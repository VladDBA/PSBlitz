<# 
.SYNOPSIS
 Outputs SQL Server health and performance diagnostics data to either Excel or HTML, 
 and saves execution plans and deadlock graphs as .sqlplan and .xdl files.

.DESCRIPTION
 Outputs the following to an Excel spreadsheet or to an HTML report:

    Instance information
    Wait stats - from sp_BlitzFirst
	Currently opened transactions (if any)
    Currently running queries - from sp_BlitzWho
    Instance health-related findings - from sp_Blitz
    tempdb size and usage information per object and session
    Index-related issues and recommendations - from sp_BlitzIndex
    Top 10 most resource intensive queries - from sp_BlitzCache
    Deadlock related information from the past 15 days - from sp_BlitzLock
	Information about all databases and their files or for a single database in 
	case of a database-specific check
	Query Store information in the case of a database-specific check on an eligible database - from 
	sp_BlitzQueryStore
    Statistics details for a given database - in the case of database-specific check or if a database 
	accounts for at least 2/3 of the sp_BlitzCache data
    Index Fragmentation information for a given database - in the case of database-specific check or if 
	a database accounts for at least 2/3 of the sp_BlitzCache data

 Note: If the execution of PSBlitz took longer than 15 minutes up until the call to sp_BlitzLock, the timeframe for 
 sp_BlitzLock will be narrowed down to the last 7 days in order to keep execution time within a reasonable amount.

 Exports the following files:

    Execution plans (as .sqlplan files) - from the same dataset generated by sp_BlitzCache
    Execution plans (as .sqlplan files) - from the sample execution plans provided by sp_BlitzIndex @Mode = 0 
	and sp_BlitzIndex @Mode = 4 for missing index suggestions (only on SQL Server 2019)
    Execution plans (as .sqlplan files) of currently running sessions - from the same dataset generated by sp_BlitzWho
    Deadlock graphs (as .xdl files) - from the same dataset generated by sp_BlitzLock
	Execution plans (as .sqlplan files) - from sp_BlitzLock if any of the execution plans involved in deadlocks are still
	in the plan cache at the time of the check
	Execution plans (as .sqlplan files) - from sp_BlitzQueryStore in the case of a database-specific check 
	on an eligible database

 PSBlitz.ps1 uses slightly modified, non-stored procedure versions, of the following components from Brent Ozar's 
 SQL Server First Responder Kit:

    sp_Blitz
    sp_BlitzCache
    sp_BlitzFirst
    sp_BlitzIndex
    sp_BlitzLock
    sp_BlitzWho
	sp_BlitzQueryStore
 
 Aside from the above scripts, PSBlitz also runs the following scripts to return sp_BlitzWho data, instance and resource 
 information, index fragmentation and stats info, database and database files info, as well as TempDB usage:

    GetDbInfo.sql
    GetBlitzWhoData.sql
    GetInstanceInfo.sql
	GetAzureSQLDBInfo.sql
    GetTempDBUsageInfo.sql
	GetStatsInfoForWholeDB.sql
	GetIndexInfoForWholeDB.sql

 Prerequisites 
    
    If you want the report to be in Excel format, then the MS Office suite needs to be installed on the machine where 
	you're executing PSBlitz, otherwise use the HTML format.
	PSBlitz will auto-default to HTML output on when ran on a host that does not have the MS Office suite installed.
	Sufficient permissions to query DMVs, server state, and get database objects' definitions.

	You don't need to have any of the sp_Blitz stored procedures present on the instance that you're executing PSBlitz.ps1 for, 
	all the scripts are contained in the PSBlitz\Resources directory in non-stored procedure format.

 Execution

    You can run PSBlitz.ps1 by simply right-clicking on the script and then clicking on "Run With PowerShell" which will execute 
    the script in interactive mode, prompting you for the required input.

    Otherwise you can navigate to the directory where the script is in PowerShell and execute it by providing parameters 
	and appropriate values.

 License
 MIT License
 Copyright for sp_Blitz, sp_BlitzCache, sp_BlitzFirst, sp_BlitzIndex, 
 sp_BlitzLock, and sp_BlitzWho is held by Brent Ozar Unlimited under MIT licence:
 SQL Server First Responder Kit - https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit

 Copyright for sp_QuickieStore is held by  Darling Data, LLC:
 DarlingData - https://github.com/erikdarlingdata/DarlingData

 Copyright for sorttable.js is held by Stuart Langridge - http://www.kryogenix.org/code/browser/sorttable/

 Copyright for PSBlitz.ps1, GetStatsInfoForWholeDB.sql, GetOpenTransactions.sql, 
 GetIndexInfoForWholeDB.sql, GetInstanceInfo.sql, and GetTempDBUsageInfo.sql 
 is held by Vlad Drumea, 2025 as described below.

 Copyright (c) 2025 Vlad Drumea - https://vladdba.com/

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.

.PARAMETER ServerName
 Accepts either HostName\InstanceID (for named instances), HostName,Port when using a port number instead of an instance ID, 
 or just HostName for default instances. If you provide either ? or Help as a value for -ServerName, 
 the script will return a brief help menu.

.PARAMETER SQLLogin
 The name of the SQL login used to run the script. If not provided, the script will use integrated security.

.PARAMETER SQLPass
 The password for the SQL login provided via the -SQLLogin parameter, omit if -SQLLogin was not used.

.PARAMETER IsIndepth
 Providing Y as a value will tell PSBlitz.ps1 to run a more in-depth check against the instance/database. 
 Omit for default check.

.PARAMETER CheckDB
 Used to provide the name of a specific database against which sp_BlitzIndex, sp_BlitzCache, 
 and sp_BlitzLock will be ran. Omit to run against the whole instance.
 Also used to provide the name of the Azure SQL DB database.

.PARAMETER CacheTop
 Used to specify if more/less than the default top 10 queries should be returned for the 
 sp_BlitzCache step. Only works for HTML output (-ToHTM Y).

.PARAMETER CacheMinutesBack
 Used to specify how many minutes back to begin plan cache analysis. 
 Defaults to entire contents of the plan cache since instance startup.
 In order to avoid missing the desired timeframe, the value is dynamically adjusted based on 
 the runtime of PSBlitz up until the plan cache analysis point.

.PARAMETER OutputDir
 Used to provide a path where the output directory should be saved to. Defaults to PSBlitz.ps1's directory 
 if not specified or a non-existent path is provided.

.PARAMETER ToHTML
 Providing Y as a value will tell PSBlitz.ps1 to output the report as HTML instead of an Excel file. 
 This is perfect when running PSBlitz from a machine that doesn't have Office installed.

.PARAMETER ZipOutput
 Providing Y as a value will tell PSBlitz.ps1 to also create a zip archive of the output files.

.PARAMETER BlitzWhoDelay
 Used to sepcify the number of seconds between each sp_BlitzWho execution. Defaults to 10 if not specified.

.PARAMETER ConnTimeout
 Can be used to increased the timeout limit in seconds for connecting to SQL Server. Defaults to 45 seconds if not specified.

.PARAMETER MaxTimeout
 Can be used to set a higher timeout for sp_BlitzIndex and Stats and Index info retrieval. Defaults to 1000 (16.6 minutes)

.PARAMETER MaxUsrDBs
 Can be used to tell PSBlitz to raise the limit of user databases based on which index-related info is 
 limited to only the "loudest" database in the cache results. Defaults to 50 - only change it if you're using using HTML output
 and have enough RAM to handle the increased data that PS will have to process.

.PARAMETER DebugInfo
 Switch used to get more information for debugging and troubleshooting purposes.

.NOTES
 Author: Vlad Drumea (VladDBA)
 Website: https://vladdba.com/

 Copyright: (c) 2025 by Vlad Drumea, licensed under MIT
 License: MIT https://opensource.org/licenses/MIT

.LINK
 https://github.com/VladDBA/PSBlitz

.EXAMPLE
 PS>.\PSBlitz.ps1 ?
 PS>.\PSBlitz.ps1 Help
 Print the help menu

.EXAMPLE
 PS>.\PSBlitz.ps1 Server01\SQL01
 Run it against the whole instance (named instance SQL01), with default checks via integrated security

.EXAMPLE 
 PS>.\PSBlitz.ps1 Server01,1433
 Run it against the whole instance listening on port 1433 on host Server01, with default checks via integrated security

.EXAMPLE
 PS>.\PSBlitz.ps1 Server01\SQL01 -IsIndepth Y
 Run it against the whole instance, with in-depth checks via integrated security

.EXAMPLE
 PS>.\PSBlitz.ps1 Server01\SQL01 -IsIndepth Y -CheckDB YourDatabase
 Run it with in-depth checks, limit sp_BlitzIndex, sp_BlitzCache, and sp_BlitzLock to YourDatabase only, via integrated security

.EXAMPLE
 PS>.\PSBlitz.ps1 Server01\SQL01 -SQLLogin DBA1 -SQLPass SuperSecurePassword
 Run it against the whole instance, with default checks via SQL login and password

.EXAMPLE
 PS>.\PSBlitz.ps1 yourserver.database.windows.net,1433:YourDatabase -SQLLogin DBA1 -SQLPass SuperSecurePassword
 Run it against the YourDatabase database hosted in Azure SQL DB at myserver.database.windows.net port 1433 via SQL login and password

.EXAMPLE
  PS>.\PSBlitz.ps1 Server02 -SQLLogin DBA1 -SQLPass SuperSecurePassword -IsIndepth Y -CheckDB YourDatabase
  Run it against a default instance residing on Server02, with in-depth checks via SQL login and password, 
 while limmiting sp_BlitzIndex, sp_BlitzCache, and sp_BlitzLock to YourDatabase only

.EXAMPLE
 PS>.\PSBlitz.ps1 Server02 -SQLLogin DBA1 -SQLPass SuperSecurePassword -IsIndepth Y -CheckDB YourDatabase -MaxTimeout 1200 -BlitzWhoDelay 20 -DebugInfo -OutputDir C:\Temp
 Run the same command as above, but increase execution timeout for sp_BlitzIndex, stats and index info retrieval, 
 while also increasing delay between sp_BlitzWHo executions as well as getting more verbose console output 
 and saving the output directory to C:\temp

.EXAMPLE
 PS>.\PSBlitz.ps1 Server01\SQL01 -ToHTML Y -ZipOutput Y
 Run PSBlitz but output the report as HTML instead of XLSX while also creating a zip archive of the output files.

.EXAMPLE
 PS>.\PSBlitz.ps1 yourserver.database.windows.net,1433:YourDatabase -SQLLogin DBA1 -SQLPass SuperSecurePassword
 Run it against the YourDatabase database hosted in Azure SQL DB at yourserver.database.windows.net port 1433 via SQL login and password

.EXAMPLE
 PS>.\PSBlitz.ps1 yourserver.database.windows.net -SQLLogin DBA1 -SQLPass SuperSecurePassword
 Run it against the Azure SQL Managed Instance yourserver.database.windows.net

.EXAMPLE
 PS>.\PSBlitz.ps1 yourserver.database.windows.net -SQLLogin DBA1 -SQLPass SuperSecurePassword -IsIndepth Y -CheckDB YourDatabase
 Run it against the Azure SQL Managed Instance yourserver.database.windows.net with an in-depth check while limiting index, stats, plan cache, and database info to YourDatabase

#>

###Input Params
##Params for running from command line
[cmdletbinding()]
param(
	[Parameter(Position = 0, Mandatory = $False)]
	[string[]]$ServerName,
	[Parameter(Mandatory = $False)]
	[string]$SQLLogin,
	[Parameter(Mandatory = $False)]
	[string]$SQLPass,
	[Parameter(Mandatory = $False)]
	[string]$IsIndepth,
	[Parameter(Mandatory = $False)]
	[string]$CheckDB,
	[Parameter(Mandatory = $False)]
	[string]$Help,
	[Parameter(Mandatory = $False)]
	[int]$BlitzWhoDelay = 10,
	[Parameter(Mandatory = $False)]
	[switch]$DebugInfo,
	[Parameter(Mandatory = $False)]
	[int]$MaxTimeout = 1000,
	[Parameter(Mandatory = $False)]
	[int]$ConnTimeout = 45,
	[Parameter(Mandatory = $False)]
	[string]$OutputDir,
	[Parameter(Mandatory = $False)]
	[string]$ToHTML = "N",
	[Parameter(Mandatory = $False)]
	[string]$ZipOutput = "N",
	[Parameter(Mandatory = $False)]
	[int]$CacheTop = 10,
	[Parameter(Mandatory = $False)]
	[int]$CacheMinutesBack = 0,
	[Parameter(Mandatory = $False)]
	[int]$MaxUsrDBs = 50
)

###Internal params
#Version
$Vers = "5.4.0"
$VersDate = "2025-05-16"
$TwoMonthsFromRelease = [datetime]::ParseExact("$VersDate", 'yyyy-MM-dd', $null).AddMonths(2)
$NowDate = Get-Date
#Get script path
$ScriptPath = split-path -parent $MyInvocation.MyCommand.Definition
#clear previous errors
$error.Clear();
#Set resources path
$ResourcesPath = Join-Path -Path $ScriptPath -ChildPath "Resources"
#Set name of the input Excel file
$OrigExcelFName = "PSBlitzOutput.xlsx"
$DefaultTimeout = 600

$ResourceList = @("PSBlitzOutput.xlsx", "spBlitz_NonSPLatest.sql",
	"spBlitzCache_NonSPLatest.sql", "spBlitzFirst_NonSPLatest.sql",
	"spBlitzIndex_NonSPLatest.sql", "spBlitzLock_NonSPLatest.sql",
	"spBlitzWho_NonSPLatest.sql",
	"GetBlitzWhoData.sql", "GetInstanceInfo.sql",
	"GetTempDBUsageInfo.sql", "GetOpenTransactions.sql",
	"GetStatsInfoForWholeDB.sql", "GetIndexInfoForWholeDB.sql",
	"GetDbInfo.sql", "GetAzureSQLDBInfo.sql",
	"GetObjectsWithDangerousOptions.sql", 
	"searchtable.js", "sorttable.js", "styles.css", "copy.js", "spQuickieStore_NonSPLatest.sql")
#Set path+name of the input Excel file
$OrigExcelF = Join-Path -Path $ResourcesPath -ChildPath $OrigExcelFName
#Set default start row for Excel output
$DefaultStartRow = 2
#BlitzWho initial pass number
$BlitzWhoPass = 1

if ($DebugInfo) {
	#Success
	$GreenCheck = @{
		Object          = [Char]8730
		ForegroundColor = 'Green'
		NoNewLine       = $true
	}
	#Failure
	$RedX = @{
		Object          = 'x (Failed)'
		ForegroundColor = 'Red'
		NoNewLine       = $true
	}
	#Command Timeout
	$RedXTimeout = @{
		Object          = 'x (Command timeout)'
		ForegroundColor = 'Red'
		NoNewLine       = $true
	}
}
else {
	#Success
	$GreenCheck = @{
		Object          = [Char]8730
		ForegroundColor = 'Green'
		NoNewLine       = $false
	}
	#Failure
	$RedX = @{
		Object          = 'x (Failed)'
		ForegroundColor = 'Red'
		NoNewLine       = $false
	}
	#Command Timeout
	$RedXTimeout = @{
		Object          = 'x (Command timeout)'
		ForegroundColor = 'Red'
		NoNewLine       = $false
	}
}

###Functions
#Function to return a brief help menu
function Get-PSBlitzHelp {
	Write-Host "`n######	PSBlitz		######`n Version $Vers - $VersDate
	`n Updates/more info: https://github.com/VladDBA/PSBlitz
	`n######	Parameters	######
-ServerName		- accepts either [hostname]\[instance] (for named instances), 
		[hostname,port], or just [hostname] for default instances
-SQLLogin		- the name of the SQL login used to run the script; if not provided, 
		the script will use integrated security
-SQLPass		- the password for the SQL login provided via the -SQLLogin parameter,
		omit if -SQLLogin was not used
-IsIndepth		- Y will run a more in-depth check against the instance/database, omit for a basic check
-CheckDB		- used to provide the name of a specific database to run some of the checks against, 
		omit to run against the whole instance
-OutputDir		- used to provide a path where the output directory should be saved to.
		Defaults to PSBlitz.ps1's directory if not specified or a non-existent path is provided.
-ToHTML			- Y will output the report as HTML instead of an Excel file.
-ZipOutput		- Y to also create a zip archive of the output files.
-BlitzWhoDelay	- used to sepcify the number of seconds between each sp_BlitzWho execution.
		Defaults to 10 if not specified
-CacheTop       - used to specify if more/less than the default top 10 queries should be returned 
        for the sp_BlitzCache step. Only works for HTML output (-ToHTM Y).
-CacheMinutesBack	- used to specify how many minutes back to begin plan cache analysis.
		Defaults to entire contents of the plan cache since instance startup.
		In order to avoid missing the desired timeframe, the value is dynamically adjusted based on 
		the runtime of PSBlitz up until the plan cache analysis point.
-MaxTimeout		- can be used to set a higher timeout for sp_BlitzIndex and Stats and Index info
		retrieval. Defaults to 1000 (16.6 minutes)
-ConnTimeout	- used to increased the timeout limit in seconds for connecting to SQL Server.
		Defaults to 15 seconds if not specified
-DebugInfo		- switch used to get more information for debugging and troubleshooting purposes.
`n######	Execution	######
You can either run the script directly in PowerShell from its directory:
 Run it against the whole instance (named instance SQL01), with default checks via integrated security"
	Write-Host ".\PSBlitz.ps1 Server01\SQL01" -fore green
	Write-Host "`n Same as the above, but have sp_BlitzWho execute every 5 seconds instead of 10"
	Write-Host ".\PSBlitz.ps1 Server01\SQL01 -BlitzWhoDelay 5" -fore green
	Write-Host "`n Run it against an instance listening on port 1433 on Server01"
	Write-Host ".\PSBlitz.ps1 Server01,1433" -fore green
	Write-Host "`n Run it against a default instance installed on Server01"
	Write-Host ".\PSBlitz.ps1 Server01" -fore green
	Write-Host "`n Run it against the whole instance, with in-depth checks via integrated security"
	Write-Host ".\PSBlitz.ps1 Server01\SQL01 -IsIndepth Y" -fore green
	Write-Host "`n Run it against the whole instance and output the report as HTML"
	Write-Host ".\PSBlitz.ps1 Server01\SQL01 -IsIndepth Y -ToHTML Y" -fore green
	Write-Host "`n Run it with in-depth checks, limit sp_BlitzIndex, sp_BlitzCache, and sp_BlitzLock to 
YourDatabase only, via integrated security"
	Write-Host ".\PSBlitz.ps1 Server01\SQL01 -IsIndepth Y -CheckDB YourDatabase" -fore green
	Write-Host "`n Run it against the whole instance, with default checks via SQL login and password"
	Write-Host ".\PSBlitz.ps1 Server01\SQL01 -SQLLogin DBA1 -SQLPass SuperSecurePassword" -fore green
	Write-Host "`n Run it against the YourDatabase database hosted in Azure SQL DB at myserver.database.windows.net port 1433 via SQL login and password"
	Write-Host "\PSBlitz.ps1 yourserver.database.windows.net,1433:YourDatabase -SQLLogin DBA1 -SQLPass SuperSecurePassword"
	Write-Host "`n Or you can run it in interactive mode by just right-clicking on the PSBlitz.ps1 file 
-> 'Run with PowerShell', and the script will prompt you for input.
`n######	What it runs	######
PSBlitz.ps1 uses slightly modified, non-stored procedure versions, of the following components 
from Brent Ozar's FirstResponderKit (https://www.brentozar.com/first-aid/):
   sp_Blitz
   sp_BlitzCache
   sp_BlitzFirst
   sp_BlitzIndex
   sp_BlitzLock
   sp_BlitzWho
   sp_BlitzQueryStore
`n You can find the scripts in the '$ResourcesPath' directory
"
}
#Function to execute sp_BlitzWho
function Invoke-BlitzWho {
	param (
		[string]$BlitzWhoQuery,
		[string]$IsInLoop
	)
	if ($IsInLoop -eq "Y") {
		Write-Host " ->Active session data capture - pass $BlitzWhoPass... " -NoNewLine
	}
 else {
		Write-Host " Active session data capture - pass $BlitzWhoPass... " -NoNewLine
	}
	$StepStart = Get-Date
	$StepName = "sp_BlitzWho - pass $BlitzWhoPass"
	$BlitzWhoCommand = new-object System.Data.SqlClient.SqlCommand
	$BlitzWhoCommand.CommandText = $BlitzWhoQuery
	$BlitzWhoCommand.CommandTimeout = 120
	$SqlConnection.Open()
	$BlitzWhoCommand.Connection = $SqlConnection
	Try {
		$BlitzWhoCommand.ExecuteNonQuery() | Out-Null -ErrorAction Stop
		$SqlConnection.Close()
		Write-Host @GreenCheck
		$StepEnd = Get-Date
		Add-LogRow $StepName "Success"
	}
 Catch {
		Write-Host @RedX
		$StepEnd = Get-Date
		Add-LogRow $StepName "Failure"
	}
}

#Function to properly format XML contents for deadlock graphs and execution plans
function Format-XML {
	[CmdletBinding()]
	Param ([
		Parameter(ValueFromPipeline = $true, Mandatory = $true)]
		[string]$XMLContent)
	$XMLDoc = New-Object -TypeName System.Xml.XmlDocument
	$XMLDoc.LoadXml($XMLContent)
	$SW = New-Object System.IO.StringWriter
	$Writer = New-Object System.Xml.XmlTextwriter($SW)
	$Writer.Formatting = [System.XML.Formatting]::Indented
	$XMLDoc.WriteContentTo($Writer)
	$SW.ToString()
}

#Function to format exception messages
function Format-ExceptionMsg {
	$ErrorMessage = $error[0] 
	
	[string]$ErrorMessageString = $ErrorMessage | Select-Object -ExpandProperty Exception | Select-Object -ExpandProperty Message
	try {
		
		[string]$SQLErrNo = $ErrorMessage | Select-Object -ExpandProperty Exception | Select-Object -ExpandProperty InnerException | Select-Object -ExpandProperty Number -ErrorAction Ignore
		if (!([string]::IsNullOrEmpty($SQLErrNo))) {
			#Get SQL related error info
			[string]$SQLErrState = $ErrorMessage | Select-Object -ExpandProperty Exception | Select-Object -ExpandProperty InnerException | Select-Object -ExpandProperty State -ErrorAction Stop
			[string]$SQLErrLev = $ErrorMessage | Select-Object -ExpandProperty Exception | Select-Object -ExpandProperty InnerException | Select-Object -ExpandProperty Class
			[string]$SQLErrState = $ErrorMessage | Select-Object -ExpandProperty Exception | Select-Object -ExpandProperty InnerException | Select-Object -ExpandProperty State
			[string]$SQLErrLineNo = $ErrorMessage | Select-Object -ExpandProperty Exception | Select-Object -ExpandProperty InnerException | Select-Object -ExpandProperty LineNumber
			[string]$SQLErrMsg = $ErrorMessage | Select-Object -ExpandProperty Exception | Select-Object -ExpandProperty InnerException | Select-Object -ExpandProperty Message
			##formatting the error message in SQL Server style if there's an error number
			Write-Output "SQL Error: MSg $SQLErrNo, Level $SQLErrLev, State $SQLErrState, Line $SQLErrLineNo `n $SQLErrMsg"
		}
		else {
			#Get PS related error info
			[string]$PSErrMsg = $ErrorMessageString
			[string]$PSErrLine = $ErrorMessage | Select-Object -ExpandProperty InvocationInfo | Select-Object -ExpandProperty ScriptLineNumber -ErrorAction Stop
			[string]$PSErrStatement = $ErrorMessage | Select-Object -ExpandProperty InvocationInfo | Select-Object -ExpandProperty Line
			if (!([string]::IsNullOrEmpty($PSErrStatement))) {
				$PSErrStatement = $PSErrStatement.Trim()
			}
			if (!([string]::IsNullOrEmpty($PSErrMsg))) {
				Write-Output "PS Error: Script Line $PSErrLine `n Message $PSErrMsg `n Statement $PSErrStatement"
			}
			else {
				Write-Output "No exceptions encountered."
			}			
		}
	}
 catch {

		Write-Output $ErrorMessageString
	}
}
#Function to return error messages in the catch block
function Invoke-ErrMsg {
	$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
	$RunTime = [Math]::Round($StepRunTime, 2)
	if ($RunTime -ge $CmdTimeout) {
		Write-Host @RedXTimeout
		if ($DebugInfo) {
			Write-Host " - $RunTime seconds" -Fore Yellow
		}
		$OutErr = Format-ExceptionMsg
		Write-Host "  $OutErr" -fore Red	
	}
 else {
		Write-Host @RedX
		if ($DebugInfo) {
			Write-Host " - $RunTime seconds" -Fore Yellow
		}
		$OutErr = Format-ExceptionMsg
		Write-Host "  $OutErr" -fore Red		
	}
}

function Get-ExecTime {
	$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
	[string]$StepDUration = [Math]::Round($StepRunTime, 2).ToString()
	Write-Output $StepDUration
}
function Add-LogRow {
	[CmdletBinding()]
	Param ([
		Parameter(Position = 0, Mandatory = $true)]
		[string]$StepName,
		[Parameter(Position = 1, Mandatory = $true)]
		[string]$StepStatus,
		[Parameter(Position = 2, Mandatory = $false)]
		[string]$MoreInfo = ""
	)
	$ExecTime = Get-ExecTime
	$ErrMsg = Format-ExceptionMsg
	$LogRow = $LogTbl.NewRow()
	$LogRow.Step = $StepName
	$LogRow.StartDate = $StepStart.ToString("yyyy-MM-dd HH:mm:ss")
	$LogRow.EndDate = $StepEnd.ToString("yyyy-MM-dd HH:mm:ss")
	$LogRow."Duration (Seconds)" = $ExecTime
	$LogRow.Outcome = $StepStatus
	if ("Interrupted", "Failure" -contains $StepStatus ) {
		$LogRow.Message = $ErrMsg
	}
 elseif ($StepStatus -eq "Success") {
		$LogRow.Message = $MoreInfo
	}
	else {
		$LogRow.Message = $MoreInfo
	}
	$LogTbl.Rows.Add($LogRow)
}

function Invoke-PSBlitzQuery {
	param (
		[Parameter(Position = 0, Mandatory = $true)]
		[string]$QueryIn,
		[Parameter(Position = 1, Mandatory = $true)]
		[string]$StepNameIn,
		[Parameter(Position = 2, Mandatory = $true)]
		[string]$ConnStringIn,
		[Parameter(Position = 3, Mandatory = $true)]
		[int]$CmdTimeoutIn
	)
	$global:PSBlitzSet = New-Object System.Data.DataSet
	$IBQConnection = New-Object System.Data.SqlClient.SqlConnection
	$IBQConnection.ConnectionString = $ConnStringIn
	$IBQCommand = $IBQConnection.CreateCommand()
	$IBQCommand.CommandText = $QueryIn
	$IBQCommand.CommandTimeout = $CmdTimeoutIn
	$IBQAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
	$IBQAdapter.SelectCommand = $IBQCommand

	Try {
		$StepStart = get-date
		$IBQConnection.Open()
		$IBQAdapter.Fill($global:PSBlitzSet) | Out-Null -ErrorAction Stop
		$StepEnd = get-date
		Write-Host @GreenCheck
		$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
		$RunTime = [Math]::Round($StepRunTime, 2)
		if ($DebugInfo) {
			Write-Host " - $RunTime seconds" -Fore Yellow
		}
		$global:StepOutcome = "Success"
		if (($StepNameIn -like "sp_BlitzCache*") -or ($StepNameIn -like "sp_BlitzQueryStore*") -or 
		($StepNameIn -eq "sp_BlitzIndex mode 1") -or ($StepNameIn -eq "Stats Info") -or ($StepNameIn -eq "Index Frag Info") -or 
		($StepNameIn -eq "sp_BlitzLock") -or ($StepNameIn -eq "Return sp_BlitzWho") -or ($StepNameIn -eq "Open Transacion Info") -or 
		($StepNameIn -eq "Objects with dangerous SET options") -or ($StepNameIn -eq "sp_Blitz") -or 
		($StepNameIn -eq "sp_BlitzFirst 30 seconds") -or ($StepNameIn -like "Query Store check *")) {
			$RecordsReturned = $global:PSBlitzSet.Tables[0].Rows.Count
			Add-LogRow $StepNameIn $global:StepOutcome "$RecordsReturned records returned"
		}
		elseif ('Stats Info', 'sp_BlitzIndex mode 0', 'sp_BlitzIndex mode 2', 'sp_BlitzIndex mode 4' -contains $StepNameIn) {
			$RecordsReturned = $global:PSBlitzSet.Tables[0].Rows.Count
			Add-LogRow $StepNameIn $global:StepOutcome "$RecordsReturned records returned"
			$TotalRecords = $global:PSBlitzSet.Tables[1].Rows[0]["RecordCount"]
			if ($TotalRecords -gt $RecordsReturned) {
				Add-LogRow "->$StepNameIn" "Record limit exceeded" "Result was limited to top $RecordsReturned records out of $TotalRecords"
				Write-Host "  ->Record limit exceeded `n -> Result was limited to top $RecordsReturned records out of $TotalRecords" -Fore Yellow
			}
		}
		else {
			Add-LogRow $StepNameIn $global:StepOutcome
		}
	}
 Catch {
		$StepEnd = get-date
		Invoke-ErrMsg
		$global:StepOutcome = "Failure"
		Add-LogRow $StepNameIn $global:StepOutcome
	}
	Finally {
		$IBQConnection.Close()
		$IBQConnection.Dispose()
	}
}
function Convert-TableToHtml {
	param (
		[Parameter(Position = 0, Mandatory = $true)]
		[System.Data.DataTable] $DataTable,
		[Parameter(Mandatory = $false)]
		[switch] $DebugInfo,
		[Parameter(Mandatory = $false)]
		[switch] $HasURLs,
		[Parameter(Mandatory = $false)]
		[string] $HyperlinkCol = 'x',
		[Parameter(Mandatory = $false)]
		[string[]] $ExclCols,
		[Parameter(Mandatory = $false)]
		[string[]] $DateTimeCols,
		[Parameter(Mandatory = $false)]
		[string] $CSSClass,
		[Parameter(Mandatory = $false)]
		[string] $TblID,
		[Parameter(Mandatory = $false)]
		[switch] $NoCaseChange,
		[Parameter(Mandatory = $false)]
		[switch] $AnchorFromHere,
		[Parameter(Mandatory = $false)]
		[switch] $AnchorToHere,
		[Parameter(Mandatory = $false)]
		[string[]] $AnchorIDs,
		[Parameter(Mandatory = $false)]
		[string] $AnchorExt = '.query'
	)

	try {
		if ($DebugInfo) {
			Write-Host " ->Converting data to HTML... " -ForegroundColor Yellow -NoNewline
			$StepStart = get-date
		}
		$properties = @()
		$cultureInfo = [System.Globalization.CultureInfo]::CurrentCulture
        
		foreach ($column in $DataTable.Columns) {
			if ($ExclCols -contains $column.ColumnName) { continue }
            
			$currentColumn = $column.ColumnName
			$formattedName = if ($currentColumn -like "*_*") {
				$cultureInfo.TextInfo.ToTitleCase(($currentColumn -replace "_", " "))
			}
			elseif ($currentColumn -like "* *") {
				$cultureInfo.TextInfo.ToTitleCase($currentColumn)
			}
			elseif ($NoCaseChange -eq $true) {
				$currentColumn
			}
			else {
				$cultureInfo.TextInfo.ToTitleCase($currentColumn)
			}
			#handle lower case KB, MB, GB
			if ($formattedName -like "*kb*" -or $formattedName -like "*mb*" -or $formattedName -like "*gb*") {
				$formattedName = $formattedName -replace "([KMG])b", '$1B'
			}
			#handle mixed case ms
			if ($formattedName -like "*ms" -or $formattedName -like "*ms)") {
				$pattern = "(?-i)Ms"
				$formattedName = $formattedName -replace $pattern , "ms"
			}

			$property = if ($DateTimeCols -contains $currentColumn) {
				@{
					Name       = $formattedName
					Expression = [ScriptBlock]::Create('if ($_["' + $currentColumn + '"] -and $_["' + $currentColumn + '"] -ne [System.DBNull]::Value) { $_["' + $currentColumn + '"].ToString("yyyy-MM-dd HH:mm:ss") } else { $_["' + $currentColumn + '"] }')
				}
			}
			else {
				@{
					Name       = $formattedName
					Expression = [ScriptBlock]::Create('$_["' + $currentColumn + '"]')
				}
			}
			$properties += $property
		}

		$htmlTableOut = $DataTable | Select-Object -Property $properties | ConvertTo-Html -As Table -Fragment
        
		if (($CSSClass) -and ($TblID)) {
			$htmlTableOut = $htmlTableOut -replace "<table>", "<table id='$TblID' class='$CSSClass'>"
		}
		elseif ($CSSClass) {
			$htmlTableOut = $htmlTableOut -replace "<table>", "<table class='$CSSClass'>"
			#clean up XML noise and extra charcters in specific tables
            if ($CSSClass -eq "CacheTabx") {
				$htmlTableOut = $htmlTableOut -replace "<td>&lt;\?ClickMe ", "<td>"
				$htmlTableOut = $htmlTableOut -replace "\?&gt;</td>", "</td>"
				$htmlTableOut = $htmlTableOut -replace "<td>&lt;MissingIndexes&gt;", "<td>"
				$htmlTableOut = $htmlTableOut -replace "&lt;/MissingIndexes&gt;</td>", "</td>"
			}
			elseif ($CSSClass -eq "Top10ClientConnTbl") {
				$htmlTableOut = $htmlTableOut -replace "; </td>", "</td>"
			}
			elseif($CSSClass -like "QueryStoreTab*"){
				$htmlTableOut = $htmlTableOut -replace " ms\)", "&nbsp;ms)"
				$htmlTableOut = $htmlTableOut -replace " \(", "&nbsp;("
			}
		}
		elseif ($TblID) {
			$htmlTableOut = $htmlTableOut -replace "<table>", "<table id='$TblID'>"
		}
        if($HyperlinkCol -ne 'x'){
			# fix hyperlinks
			$htmlTableOut = $htmlTableOut -replace "&lt;a href=&#39;","<a href='"
			$htmlTableOut = $htmlTableOut -replace "&#39; target=&#39;_blank&#39;&gt;", "' target='_blank'>"
			$htmlTableOut = $htmlTableOut -replace "&lt;/a&gt;","</a>"
			#fix column name
			$HyperlinkColClean = $HyperlinkCol -replace 'HL',''
			$htmlTableOut = $htmlTableOut -replace "<th>$HyperlinkCol</th>","<th>$HyperlinkColClean</th>"
		}
		if ($HasURLs) {
			$URLRegex = '(?i)\b((?:https?://|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:\".,<>?«»“”]))'
			$htmlTableOut = $htmlTableOut -replace $URLRegex, '<a href="$&" target="_blank">$&</a>'
		}
		if ($AnchorFromHere) {
			foreach ($AnchorID in $AnchorIDs) {
				$AnchorRegex = if ($TblID -eq "DeadlockDtlTable") {
					"DL(\d+)Q(\d+)V{0,}$AnchorExt"
				}
				else { "$AnchorID(_\d+)$AnchorExt" }
				$AnchorURL = '<a href="#$&">$&</a>'
				$htmlTableOut = $htmlTableOut -replace $AnchorRegex, $AnchorURL
			}
		}
		if ($DebugInfo) {
			$StepEnd = get-date
			Write-Host @GreenCheck
			$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
			$RunTime = [Math]::Round($StepRunTime, 2)
			Write-Host " - $RunTime seconds" -Fore Yellow
			Add-LogRow "->Convert data to HTML" "Success"
		}
        
		return $htmlTableOut
	}
	catch {
		Invoke-ErrMsg
		if ($DebugInfo) {
			Add-LogRow "->Convert data to HTML" "Failure"
		}
	}
}

function Convert-QueryTableToHtml {
	param (
		[Parameter(Position = 0, Mandatory = $true)]
		[System.Data.DataTable] $DataTable,
		[Parameter(Mandatory = $false)]
		[switch] $DebugInfo,
		[Parameter(Mandatory = $false)]
		[string[]] $Cols,
		[Parameter(Mandatory = $false)]
		[switch] $AnchorToHere,
		[Parameter(Mandatory = $false)]
		[string] $CSSClass,
		[Parameter(Mandatory = $false)]
		[string] $AnchorID,
		[Parameter(Mandatory = $false)]
		[string] $AnchorExt = '.query'
	)
	try {
		if ($DebugInfo) {
			Write-Host " ->Converting query data to HTML... " -ForegroundColor Yellow -NoNewline
			$StepStart = get-date
		}

		$properties = @()
		$cultureInfo = [System.Globalization.CultureInfo]::CurrentCulture
		foreach ($column in $Cols) {
			$currentColumn = $column
			$formattedName = if ("current_query", "most_recent_query" -contains $currentColumn) {
				"Query"
			} 
			elseif ("current_sql", "most_recent_sql", "query_sql_text" -contains $currentColumn) {
				"Query Text"
			}
			elseif ($currentColumn -like "*_*") {
				$cultureInfo.TextInfo.ToTitleCase(($currentColumn -replace "_", " "))
			}
			elseif ($currentColumn -like "* *") {
				$cultureInfo.TextInfo.ToTitleCase($currentColumn)
			}
			else {
				$cultureInfo.TextInfo.ToTitleCase($currentColumn)
			}
			$property = @{
				Name       = $formattedName
				Expression = [ScriptBlock]::Create('$_["' + $currentColumn + '"]')
			}
			$properties += $property
		}
		$htmlTableOut = $DataTable | Select-Object -Property $properties | ConvertTo-Html -As Table -Fragment

		if ($AnchorToHere) {
			if ($AnchorID -eq "DeadlockDtlTable") {
				$AnchorRegex = "<td>DL(\d+)Q(\d+)(V{0,})$AnchorExt"
				$AnchorURL = '<td id=' + "DL" + '$1' + "Q" + '$2' + '$3' + "$AnchorExt>" + "DL" + '$1' + "Q" + '$2' + '$3' + "$AnchorExt"
			}
			else {
				$AnchorRegex = "<td>$AnchorID(_\d+)$AnchorExt"
				$AnchorURL = '<td id=' + "$AnchorID" + '$1' + "$AnchorExt>" + "$AnchorID" + '$1' + "$AnchorExt"
			}

			$htmlTableOut = $htmlTableOut -replace $AnchorRegex, $AnchorURL
		}
		#Ensure CRLF displays correctly in HTML
		if($CSSClass){
			$htmlTableOut = $htmlTableOut -replace "<table>", "<table class='$CSSClass'>"
		} else{
		$htmlTableOut = $htmlTableOut -replace '<table>', '<table style="white-space:pre-wrap; word-wrap:normal">'
		}
		#Lazy way to remove empty rows, will try to fix later 
		$htmlTableOut = $htmlTableOut -replace "<tr><td></td><td></td></tr>", ""
		if ($DebugInfo) {
			$StepEnd = get-date
			Write-Host @GreenCheck
			$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
			$RunTime = [Math]::Round($StepRunTime, 2)
			Write-Host " - $RunTime seconds" -Fore Yellow
			Add-LogRow "->Convert query data to HTML" "Success"
		}
		return $htmlTableOut
	}
 catch {
		#Write-Host " Error converting query table to HTML: $_" -ForegroundColor Red
		Invoke-ErrMsg
		if ($DebugInfo) {
			Add-LogRow "->Convert query data to HTML" "Failure"
		}
	}

}

function Export-PlansAndDeadlocks {
	param (
		[Parameter(Position = 0, Mandatory = $true)]
		[System.Data.DataTable] $DataTable,
		[Parameter(Position = 1, Mandatory = $true)]
		[string] $FileDir,
		[Parameter(Position = 2, Mandatory = $True)]
		[string] $XMLColName,
		[Parameter(Position = 3, Mandatory = $True)]
		[string] $FNameColName,
		[Parameter(Position = 4, Mandatory = $false)]
		[string] $OutputType = 'sqlplan',
		[Parameter(Position = 5, Mandatory = $false)]
		[string] $FPrefix = '',
		[Parameter(Position = 6, Mandatory = $false)]
		[switch] $DebugInfo,
		[Parameter(Position = 7, Mandatory = $false)]
		[switch] $FileNameFromColumn
	)
	try {
		if ($DebugInfo) {
			Write-Host " ->Exporting $(if($XMLColName -eq 'deadlock_graph'){"deadlock graphs"}
			else{"execution plans"})... " -ForegroundColor Yellow -NoNewline
			$StepStart = get-date
		}
		$RowNum = 0
		$i = 0
		foreach ($row in $DataTable) {
			$i += 1
			$FileName = "-- N/A --"
			if (($DataTable.Rows[$RowNum][$XMLColName] -ne [System.DBNull]::Value) -and 
			    (($DataTable.Rows[$RowNum][$FNameColName] -like "Deadlock*") -or
			      ($XMLColName -ne "deadlock_graph")) ) {
				if ($FileNameFromColumn) {
					$FileName = $DataTable.Rows[$RowNum][$FNameColName]
				}
				else {
					$FileName = $FPrefix + '_' + $i + '.' + $OutputType
				}
				$DataTable.Rows[$RowNum][$XMLColName] | Format-XML | Set-Content -Path "$FileDir\$FileName" -Force
			}
			if ($FileNameFromColumn -eq $false) {
				$DataTable.Rows[$RowNum][$FNameColName] = $FileName
			}			
			$RowNum += 1			
		}

		if ($DebugInfo) {
			$StepEnd = get-date
			Write-Host @GreenCheck
			$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
			$RunTime = [Math]::Round($StepRunTime, 2)
			Write-Host " - $RunTime seconds" -Fore Yellow
		}
	}
	catch {
		Invoke-ErrMsg
		#Write-Host " Error exporting deadlock and plan data: $_" -ForegroundColor Red
	}
}

function Add-QueryName {
	param (
		[Parameter(Position = 0, Mandatory = $true)]
		[System.Data.DataTable] $DataTable,
		[Parameter(Position = 1, Mandatory = $true)]
		[string] $QueryNameColName,
		[Parameter(Position = 2, Mandatory = $true)]
		[string] $QueryTextColName,
		[Parameter(Position = 3, Mandatory = $true)]
		[string] $QPrefix
	)
	try {
		$RowNum = 0
		$i = 0
		foreach ($row in $DataTable) {
			if ($DataTable.Rows[$RowNum][$QueryTextColName] -ne [System.DBNull]::Value) {
				$i += 1
				$QueryName = $QPrefix + "_" + $i + ".query"					
			}
			else { $QueryName = "-- N/A --" }
			$DataTable.Rows[$RowNum][$QueryNameColName] = $QueryName
			$RowNum += 1
		}
	}
	catch {
		Write-Host " Error adding query names: $_" -ForegroundColor Red
	}
}

function Convert-TableToExcel {
	param (
		[Parameter(Position = 0, Mandatory = $true)]
		[System.Data.DataTable]$DataTable,
		[Parameter(Position = 1, Mandatory = $true)]
		$ExcelSheet,
		[Parameter(Mandatory = $false)]
		[int]$StartRow = 1,
		[Parameter(Mandatory = $false)]
		[int]$StartCol = 1,
		[Parameter(Mandatory = $false)]
		[string[]]$ColumnOrder,
		[Parameter(Mandatory = $false)]
		[string[]]$ExclCols,
		[Parameter(Mandatory = $false)]
		[string[]]$URLCols,
		[Parameter(Mandatory = $false)]
		[switch]$DebugInfo,
		[Parameter(Mandatory = $false)]
		[int]$MapURLToColNum,
		[Parameter(Mandatory = $false)]
		[string]$URLTextCol
	)

	try {
		$StepStart = get-date
		$ExcelStartRow = $StartRow
		$ExcelColNum = $StartCol
		$RowNum = 0

		# Determine columns to process
		$DataSetCols = if ($ColumnOrder) {
			$ColumnOrder
		}
		else {
			$DataTable.Columns.ColumnName | Where-Object { $ExclCols -notcontains $_ }
		}

		if ($DebugInfo) {
			Write-Host " ->Writing data to Excel worksheet... " -ForegroundColor Yellow -NoNewline
			$StepStart = get-date
		}

		foreach ($row in $DataTable) {
			foreach ($col in $DataSetCols) {
				[string]$global:DebugCol = $col
				[string]$global:DebugValue = $DataTable.Rows[$RowNum][$col]
				if ($URLCols -contains $col) {
					if ($DataTable.Rows[$RowNum][$col] -like "http*") {
						$ExcelSheet.Hyperlinks.Add(
							$ExcelSheet.Cells.Item($ExcelStartRow, $MapURLToColNum),
							$DataTable.Rows[$RowNum][$col],
							"",
							"Click for more info",
							$DataTable.Rows[$RowNum][$URLTextCol]
						) | Out-Null
					}
				}
				else {
					$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $DataTable.Rows[$RowNum][$col]
				}
				$ExcelColNum += 1
			}

			$ExcelStartRow += 1
			$RowNum += 1
			$ExcelColNum = $StartCol
		}
		if ($DebugInfo) {
			$StepEnd = get-date
			Write-Host @GreenCheck
			$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
			$RunTime = [Math]::Round($StepRunTime, 2)
			Write-Host " - $RunTime seconds" -Fore Yellow
			Add-LogRow "->Write data to Excel worksheet" "Success"
		}
		
	}
 catch {
		Invoke-ErrMsg
		#Write-Host " Error converting table to Excel: $_" -ForegroundColor Red
		Write-Host "  Debug Column: $global:DebugCol"
		Write-Host "  Debug Value: $global:DebugValue"
		if ($DebugInfo) {
			Add-LogRow "->Write data to Excel worksheet" "Failure"
		}
	}
}

function Save-ExcelFile {
	param (
		[Parameter(Position = 0, Mandatory = $true)]
		$ExcelFile,
		[Parameter(Position = 1, Mandatory = $false)]
		[switch]$DebugInfo
	)
	try {
		$ExcelFile.Save()
		if ($DebugInfo) {
			Write-Host " ->Excel file saved successfully" -ForegroundColor Yellow
		}
	}
	catch {
		Write-Host " Error saving Excel file: $_" -ForegroundColor Red
	}

}

function Save-HtmlFile {
	param (
		[Parameter(Position = 0, Mandatory = $true)]
		$HtmlData,
		[Parameter(Position = 1, Mandatory = $true)]
		[string]$HtmlFileName,
		[Parameter(Position = 2, Mandatory = $true)]
		[string]$HtmlOutputDir,
		[Parameter(Position = 3, Mandatory = $false)]
		[switch]$DebugInfo,
		[Parameter(Position = 4, Mandatory = $false)]
		[string]$AdditionalInfo = ''
	)
	if ($HtmlFileName -notlike "*.html") {
		$HtmlFileName = $HtmlFileName + ".html"
	}
	try {
		$HTMLFilePath = Join-Path -Path $HtmlOutputDir -ChildPath $HtmlFileName
		$HtmlData | Out-File -Encoding utf8 -FilePath "$HTMLFilePath"
		if ($DebugInfo) {
			Write-Host " ->$($AdditionalInfo)HTML file saved successfully" -ForegroundColor Yellow
		}
	}
	catch {
		Write-Host " Error saving HTML file: $_" -ForegroundColor Red
	}
}

function Invoke-ClearVariables {
	[Parameter(Position = 0, Mandatory = $true)]
	[string[]]$VarNames

	foreach ($Var in $VarNames) {
		Clear-Variable -Name $Var #-ErrorAction SilentlyContinue
		Remove-Variable -Name $Var #-ErrorAction SilentlyContinue
	}
}

###Background Job preparation
#sp_BlitzWho
$InitScriptBlock = {
	function Invoke-BlitzWho {
		param (
			[string]$BlitzWhoQuery
		)
		$BlitzWhoCommand = new-object System.Data.SqlClient.SqlCommand
		$BlitzWhoCommand.CommandText = $BlitzWhoQuery
		#increased BlitzWho command timeout from 20 to 60 because some people have been getting errors
		#considering setting @ExpertMode = 0 if this keeps up
		$BlitzWhoCommand.CommandTimeout = 60
		$SqlConnection.Open()
		$BlitzWhoCommand.Connection = $SqlConnection
		$BlitzWhoCommand.ExecuteNonQuery() | Out-Null 
		$SqlConnection.Close()
	}
	function Format-ExceptionMsg {
		$ErrorMessage = $error[0] 
		
		[string]$ErrorMessageString = $ErrorMessage | Select-Object -ExpandProperty Exception | Select-Object -ExpandProperty Message
		try {
			
			[string]$SQLErrNo = $ErrorMessage | Select-Object -ExpandProperty Exception | Select-Object -ExpandProperty InnerException | Select-Object -ExpandProperty Number -ErrorAction Ignore
			if (!([string]::IsNullOrEmpty($SQLErrNo))) {
				#Get SQL related error info
				[string]$SQLErrState = $ErrorMessage | Select-Object -ExpandProperty Exception | Select-Object -ExpandProperty InnerException | Select-Object -ExpandProperty State -ErrorAction Stop
				[string]$SQLErrLev = $ErrorMessage | Select-Object -ExpandProperty Exception | Select-Object -ExpandProperty InnerException | Select-Object -ExpandProperty Class
				[string]$SQLErrLineNo = $ErrorMessage | Select-Object -ExpandProperty Exception | Select-Object -ExpandProperty InnerException | Select-Object -ExpandProperty LineNumber
				[string]$SQLErrMsg = $ErrorMessage | Select-Object -ExpandProperty Exception | Select-Object -ExpandProperty InnerException | Select-Object -ExpandProperty Message
				##formatting the error message in SQL Server style if there's an error number
				Write-Output "SQL Error: MSg $SQLErrNo, Level $SQLErrLev, State $SQLErrState, Line $SQLErrLineNo `n $SQLErrMsg"
			}
			else {
				#Get PS related error info
				[string]$PSErrMsg = $ErrorMessageString
				[string]$PSErrLine = $ErrorMessage | Select-Object -ExpandProperty InvocationInfo | Select-Object -ExpandProperty ScriptLineNumber -ErrorAction Stop
				[string]$PSErrStatement = $ErrorMessage | Select-Object -ExpandProperty InvocationInfo | Select-Object -ExpandProperty Line
				if (!([string]::IsNullOrEmpty($PSErrStatement))) {
					$PSErrStatement = $PSErrStatement.Trim()
				}
				if (!([string]::IsNullOrEmpty($PSErrMsg))) {
					Write-Output "PS Error: Script Line $PSErrLine `n Message $PSErrMsg `n Statement $PSErrStatement"
				}
				else {
					Write-Output "No exceptions encountered."
				}			
			}
		}
	 catch {
			Write-Output $ErrorMessageString
		}
	}
	function Invoke-FlagTableCheck {
		param (
			[string]$FlagTblDt
		)
		$CheckFlagTblQuery = new-object System.Data.SqlClient.SqlCommand
		$FlagTblQuery = "DECLARE @FlagTable NVARCHAR(300); `n SELECT @FlagTable = CASE "
		$FlagTblQuery += "WHEN CAST(SERVERPROPERTY('Edition') AS NVARCHAR(128)) = N'SQL Azure' "
		$FlagTblQuery += "`nAND SERVERPROPERTY('EngineEdition') IN (5, 6) "
		$FlagTblQuery += "`nTHEN  N'BlitzWhoOutFlag_$FlagTblDt' ELSE "
		$FlagTblQuery += "`nN'tempdb.dbo.BlitzWhoOutFlag_$FlagTblDt' END; "
		$FlagTblQuery += "`nSELECT CASE WHEN OBJECT_ID(@FlagTable, N'U') IS NOT NULL "
		$FlagTblQuery += "`nTHEN 'Y' ELSE 'N' END AS [FlagFound];"
		$CheckFlagTblQuery.CommandText = $FlagTblQuery
		$CheckFlagTblQuery.Connection = $SqlConnection
		$CheckFlagTblQuery.CommandTimeout = 30
		$CheckFlagTblAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
		$CheckFlagTblAdapter.SelectCommand = $CheckFlagTblQuery
		$CheckFlagTblSet = new-object System.Data.DataSet
		Try {
			$CheckFlagTblAdapter.Fill($CheckFlagTblSet) | Out-Null -ErrorAction Stop
			$SqlConnection.Close()
			[string]$IsFlagTbl = $CheckFlagTblSet.Tables[0].Rows[0]["FlagFound"]
            
		}
		Catch {
			[string]$IsFlagTbl = "X"
            
		}
		if ($IsFlagTbl -eq "Y") {
			$CleanupCommand = new-object System.Data.SqlClient.SqlCommand
			$Cleanup = "DECLARE @SQL NVARCHAR(400);`nSELECT @SQL = N'DROP TABLE '+ CASE "
			$Cleanup += "`nWHEN CAST(SERVERPROPERTY('Edition') AS NVARCHAR(100)) = N'SQL Azure' "
			$Cleanup += "`nAND SERVERPROPERTY('EngineEdition') IN (5, 6) "
			$Cleanup += "`nTHEN N'[BlitzWhoOutFlag_$FlagTblDt];' "
			$Cleanup += "`nELSE N'[tempdb].[dbo].[BlitzWhoOutFlag_$FlagTblDt];' `nEND; `nEXEC(@SQL);"
			$CleanupCommand.CommandText = $Cleanup
			$CleanupCommand.CommandTimeout = 20
			$SqlConnection.Open()
			$CleanupCommand.Connection = $SqlConnection
			$CleanupCommand.ExecuteNonQuery() | Out-Null 
			$SqlConnection.Close()
			$SqlConnection.Dispose()
		}
		return $IsFlagTbl
	}
}

$MainScriptblock = {
	Param([string]$ConnStringIn , [string]$BlitzWhoIn, [string]$DirDateIn, [int]$BlitzWhoDelayIn)
	$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
	$SqlConnection.ConnectionString = $ConnStringIn
	[int]$SuccessCount = 0
	[int]$FailedCount = 0
	[int]$FlagCheckRetry = 0    
	[string]$IsFlagTbl = "N"
	[string]$FlagErrCheck = "N"
	while (($IsFlagTbl -ne "Y") -and ($FlagCheckRetry -le 3)) {

		Try {
			Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoIn 
			$SuccessCount += 1
		}
		Catch {
			$FailedCount += 1
		}
		[string]$IsFlagTbl = Invoke-FlagTableCheck -FlagTblDt $DirDateIn
		#Reset retry count if failures aren't consecutive
		if (($FlagErrCheck -eq "X") -and ($IsFlagTbl -ne "X")) {
			$FlagCheckRetry = 0
		}
		if ($IsFlagTbl -eq "N") {
			Start-Sleep -Seconds $BlitzWhoDelayIn
		}
		if ($IsFlagTbl -eq "X") {
            
			$FlagCheckRetry += 1
			$FlagErrCheck = $IsFlagTbl
			$IsFlagTbl = "N"
		}
	}
	if ($FailedCount -gt 0) {
		$OutMsg = " ->Successful runs: $SuccessCount"
		#Write-Host " ->Successful runs: $SuccessCount" -NoNewLine
		$OutMsg += "; Failed runs: $FailedCount"
		#Write-Host "; Failed runs: $FailedCount" -NoNewLine
		if ($FlagCheckRetry -gt 0) {
			$OutMsg += "; Retries: $FlagCheckRetry"
			#Write-Host "; Retries: $FlagCheckRetry"
			$OutErr = Format-ExceptionMsg
			$OutMsg += "`n $OutErr"
			Write-Output $OutMsg
		}
		else {
			$OutMsg += ""
			#Write-Host ""
			$OutErr = Format-ExceptionMsg
			$OutMsg += "`n $OutErr"
			Write-Output $OutMsg
			#Write-Host "  $OutErr" -fore Red
		}
		$SqlConnection.Dispose()
	}
	else {
		$OutMsg = " ->Successful runs: $SuccessCount"
		#Write-Host " ->Successful runs: $SuccessCount" -NoNewLine
		if ($FlagCheckRetry -gt 0) {
			$OutMsg += "; Consecutive retries: $FlagCheckRetry"
			#Write-Host "; Consecutive retries: $FlagCheckRetry"
			Write-Output $OutMsg
		}
		else {
			$OutMsg += ""
			#Write-Host ""
			Write-Output $OutMsg
		}
		$SqlConnection.Dispose()
	}
}

###Convert $ServerName from array to string 
[string]$ServerName = $ServerName -join ","

###Return help if requested during execution
if (("Y", "Yes" -Contains $Help) -or ("?", "Help" -Contains $ServerName)) {
	Get-PSBlitzHelp
	Exit
}

###Validate existence of dependencies
#Check resources path
if (!(Test-Path $ResourcesPath )) {
	Write-Host "The Resources directory was not found in $ScriptPath!" -fore red
	Write-Host " Make sure to download the latest release from https://github.com/VladDBA/PSBlitz/releases" -fore yellow
	Write-Host "and properly extract the contents" -fore yellow
	Read-Host -Prompt "Press Enter to close this window."
	Exit
}
#Check individual files
$MissingFiles = @()
foreach ($Rsc in $ResourceList) {
	$FileToTest = Join-Path -Path $ResourcesPath -ChildPath $Rsc
	if (!(Test-Path $FileToTest -PathType Leaf)) {
		$MissingFiles += $Rsc
	}			
}
if ($MissingFiles.Count -gt 0) {
	Write-Host "The following files are missing from"$ResourcesPath":" -fore red
	foreach ($MIAFl in $MissingFiles) {
		Write-Host "  $MIAFl" -fore red
	}
	Write-Host " Make sure to download the latest release from https://github.com/VladDBA/PSBlitz/releases" -fore yellow
	Write-Host "and properly extract the contents" -fore yellow
	Read-Host -Prompt "Press Enter to close this window."
	Exit
}
$IsAzureSQLDB = $false
$IsAzureSQLMI = $false
$IsAzure = $false
###Switch to interactive mode if $ServerName is empty
if ([string]::IsNullOrEmpty($ServerName)) {
	Write-Host "Running in interactive mode"
	$InteractiveMode = 1
	##Instance
	while ([string]::IsNullOrEmpty($ServerName)) {
		$ServerName = Read-Host -Prompt "Server"
	}
	#Make ServerName filename friendly and get host name
	if ($ServerName -like "*`"*") {
		$ServerName = $ServerName -replace "`"", ""
	}
	if ($ServerName -like "*\*") {
		$pos = $ServerName.IndexOf("\")
		$InstName = $ServerName.Substring($pos + 1)
		$HostName = $ServerName.Substring(0, $pos)
	}
	#Azure SQL DB 
	elseif ($ServerName -like "*database.windows.net*") {
		$IsAzure = $true
		#let's strip "tcp: first just in case"
		if ($ServerName -like "tcp:*") {
			$TCPStripped = $true
			$ServerName = $ServerName -replace "tcp:", ""
		}
		#get the database name if it was provided
		if ($ServerName -like "*:*") {
			$pos = $ServerName.IndexOf(":")
			[string]$ASDBName = $ServerName.Substring($pos + 1)
			$ServerName = $ServerName.Substring(0, $pos)
			if (!([string]::IsNullOrEmpty($ASDBName))) {
				$IsAzureSQLDB = $true
			}
		}
		#Get the hostname
		if ($ServerName -like "*,*") {
			$pos = $ServerName.IndexOf(",")
			$HostName = $ServerName.Substring(0, $pos)		
		}
		else {
			$HostName = $ServerName
		}
	
		$InstName = $HostName

		#slap tcp: back on because why not
		if ($TCPStripped) {
			$ServerName = "tcp:$ServerName"
		}
	}
 elseif ($ServerName -like "*,*") {
		$pos = $ServerName.IndexOf(",")
		$HostName = $ServerName.Substring(0, $pos)
		$InstName = $ServerName -replace ",", "-"
		if ($HostName -like "tcp:*") {
			$HostName = $HostName -replace "tcp:", ""
		}
		if ($HostName -like ".") {
			$pos = $HostName.IndexOf(".")
			$HostName = $HostName.Substring(0, $pos)

		}
	}
 else	{
		$InstName = $ServerName
		$HostName = $ServerName
	}
	if ($HostName -like "tcp:*") {
		$HostName = $HostName -replace "tcp:", ""
	}
	if ($HostName -like ".") {
		$pos = $HostName.IndexOf(".")
		$HostName = $HostName.Substring(0, $pos)
	}
	#Return help menu if $ServerName is ? or Help
	if ("?", "Help" -Contains $ServerName) {
		Get-PSBlitzHelp
		Read-Host -Prompt "Press Enter to close this window."
		Exit
	}
	
	##Have sp_BlitzIndex, sp_BlitzCache, sp_BlitzLock executed against a specific database
	if ($IsAzure -eq $false) {
		$CheckDB = Read-Host -Prompt "Name of the database you want to check (leave empty for all)"
	}
	
	##SQL Login
	$SQLLogin = Read-Host -Prompt "SQL login name (leave empty to use integrated security)"
	if (!([string]::IsNullOrEmpty($SQLLogin))) {
		##SQL Login pass
		$SecSQLPass = Read-Host -Prompt "Password" -AsSecureString
	}
	##Indepth check 
	$IsIndepth = Read-Host -Prompt "Perform an in-depth check?(empty defaults to N)[Y/N]"
	##sp_BlitzWho delay
	if (!([int]$BlitzWhoDelay = Read-Host "Seconds of delay between session activity captures (empty defaults to 10)")) { 
		$BlitzWhoDelay = 10 
	}
	##Output file type
	if (!([string]$ToHTML = Read-Host -Prompt "Output the report as HTML instead of Excel?(empty defaults to N)[Y/N]")) {
		$ToHTML = "N"
	}
	##Zip output files
	if (!([string]$ZipOutput = Read-Host -Prompt "Create a zip archive of the output files?(empty defaults to N)[Y/N]")) {
		$ZipOutput = "N"
	}
	##Prompt for advanced options
	if (!([string]$AdvOptions = Read-Host -Prompt "Show advanced options?(empty defaults to N)[Y/N]")) {
		$AdvOptions = "N"
	}
	if ($AdvOptions -eq "Y") {
		##Get top N queries from cache
		[int]$CacheTop = Read-Host -Prompt "Number of top resource intensive queries to return?(empty defaults to 10)"

		##How many minutes back to check for cache
		[int]$CacheMinutesBack = Read-Host -Prompt "How many minutes in the past to check the plan cache?(empty defaults to everything in the plan cache)"

		##custom output dir
		[string]$OutputDir = Read-Host -Prompt "Specify another existing directory path to save the output.(empty defaults to PSBlitz's path)"
	}
}
else {
	$InteractiveMode = 0
	if ($ServerName -like "*\*") {
		$pos = $ServerName.IndexOf("\")
		$InstName = $ServerName.Substring($pos + 1)
		$HostName = $ServerName.Substring(0, $pos)
	}
 #Azure SQL DB 
 elseif ($ServerName -like "*database.windows.net*") {
		$IsAzure = $true
		#let's strip "tcp: first just in case"
		if ($ServerName -like "tcp:*") {
			$TCPStripped = $true
			$ServerName = $ServerName -replace "tcp:", ""
		}
		#get the database name if it was provided
		if ($ServerName -like "*:*") {
			$pos = $ServerName.IndexOf(":")
			[string]$ASDBName = $ServerName.Substring($pos + 1)
			$ServerName = $ServerName.Substring(0, $pos)
			if (!([string]::IsNullOrEmpty($ASDBName))) {
				$IsAzureSQLDB = $true
			}
		}
		#Get the hostname
		if ($ServerName -like "*,*") {
			$pos = $ServerName.IndexOf(",")
			$HostName = $ServerName.Substring(0, $pos)		
		}
		else {
			$HostName = $ServerName
		}
	
		$InstName = $HostName

		#slap tcp: back on because why not
		if ($TCPStripped) {
			$ServerName = "tcp:$ServerName"
		}
	}
	elseif ($ServerName -like "*,*") {
		$pos = $ServerName.IndexOf(",")
		$HostName = $ServerName.Substring(0, $pos)
		$InstName = $ServerName -replace ",", "-"
	}
	else	{
		$InstName = $ServerName
		$HostName = $ServerName
	}
}

if (($InteractiveMode -eq 0) -and (!([string]::IsNullOrEmpty($SQLLogin))) -and ([string]::IsNullOrEmpty($SQLPass))) {
	Write-Host " You've provided a SQL login, but no password." -Fore Yellow
	$SecSQLPass = Read-Host -Prompt "Password" -AsSecureString
	#Convert the secure password to plain text for SqlConnection
	$BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecSQLPass)
	$SQLPass = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
}

#Convert the secure password to plain text for SqlConnection
if (($InteractiveMode -eq 1) -and (!([string]::IsNullOrEmpty($SQLLogin))) ) {
	$BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecSQLPass)
	$SQLPass = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
}

###If release is older than 2 months print an info message
if ($NowDate -ge $TwoMonthsFromRelease) {
	Write-Host "Informational: This release of PSBlitz is two months old" -Fore Yellow
	Write-Host "->You can check for a newer release at https://github.com/VladDBA/PSBlitz/releases"
}

### If Azure and database name was not provided, do a preliminary test for the type of env
#Turning this into a fallback check in case the server name doesn't match the standard Azure SQL format
if (($IsAzure -eq $false) -and ([string]::IsNullOrEmpty($ASDBName)) -and ($IsAzureSQLDB -eq $false)) {
	$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
	$AppName = "PSBlitz " + $Vers
	if (!([string]::IsNullOrEmpty($SQLLogin))) {
		$ConnString = "Server=$ServerName;Database=master;User Id=$SQLLogin;Password=$SQLPass;Connection Timeout=$ConnTimeout;Application Name=$AppName"
	}
	else {

		$ConnString = "Server=$ServerName;Database=master;trusted_connection=true;Connection Timeout=$ConnTimeout;Application Name=$AppName"
	}
	$SqlConnection.ConnectionString = $ConnString

	[int]$CmdTimeout = 100
	Write-Host "Detecting environment type... " -NoNewLine
	$AzCheckQuery = new-object System.Data.SqlClient.SqlCommand
	$Query = "SELECT CAST(SERVERPROPERTY('EngineEdition') AS INT) AS [EngineEdition],"
	$Query += "`nCAST(SERVERPROPERTY('Edition') AS NVARCHAR(128)) AS [Edition];"
	$AzCheckQuery.CommandText = $Query
	$AzCheckQuery.Connection = $SqlConnection
	$AzCheckQuery.CommandTimeout = $CmdTimeout
	$AzCheckAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
	$AzCheckAdapter.SelectCommand = $AzCheckQuery
	$AzCheckSet = new-object System.Data.DataSet
	Try {
		$StepStart = get-date
		$AzCheckAdapter.Fill($AzCheckSet) | Out-Null -ErrorAction Stop
		$SqlConnection.Close()
		$StepEnd = get-date
	}
	Catch {
		$StepEnd = get-date
		Invoke-ErrMsg
		$Help = Read-Host -Prompt "Need help?[Y/N]"
		if ($Help -eq "Y") {
			Get-PSBlitzHelp
			#Don't close the window automatically if in interactive mode
			if ($InteractiveMode -eq 1) {
				Read-Host -Prompt "Press Enter to close this window."
				Exit
			}
		}
		else {
			Exit
		}
	}
	if ($AzCheckSet.Tables[0].Rows.Count -eq 1) {
		$AzCheckTbl = New-Object System.Data.DataTable
		$AzCheckTbl = $AzCheckSet.Tables[0]
		[int]$EngineEdition = $AzCheckTbl.Rows[0]["EngineEdition"]
		[string]$Edition = $AzCheckTbl.Rows[0]["Edition"]
		Write-Host @GreenCheck
		$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
		if ($DebugInfo) {
			Write-Host " Engine Edition - $EngineEdition"  -Fore Yellow
		}
		if ($Edition -eq "SQL Azure") {
			if ($EngineEdition -eq 8) {
				$IsAzureSQLMI = $true
				Write-Host "->Azure SQL MI"
			}
			elseif ($EngineEdition -eq 5) {
				$IsAzureSQLDB = $true
				Write-Host "->Azure SQL DB"
			} 
		}
		elseif ($EngineEdition -in 2, 3, 4) {
			Write-Host "->SQL Server $Edition"
		}
		else {
			Write-Host "->Well this is awquard, use the following info to debug:"
			Write-Host " Edition - $Edition; EngineEdition - $EngineEdition"
		}
	}

}

#If Azure SQL DB make sure database name is provided regardless of mode
if (($IsAzureSQLDB) -and ([string]::IsNullOrEmpty($ASDBName))) {
	if (!([string]::IsNullOrEmpty($CheckDB))) {
		$ASDBName = $CheckDB
		$CheckDB = ""
	}
	else {
		Write-Host " The environment has been identified as Azure SQL DB, but a database name was not provide." -Fore yellow
		while ([string]::IsNullOrEmpty($ASDBName)) {
			$ASDBName = Read-Host -Prompt "Name of the Azure SQL DB database (cannot be empty)"
		}
	}
}
elseif (($IsAzureSQLMI) -and ($InteractiveMode -eq 1) -and ([string]::IsNullOrEmpty($CheckDB))) {
	$CheckDB = Read-Host -Prompt "Name of the database you want to check (leave empty for all)"
}

#Set the string to replace for $CheckDB
if (!([string]::IsNullOrEmpty($CheckDB))) {
	$OldCheckDBStr = ";SET @DatabaseName = NULL;"
	$NewCheckDBStr = ";SET @DatabaseName = '" + $CheckDB + "';" 
}

###Define connection
$AppName = "PSBlitz " + $Vers
$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
if (!([string]::IsNullOrEmpty($SQLLogin))) {
	if ($IsAzureSQLDB) {
		$ConnString = "Server=$ServerName;Database=$ASDBName;User Id=$SQLLogin;Password=$SQLPass;Connection Timeout=$ConnTimeout;Application Name=$AppName"
	}
 else {
		$ConnString = "Server=$ServerName;Database=master;User Id=$SQLLogin;Password=$SQLPass;Connection Timeout=$ConnTimeout;Application Name=$AppName"
	}
	$Auth = "SQL"
}
else {
	if ($IsAzureSQLDB) {
		$ConnString = "Server=$ServerName;Database=$ASDBName;trusted_connection=true;Connection Timeout=$ConnTimeout;Application Name=$AppName"
	}
 else {
		$ConnString = "Server=$ServerName;Database=master;trusted_connection=true;Connection Timeout=$ConnTimeout;Application Name=$AppName"
	}
	$Auth = "Trusted"
}
$SqlConnection.ConnectionString = $ConnString

###Test connection to instance
[int]$CmdTimeout = 100
Write-Host "Testing connection to $ServerName... " -NoNewLine
$ConnCheckQuery = new-object System.Data.SqlClient.SqlCommand
$Query = "SELECT CAST(SERVERPROPERTY('Edition') AS NVARCHAR(128)) AS [Edition],"
$Query += "`nCAST(ISNULL(SERVERPROPERTY('ProductMajorVersion'),0) AS TINYINT) AS [MajorVersion];"
$ConnCheckQuery.CommandText = $Query
$ConnCheckQuery.Connection = $SqlConnection
$ConnCheckQuery.CommandTimeout = $CmdTimeout
$ConnCheckAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
$ConnCheckAdapter.SelectCommand = $ConnCheckQuery
$ConnCheckSet = new-object System.Data.DataSet
Try {
	$StepStart = get-date
	$ConnCheckAdapter.Fill($ConnCheckSet) | Out-Null -ErrorAction Stop
	$SqlConnection.Close()
	$StepEnd = get-date
}
Catch {
	$StepEnd = get-date
	Invoke-ErrMsg
	$Help = Read-Host -Prompt "Need help?[Y/N]"
	if ($Help -eq "Y") {
		Get-PSBlitzHelp
		#Don't close the window automatically if in interactive mode
		if ($InteractiveMode -eq 1) {
			Read-Host -Prompt "Press Enter to close this window."
			Exit
		}
	}
 else {
		Exit
	}
}
if ($ConnCheckSet.Tables[0].Rows.Count -eq 1) {
	$ConnChec = New-Object System.Data.DataTable
	$ConnChec = $ConnCheckSet.Tables[0]
	[int]$MajorVers = $ConnChec.Rows[0]["MajorVersion"]
	Write-Host @GreenCheck
	$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
	$ConnTest = [Math]::Round($StepRunTime, 3)
	if ($DebugInfo) {
		Write-Host " - $ConnTest seconds"
		Write-Host " Product Major Version - $MajorVers"  -Fore Yellow
	}
 else {
		if ($ConnTest -ge 2) {
			Write-Host "->Estimated response latency: $ConnTest seconds" -Fore Red
		}
		elseif ($ConnTest -ge 0.5) {
			Write-Host "->Estimated response latency: $ConnTest seconds" -Fore Yellow
		}
		elseif ($ConnTest -ge 0.2) {
			Write-Host "->Estimated response latency: $ConnTest seconds"
		}
		elseif ($ConnTest -lt 0.2) {
			Write-Host "->Estimated response latency: $ConnTest seconds" -Fore Green
		}

	}
}
###Test existence of value provided for $CheckDB
if (!([string]::IsNullOrEmpty($CheckDB))) {
	Write-Host "Checking existence of database $CheckDB..."
	$CheckDBQuery = new-object System.Data.SqlClient.SqlCommand
	$DBQuery = "SELECT [name] from sys.databases WHERE [name] = @DBName AND [state] = 0 AND [user_access_desc] = 'MULTI_USER';"
	$CheckDBQuery.CommandText = $DBQuery
	$CheckDBQuery.Parameters.Add("@DBName", [Data.SQLDBType]::NVarChar, 256) | Out-Null
	$CheckDBQuery.Parameters["@DBName"].Value = $CheckDB
	$CheckDBQuery.Connection = $SqlConnection
	$CheckDBQuery.CommandTimeout = 100
	$CheckDBAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
	$CheckDBAdapter.SelectCommand = $CheckDBQuery
	$CheckDBSet = new-object System.Data.DataSet
	$CheckDBAdapter.Fill($CheckDBSet) | Out-Null
	$SqlConnection.Close()
	Try {
		if ($CheckDBSet.Tables[0].Rows[0]["name"] -eq $CheckDB) {
			Write-Host "->Database $CheckDB - " -NoNewLine -ErrorAction Stop
			Write-Host "is online" -fore green -ErrorAction Stop
		}
	}
 Catch {
		Write-Host "->Database $CheckDB either does not exist or is offline" -fore red
		$InstanceWide = Read-Host -Prompt "Switch to instance-wide plan cache, index, and deadlock check?[Y/N]"
		if ($InstanceWide -eq "Y") {
			$CheckDB = ""
		}
		else {
			$Help = Read-Host -Prompt "Need help?[Y/N]"
			if ($Help -eq "Y") {
				Get-PSBlitzHelp
				#Don't close the window automatically if in interactive mode
				if ($InteractiveMode -eq 1) {
					Read-Host -Prompt "Press Enter to close this window."
					Exit
				}
			}
			else {
				Exit
			}
		}
	}
	Invoke-ClearVariables CheckDBSet, CheckDBAdapter, CheckDBQuery

}
elseif ($IsAzureSQLDB -eq $false) {
	#if we're not in Azure SQL DB mode and no database was provided, get a user database count
	Write-Host "Checking user database count..." -NoNewline
	$CheckDBQuery = new-object System.Data.SqlClient.SqlCommand
	$DBQuery = "SELECT COUNT([name]) AS [DBCount] from sys.databases WHERE [state] = 0 AND [user_access_desc] = 'MULTI_USER'"
	$DBQuery += " AND [name] NOT IN ('master', 'tempdb', 'model', 'msdb');"
	$CheckDBQuery.CommandText = $DBQuery
	$CheckDBQuery.Connection = $SqlConnection
	$CheckDBQuery.CommandTimeout = 100
	$CheckDBAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
	$CheckDBAdapter.SelectCommand = $CheckDBQuery
	$CheckDBSet = new-object System.Data.DataSet
	$CheckDBAdapter.Fill($CheckDBSet) | Out-Null
	$SqlConnection.Close()
	[int]$UsrDBCount = $CheckDBSet.Tables[0].Rows[0]["DBCount"]
	if ($UsrDBCount -ge $MaxUsrDBs) {
		Write-Host " !" -Fore Yellow
		Write-Host "->Instance has $UsrDBCount user databases" -Fore Yellow
		Write-Host "->The following checks will be limited to the database that shows up the most in plan cache info:"
		if ($IsIndepth -eq "Y") {
			Write-Host "   - Index Summary"
			Write-Host "   - Index Usage Details"
			Write-Host "   - Detailed Index Diagnosis"
		}
		else {
			Write-Host "   - Index Diagnosis"
		}			
	}
 else {
		Write-Host @GreenCheck
	}	
}

###Create directories
#Turn current date time into string for output directory name
$sdate = get-date
$DirDate = $sdate.ToString("yyyyMMddHHmm")
#Set output directory
if ((!([string]::IsNullOrEmpty($OutputDir))) -and (Test-Path $OutputDir)) {

	$OutDir = $OutputDir
}
else {
	$OutDir = $scriptPath
	$OutputDir = $scriptPath
}
if ($IsAzureSQLDB) {
	$SubDir = "AzureSQLDB_$ASDBName" + "_"
}
elseif ($IsAzureSQLMI) {
	$SubDir = $InstName.Replace('.database.windows.net', '') + "_"
}
elseif ($HostName -ne $InstName) {
	$SubDir = $HostName + "_" + $InstName + "_"
}
else {
	$SubDir = $InstName + "_"
}
if (!([string]::IsNullOrEmpty($CheckDB))) {
	$SubDir = $CheckDB + "_"
}
$SubDir += $DirDate

$OutDir = Join-Path -Path $OutDir -ChildPath $SubDir

if ($ZipOutput -eq "Y") {

	$ZipFile = $SubDir + ".zip"
}
if ($DebugInfo) {
	Write-Host "`n Output directory: `n$OutDir" -Fore Yellow
}


#Check if output directory exists
if (!(Test-Path $OutDir)) {
	New-Item -ItemType Directory -Force -Path $OutDir | Out-Null
}
#Set plan output directory
$PlanOutDir = Join-Path -Path $OutDir -ChildPath "Plans"
#Check if plan output directory exists
if (!(Test-Path $PlanOutDir)) {
	New-Item -ItemType Directory -Force -Path $PlanOutDir | Out-Null
}
#Set deadlock graph output directory
$XDLOutDir = Join-Path -Path $OutDir -ChildPath "Deadlocks"
#Check if deadlock graph output directory exists
if (!(Test-Path $XDLOutDir)) {
	New-Item -ItemType Directory -Force -Path $XDLOutDir | Out-Null
}

#Initiate Excel app here
if ($ToHTML -ne "Y") {
	###Open Excel
	if ($DebugInfo) {
		$ErrorActionPreference = "Continue"
		Write-Host "Opening excel file" -fore yellow
	}
	else {
		#Do not display the occasional "out of memory" errors
		$ErrorActionPreference = "SilentlyContinue"
	}

	try {
		$ExcelApp = New-Object -comobject Excel.Application	-ErrorAction Stop
		Write-Host "PSBlitz is writing the report to Excel." -Fore Green
		Write-Host " Warning: Do not open or close Excel during this execution of PSBlitz." -Fore Yellow	
	}
	catch {
		Write-Host "Could not open Excel." -fore Red
		Write-Host "->Switching to HTML output."
		$ToHTML = "Y"
		$ErrorActionPreference = "Continue"
	}
	
}

if (($ToHTML -ne "Y") -and ($CacheTop -ne 10)) {
	Write-Host " Output type is Excel, but -CacheTop was specified with a value <> 10." -Fore Red
	Write-Host " ->These two options aren't compatible."
	Write-Host " ->Switching -CacheTop back to 10"
	$CacheTop = 10
}

if ($ToHTML -eq "Y") {
	#Set HTML files output directory
	$HTMLOutDir = Join-Path -Path $OutDir -ChildPath "HTMLFiles"
	if (!(Test-Path $HTMLOutDir)) {
		New-Item -ItemType Directory -Force -Path $HTMLOutDir | Out-Null
	}
	#HTML elements and styles used in most report pages
	$HTMLPre = @"
	<!DOCTYPE html>
	<html>
	<head>
	<link rel="stylesheet" href="styles.css">
	<style>
	.CacheTable1{
	  td {
		  vertical-align: top;
		  padding-top: 8px;
		}
		td:nth-child(3) {
			position: sticky; left: 0;
			background-color: rgba(255, 255, 255, 0.7);
		}
		td:nth-child(CacheTab1High) {
			font-weight: bold;
			background-color: rgba(255, 255, 0, 0.4);
		}
		td:nth-child(2){
		    text-align: right;
	    }
		td:nth-child(n+10):nth-child(-n+51){
    		text-align: right;
	    }
		td:nth-child(n+53):nth-child(-n+56){
    		text-align: right;
	    }
	}
	.CacheTable2{
	    td {
		  vertical-align: top;
		  padding-top: 8px;
		}	
		td:nth-child(3) {
			position: sticky; left: 0;
			background-color: rgba(255, 255, 255, 0.7);
		}
		td:nth-child(CacheTab2High) {
			font-weight: bold;
			background-color: rgba(255, 255, 0, 0.4);
		}
		td:nth-child(2){
		    text-align: right;
	    }
		td:nth-child(n+10):nth-child(-n+51){
    		text-align: right;
	    }
		td:nth-child(n+53):nth-child(-n+56){
    		text-align: right;
	    }
	}
	</style>
	<script src="sorttable.js"></script>
	<script src="searchtable.js"></script>
	<script src="copy.js"></script>
	
"@
	$URLRegex = '(?i)\b((?:https?://|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:\".,<>?«»“”]))'
	$SortableTable = '<p>Click on the column headers to sort the results.</p>'
	$JumpToTop = '<p><a href="#top">Jump to top</a></p>'

	$SearchTableDiv = @"
	    <div>
		<input type=`"text`" id=`"SearchBox`" class=`"SearchBox`" onkeyup=`"SearchTable('ReplaceTableID', ReplaceColIdx)`" placeholder=`" Filter by object name...`">
		</div>
"@
	$STDivReplace = "'ReplaceTableID', ReplaceColIdx"
	$Footer = @"
	<br>
	<footer>  
	<p>Report generated with <a href='https://github.com/VladDBA/PSBlitz' target='_blank'>PSBlitz</a> - created by <a href='https://vladdba.com/?ref=PSBlitz' target='_blank'>Vlad Drumea</a></p>
	</footer>
	<br>
"@
	$HTMLBodyStart = @"
			</head>
			<body>
"@
	$HTMLBodyEnd = @"
        <br>
	  </body>
	 </html>
"@
	$htmlResources = @("styles.css", "sorttable.js", "searchtable.js", "copy.js")
}
else {
	###Set output Excel name and destination
	if (!([string]::IsNullOrEmpty($CheckDB))) {
		$OutExcelFName = "Active_$InstName_$CheckDB.xlsx"
	}
	else {
		$OutExcelFName = "Active_$InstName.xlsx"
	}
	$OutExcelF = Join-Path -Path $OutDir -ChildPath $OutExcelFName
	###Copy Excel template to output directory
	<#
	This is a fix for https://github.com/VladDBA/PSBlitz/issues/4
	#>
	Copy-Item $OrigExcelF  -Destination $OutExcelF
}
#Set output table for sp_BlitzWho
#Set replace strings
$OldBlitzWhoOut = "@OutputTableName = 'BlitzWho_..PSBlitzReplace..',"
$NewBlitzWhoOut = "@OutputTableName = 'BlitzWho_$DirDate',"

if ($ToHTML -ne "Y") {
	###Open Excel FIle
	if ($DebugInfo) {
		$ExcelApp.visible = $True
	}
	else {
		$ExcelApp.visible = $False
	}
	$ExcelFile = $ExcelApp.Workbooks.Open("$OutExcelF")
	$ExcelApp.DisplayAlerts = $False
}
###Create log table
$LogTbl = New-Object System.Data.DataTable
$LogTbl.Columns.Add("Step", [string]) | Out-Null
$LogTbl.Columns.Add("StartDate", [string]) | Out-Null
$LogTbl.Columns.Add("EndDate", [string]) | Out-Null
#$LogTbl.Columns.Add("Duration", [string]) | Out-Null
$LogTbl.Columns.Add("Duration (Seconds)", [string]) | Out-Null
$LogTbl.Columns.Add("Outcome", [string]) | Out-Null
#$LogTbl.Columns.Add("ErrorMsg", [string]) | Out-Null
$LogTbl.Columns.Add("Message", [string]) | Out-Null

###Check instance uptime
Write-Host "Checking instance uptime..." -NoNewline
#$UptimeQuery = new-object System.Data.SqlClient.SqlCommand
$Query = "SELECT CAST(DATEDIFF(HH, [sqlserver_start_time], GETDATE()) / 24.00 AS NUMERIC(23, 2)) AS [uptime_days]	"
$Query = $Query + "`nFROM [sys].[dm_os_sys_info];"
Invoke-PSBlitzQuery -QueryIn $Query -StepNameIn "Uptime check" -ConnStringIn $ConnString -CmdTimeoutIn 100
if ($global:StepOutcome -eq "Success") {
	if ($global:PSBlitzSet.Tables[0].Rows[0]["uptime_days"] -lt 7.00) {
		[string]$DaysUp = $global:PSBlitzSet.Tables[0].Rows[0]["uptime_days"]
		Write-Host "Warning: Instance uptime is less than 7 days - $DaysUp" -Fore Red
		Write-Host "->Diagnostics data might not be reliable with less than 7 days of uptime." -Fore Red
	}
	Invoke-ClearVariables PSBlitzSet
}

#####################################################################################
#						Check start													#
#####################################################################################
$StepStart = get-date
$StepEnd = Get-Date
$ParametersUsed = "IsIndepth:$IsIndepth; CheckDB:$CheckDB;`n BlitzWhoDelay:$BlitzWhoDelay; MaxTimeout:$MaxTimeout"
$ParametersUsed += ";`n ConnTimeout:$ConnTimeout; CacheTop:$CacheTop;`n ASDBName:$ASDBName; CacheMinutesBack:$CacheMinutesBack"
$ParametersUsed += ";`n Auth:$Auth; DebugInfo:$DebugInfo"
Add-LogRow "Check start" "Started" $ParametersUsed
try {
	###Set completion flag
	$TryCompleted = "N"

	Write-Host $("-" * 80)
	Write-Host "       Starting" -NoNewLine 
	if ($IsIndepth -eq "Y") {
		Write-Host " in-depth" -NoNewLine
	}
	if (!([string]::IsNullOrEmpty($CheckDB))) {
		Write-Host " database-specific" -NoNewLine
	}
	Write-Host " check for " -NoNewLine 
	if ($IsAzureSQLDB) {
		Write-Host "Azure SQL DB - $ASDBName"
	}
	elseif ($IsAzureSQLMI) {
		Write-Host "Azure SQL MI - $($ServerName.Replace('.database.windows.net',''))" 
	}
	else {
		Write-Host "$ServerName"
	}
	Write-Host $("-" * 80)

	if (($DebugInfo) -and ($MaxTimeout -ne 1000)) {
		Write-Host " ->MaxTimeout has been set to $MaxTimeout"
	}

	###Load sp_BlitzWho in memory
	$SqlScriptFilePath = Join-Path -Path $ResourcesPath -ChildPath "spBlitzWho_NonSPLatest.sql"
	[string]$Query = [System.IO.File]::ReadAllText("$SqlScriptFilePath")
	#Replace output table name
	[string]$BlitzWhoRepl = $Query -replace $OldBlitzWhoOut, $NewBlitzWhoOut

	###Execution start time
	$StartDate = get-date
	###Collecting first pass of sp_BlitzWho data
	$JobName = "BlitzWho"
	Write-Host " Starting session activity collection process... " -NoNewline
	
	$Job = Start-Job -Name $JobName -InitializationScript $InitScriptBlock -ScriptBlock $MainScriptblock -ArgumentList $ConnString, $BlitzWhoRepl, $DirDate, $BlitzWhoDelay
	$JobStatus = $Job | Select-Object -ExpandProperty State
	if ($JobStatus -ne "Running") {
		Write-Host @RedX
		if ($DebugInfo) {
			Write-Host ""
		}
		$JobError = $Job | Select-Object -ExpandProperty Error
		Add-LogRow "Start sp_BlitzWho background process" $JobStatus $JobError
		Write-Host " ->Switching to foreground execution."
		Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop N
		$BlitzWhoPass += 1
	}
 else {
		Write-Host @GreenCheck
		if ($DebugInfo) {
			Write-Host ""
		}
		Add-LogRow "Start sp_BlitzWho background process" $JobStatus
		Write-Host " ->Active session data will be captured every $BlitzWhoDelay seconds."
	}


	#####################################################################################
	#						Instance Info												#
	#####################################################################################
	$StepOutcome = "Failure"
	Write-Host " Retrieving instance information... " -NoNewLine
	$SqlScriptFilePath = Join-Path -Path $ResourcesPath -ChildPath "GetInstanceInfo.sql"
	[string]$Query = [System.IO.File]::ReadAllText("$SqlScriptFilePath")
	Invoke-PSBlitzQuery -QueryIn $Query -StepNameIn "Instance Info" -ConnStringIn $ConnString -CmdTimeoutIn $DefaultTimeout
		
	if ($global:StepOutcome -eq "Success") {
		$InstanceInfoTbl = $global:PSBlitzSet.Tables[0]
		$ResourceInfoTbl = $global:PSBlitzSet.Tables[1]
		$ConnectionsInfoTbl = $global:PSBlitzSet.Tables[2]
		$SessOptTbl = $global:PSBlitzSet.Tables[3]
		$PlanCacheTypeTbl = $global:PSBlitzSet.Tables[4]
		$PlanCacheByDBTbl = $global:PSBlitzSet.Tables[5]
		
		if ($ToHTML -eq "Y") {

			$InstanceInfoTbl.Rows[0]["estimated_response_latency(Sec)"] = $ConnTest

			$htmlTable1 = Convert-TableToHtml $InstanceInfoTbl -CSSClass InstanceInfoTbl -DebugInfo:$DebugInfo

			if ($IsAzureSQLDB) {
				$htmlTable2 = '<p>Instance resource information is not available for Azure SQL DB.</p>'
			}
			else {

				$htmlTable2 = Convert-TableToHtml $ResourceInfoTbl -CSSClass RsrcInfoTbl -DebugInfo:$DebugInfo
			}

			$htmlTable3 = Convert-TableToHtml $ConnectionsInfoTbl -CSSClass Top10ClientConnTbl -DebugInfo:$DebugInfo
			$htmlTable4 = Convert-TableToHtml $SessOptTbl -CSSClass 'SessOptTbl sortable' -ExclCols "Option","URL" -HyperlinkCol "OptionHL" -DebugInfo:$DebugInfo

			$htmlTable5 = Convert-TableToHtml $PlanCacheTypeTbl -CSSClass InstCacheTbl -DebugInfo:$DebugInfo
			$htmlTable6 = Convert-TableToHtml $PlanCacheByDBTbl -CSSClass InstCacheTbl -DebugInfo:$DebugInfo

			$HtmlTabName = "Instance Overview"
			$html = $HTMLPre + @"
    <title>$HtmlTabName</title>
    $HTMLBodyStart
<h1>$HtmlTabName</h1>
<h2>Instance information</h2>
$htmlTable1
<br>
<h2>Resource information</h2>
$htmlTable2
<br>
<h2>Top 10 clients by connections</h2>
$htmlTable3
<br>
<h2>Plan cache usage by type</h2>
$htmlTable5
<br>
<h2>Top 10 databases by plan cache usage</h2>
$htmlTable6
<br>
<h2>Session level SET options</h2>
$htmlTable4
$HTMLBodyEnd
"@
			#Save HTML file
			Save-HtmlFile $html "InstanceInfo.html" $HTMLOutDir $DebugInfo
			Invoke-ClearVariables html, htmlTable1, htmlTable2, htmlTable3, htmlTable4
		}
		else {
			###Populating the "Instance Info" sheet
			$ExcelSheet = $ExcelFile.Worksheets.Item("Instance Info")
			##Instance Info section
			#Specify at which row in the sheet to start adding the data
			$ExcelStartRow = 3
			Convert-TableToExcel $InstanceInfoTbl $ExcelSheet -StartRow $ExcelStartRow -DebugInfo:$DebugInfo

			##Resource Info section
			#Specify at which row in the sheet to start adding the data
			$ExcelStartRow = 8
			Convert-TableToExcel $ResourceInfoTbl $ExcelSheet -StartRow $ExcelStartRow -DebugInfo:$DebugInfo

			##Top 10 clients by connections section
			#Specify at which row in the sheet to start adding the data
			$ExcelStartRow = 14
			Convert-TableToExcel $ConnectionsInfoTbl $ExcelSheet -StartRow $ExcelStartRow -DebugInfo:$DebugInfo

			#Session level options
			$ExcelStartRow = 14
			$ExcelColNum = 12
			Convert-TableToExcel $SessOptTbl $ExcelSheet -StartRow $ExcelStartRow -DebugInfo:$DebugInfo -ExclCols "OptionHL" -StartCol $ExcelColNum -URLCols "URL" -MapURLToColNum 12 -URLTextCol "Option"

			##Saving file 
			Save-ExcelFile $ExcelFile
		}
		##Cleaning up variables
		Invoke-ClearVariables ResourceInfoTbl, InstanceInfoTbl, ConnectionsInfoTbl, SessOptTbl, PSBlitzSet
	}

	if ($JobStatus -ne "Running") {
		Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop N
		$BlitzWhoPass += 1
	}

	#####################################################################################
	#						TempDB usage info	 										#
	#####################################################################################
	Write-Host " Retrieving TempDB usage data... " -NoNewLine
	$SqlScriptFilePath = Join-Path -Path $ResourcesPath -ChildPath "GetTempDBUsageInfo.sql"
	[string]$Query = [System.IO.File]::ReadAllText("$SqlScriptFilePath")
	[string]$Query = $Query -replace '..PSBlitzReplace..', "$DirDate"
	Invoke-PSBlitzQuery -QueryIn $Query -StepNameIn "TempDB Info" -ConnStringIn $ConnString -CmdTimeoutIn $DefaultTimeout
		
	if ($global:StepOutcome -eq "Success") {
		$TempDBTbl = New-Object System.Data.DataTable
		$TempDBTbl = $global:PSBlitzSet.Tables[0]
		
		$TempTabTbl = New-Object System.Data.DataTable
		$TempTabTbl = $global:PSBlitzSet.Tables[1]

		$TempDBSessTbl = New-Object System.Data.DataTable
		$TempDBSessTbl = $global:PSBlitzSet.Tables[2]

		if ($ToHTML -eq "Y") {

			$htmlTable1 = Convert-TableToHtml $TempDBTbl -CSSClass "TempdbInfoTbl" -DebugInfo:$DebugInfo

			$htmlTable2 = Convert-TableToHtml $TempTabTbl -CSSClass "InstCacheTbl" -DebugInfo:$DebugInfo

			Add-QueryName $TempDBSessTbl "query" "query_text" "TempDB"

			$htmlTable3 = Convert-TableToHtml $TempDBSessTbl -ExclCols "query_text" -DebugInfo:$DebugInfo -AnchorFromHere -AnchorIDs "TempDB"
			
			$htmlTable4 = Convert-QueryTableToHtml $TempDBSessTbl -DebugInfo:$DebugInfo -Cols "query", "query_text" -CSSClass "QueryTbl" -AnchorToHere -AnchorID "TempDB"

			$HtmlTabName = "TempDB Info"

			$html = $HTMLPre + @"
<title>$HtmlTabName</title>
$HTMLBodyStart
<h1>$HtmlTabName</h1>
<h2>TempDB space usage</h2>
$htmlTable1
<br>
<h2>Top 30 temp tables by reserved space</h2>
"@
			if ($TempTabTbl.Rows.Count -gt 0) {
				$html += @"
$htmlTable2
<br>
"@
			}
			else {
				$html += @"
				<p>No temp tables found.</p>
				<br>
"@
			}
			$html += @"
			<h2>Top 30 sessions using TempDB by total allocation</h2>
"@
			if ($TempDBSessTbl.Rows.Count -gt 0 ) {
				$html += @"
				$htmlTable3
				<br>
				<h3>Query text</h3>
				$htmlTable4

"@
			}
			else {
				$html += @"
				<p>No sessions were using tempdb at this time.</p>
				<br>
"@
			}
			$html += @"
			$HTMLBodyEnd
"@
			#Save HTML file
			Save-HtmlFile $html "TempDBInfo.html" $HTMLOutDir $DebugInfo
			Invoke-ClearVariables html, htmlTable1, htmlTable2, htmlTable3, htmlTable4

		}
		else {

			###Populating the "TempDB" sheet
			$ExcelSheet = $ExcelFile.Worksheets.Item("TempDB")
			##TempDB space usage section
			#Specify at which row in the sheet to start adding the data
			$ExcelStartRow = 3
			Convert-TableToExcel $TempDBTbl $ExcelSheet -StartRow $ExcelStartRow -DebugInfo:$DebugInfo

			##Temp tables section
			#Specify at which row in the sheet to start adding the data
			$ExcelStartRow = 8
			Convert-TableToExcel $TempTabTbl $ExcelSheet -StartRow $ExcelStartRow -DebugInfo:$DebugInfo

			##TempDB session usage section
			#Specify at which row in the sheet to start adding the data
			$ExcelStartRow = 8
			#Specify with which column in the sheet to start
			$ExcelColNum = 6
			Convert-TableToExcel $TempDBSessTbl $ExcelSheet -StartRow $ExcelStartRow -DebugInfo:$DebugInfo -StartCol $ExcelColNum -ExclCols "query"
			##Saving file 
			Save-ExcelFile $ExcelFile
		}
		##Cleaning up variables
		Invoke-ClearVariables TempDBTbl, TempTabTbl, TempDBSessTbl, PSBlitzSet
	}

	if ($JobStatus -ne "Running") {
		Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop N
		$BlitzWhoPass += 1
	}

	#####################################################################################
	#						Open transaction info - Pass 1								#
	#####################################################################################
	Write-Host " Retrieving open transaction info" -NoNewline
	$SqlScriptFilePath = Join-Path -Path $ResourcesPath -ChildPath "GetOpenTransactions.sql"
	[string]$Query = [System.IO.File]::ReadAllText("$SqlScriptFilePath")
	[string]$Query = $Query -replace "SET @CheckPass = '';", "SET @CheckPass = 'Pass1';"
	if ($IsAzureSQLDB) {
		Write-Host " for $ASDBName" -NoNewline
	}
	Write-Host "... " -NoNewline
	Invoke-PSBlitzQuery -QueryIn $Query -StepNameIn "Open Transacion Info" -ConnStringIn $ConnString -CmdTimeoutIn $DefaultTimeout
	
	if ($global:StepOutcome -eq "Success") {
		$AcTranTbl = New-Object System.Data.DataTable
		$AcTranTbl = $global:PSBlitzSet.Tables[0]
		[int]$RowsReturned = $AcTranTbl.Rows.Count
		if ($RowsReturned -le 0) {
			Write-Host " ->No open transactions found."
		}
		else {

			Export-PlansAndDeadlocks $AcTranTbl $PlanOutDir "current_plan" "current_plan_file" -DebugInfo:$DebugInfo -FileNameFromColumn
			Export-PlansAndDeadlocks $AcTranTbl $PlanOutDir "most_recent_plan" "most_recent_plan_file" -DebugInfo:$DebugInfo -FileNameFromColumn
			if ($ToHTML -eq "Y") {

				$tableName = "Open transaction info"
				if (!([string]::IsNullOrEmpty($CheckDB))) {
					$tableName += " for $CheckDB" 
				}
				elseif ($IsAzureSQLDB) {
					$tableName += " for $ASDBName"
				}
				
				$htmlTable1 = Convert-TableToHtml $AcTranTbl -ExclCols "current_sql", "current_plan", "most_recent_sql", "most_recent_plan" -DebugInfo:$DebugInfo -AnchorFromHere -AnchorIDs "Current", "MostRecent"

				$htmlTable2 = Convert-QueryTableToHtml $AcTranTbl -Cols "current_query", "current_sql" -CSSClass "QueryTbl" -AnchorToHere -AnchorID "Current" -DebugInfo:$DebugInfo
	
				$htmlTable3 = Convert-QueryTableToHtml $AcTranTbl -Cols "most_recent_query", "most_recent_sql" -CSSClass "QueryTbl" -AnchorToHere -AnchorID "MostRecent" -DebugInfo:$DebugInfo

				$html = $HTMLPre + @"
<title>$tableName</title>
$HTMLBodyStart
<h1 id="top">$tableName</h1>
$htmlTable1
<br>
<h2>Current Query text</h2>
$htmlTable2
<br>
<h2>Most Recent Query Text</h2>
$htmlTable3
$JumpToTop
$HTMLBodyEnd
"@
				#Save HTML file
				Save-HtmlFile $html "OpenTransactions.html" $HTMLOutDir $DebugInfo
				Invoke-ClearVariables html, htmlTable1, htmlTable2, htmlTable3
			}
			else {
				##Populating the "Open Transactions" sheet
				$ExcelSheet = $ExcelFile.Worksheets.Item("Open Transactions")
				Convert-TableToExcel $AcTranTbl $ExcelSheet -DebugInfo:$DebugInfo -StartRow $DefaultStartRow -ExclCols "current_query", "most_recent_query", "current_plan", "most_recent_plan"
				##Saving file 
				Save-ExcelFile $ExcelFile
			}
		}
		##Cleaning up variables 
		Invoke-ClearVariables AcTranTbl, PSBlitzSet
	}

	if ($JobStatus -ne "Running") {
		Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop N
		$BlitzWhoPass += 1
	}

	#####################################################################################
	#						Database info												#
	#####################################################################################
	if ($IsAzureSQLDB) {

		$SqlScriptFilePath = Join-Path -Path $ResourcesPath -ChildPath "GetAzureSQLDBInfo.sql"
		[string]$Query = [System.IO.File]::ReadAllText("$SqlScriptFilePath")
		Write-Host " Retrieving database info for $ASDBName... " -NoNewLine 
		Invoke-PSBlitzQuery -QueryIn $Query -StepNameIn "Azure SQL DB Info" -ConnStringIn $ConnString -CmdTimeoutIn $DefaultTimeout
		
		if ($global:StepOutcome -eq "Success") {
			$RsrcGovTbl = $global:PSBlitzSet.Tables[0]
			$DBInfoTbl = $global:PSBlitzSet.Tables[1]
			$RsrcUsageTbl = $global:PSBlitzSet.Tables[2]
			$Top10WaitsTbl = $global:PSBlitzSet.Tables[3]
			$DBFileInfoTbl = $global:PSBlitzSet.Tables[4]
			$ObjImpUpgrTbl = $global:PSBlitzSet.Tables[5]
			$DBConfigTbl = $global:PSBlitzSet.Tables[6]

			if ($ToHTML -eq "Y") {
				$tableName = "Azure SQL Database Info"

				$htmlTable = Convert-TableToHtml $RsrcGovTbl -DebugInfo:$DebugInfo -NoCaseChange

				$htmlTable1 = Convert-TableToHtml $DBInfoTbl -TblID "DBInfoTable" -CSSClass "sortable" -DebugInfo:$DebugInfo -NoCaseChange

				$htmlTable2 = Convert-TableToHtml $RsrcUsageTbl -CSSClass "sortable" -DebugInfo:$DebugInfo -NoCaseChange

				$htmlTable3 = Convert-TableToHtml $Top10WaitsTbl -CSSClass "sortable" -DebugInfo:$DebugInfo -NoCaseChange -HyperlinkCol "Wait TypeHL" -ExclCols "Wait Type", "URL"

				$htmlTable4 = Convert-TableToHtml $DBFileInfoTbl -TblID "DBFileInfoTable" -CSSClass "sortable" -DebugInfo:$DebugInfo -NoCaseChange

				if ($ObjImpUpgrTbl.Rows.Count -gt 0) {
					$htmlTable5 = Convert-TableToHtml $ObjImpUpgrTbl -CSSClass "sortable" -DebugInfo:$DebugInfo -NoCaseChange
				}
				else {
					$htmlTable5 = '<p>No matching objects found.</p>'
				}			

				$htmlTable6 = Convert-TableToHtml $DBConfigTbl -CSSClass "sortable" -DebugInfo:$DebugInfo -NoCaseChange

				$html = $HTMLPre + @"
<title>$tableName</title>
$HTMLBodyStart
<h1 id="top">$tableName</h1>
<h2>Azure SQL DB Resource Governance</h1>
$htmlTable
$JumpToTop
<br>
<h2>Database Overview</h2>
$htmlTable1
$JumpToTop
<br>
<h2>Resource Usage</h2>
$htmlTable2
$JumpToTop
<br>
<h2>Top 10 Waits Since Last Startup</h2>
$htmlTable3
$JumpToTop
<br>
<h2>Database Files Info</h2>
$htmlTable4
$JumpToTop
<br>
<h2>Objects Impacted by a Major Release Upgrade of Azure SQL DB</h2>
$htmlTable5
$JumpToTop
<br>
<h2>Database Scoped Configuration</h2>
<br>
$SortableTable
$htmlTable6
$JumpToTop
$HTMLBodyEnd
"@

				#Save HTML file
				Save-HtmlFile $html "AzureSQLDBInfo.html" $HTMLOutDir $DebugInfo
				Invoke-ClearVariables html, htmlTable, htmlTable1, htmlTable2, htmlTable3, htmlTable4, htmlTable5, htmlTable6
			}
			else {
				#Populate the Azure SQL DB Resource Governance section
				$ExcelSheet = $ExcelFile.Worksheets.Item("Azure SQL DB Info")
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = 3
				
				Convert-TableToExcel $RsrcGovTbl $ExcelSheet -StartRow $ExcelStartRow -DebugInfo:$DebugInfo

				##Saving file 
				Save-ExcelFile $ExcelFile

				##Populating the "Database Overview" section
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = 8
				
				Convert-TableToExcel $DBInfoTbl $ExcelSheet -StartRow $ExcelStartRow -DebugInfo:$DebugInfo

				##Saving file 
				Save-ExcelFile $ExcelFile

				##Populating the "Resource Usage" section
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = 13
				Convert-TableToExcel $RsrcUsageTbl $ExcelSheet -StartRow $ExcelStartRow -DebugInfo:$DebugInfo

				##Saving file 
				Save-ExcelFile $ExcelFile

				##Populating the "Top 10 Waits" section
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = 22
				
				Convert-TableToExcel $Top10WaitsTbl $ExcelSheet -StartRow $ExcelStartRow -DebugInfo:$DebugInfo -HasURLs -URLCols "URL" -MapURLToColNum 4 -URLTextCol "Wait Type" -ExclCols "Wait TypeHL"

				##Saving file 
				Save-ExcelFile $ExcelFile

				##Populating the "Database Files Info" section
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = 36
				
				Convert-TableToExcel $DBFileInfoTbl $ExcelSheet -StartRow $ExcelStartRow -DebugInfo:$DebugInfo

				##Saving file 
				Save-ExcelFile $ExcelFile

				##Populating the "Objects Impacted by a Major Release Upgrade of Azure SQL DB" section
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = 36
				#Specify with which column in the sheet to start
				$ExcelColNum = 20
				
				Convert-TableToExcel $ObjImpUpgrTbl $ExcelSheet -StartRow $ExcelStartRow -StartCol $ExcelColNum -DebugInfo:$DebugInfo

				##Saving file 
				Save-ExcelFile $ExcelFile

				##Populating the "Database Scoped Configuration" section
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = 36
				#Specify with which column in the sheet to start
				$ExcelColNum = 25
				Convert-TableToExcel $DBConfigTbl $ExcelSheet -StartRow $ExcelStartRow -StartCol $ExcelColNum -DebugInfo:$DebugInfo

				##Saving file 
				Save-ExcelFile $ExcelFile
			}
			Invoke-ClearVariables DBInfoTbl, DBFileInfoTbl, RsrcGovTbl, RsrcUsageTbl, ObjImpUpgrTbl, DBConfigTbl, PSBlitzSet
		}
	}
 else {
		#if it's not Azure SQL DB
		$SqlScriptFilePath = Join-Path -Path $ResourcesPath -ChildPath "GetDbInfo.sql"
		[string]$Query = [System.IO.File]::ReadAllText("$SqlScriptFilePath")
			
		if (!([string]::IsNullOrEmpty($CheckDB))) {
			Write-Host " Retrieving database info for $CheckDB... " -NoNewLine
			[string]$Query = $Query -replace "SET @DatabaseName = N'';", "SET @DatabaseName = N'$CheckDB';"
		}
		else {
			Write-Host " Retrieving database info... " -NoNewLine
		}
		Invoke-PSBlitzQuery -QueryIn $Query -StepNameIn "Database Info" -ConnStringIn $ConnString -CmdTimeoutIn $DefaultTimeout
		
		if ($global:StepOutcome -eq "Success") {
			$DBInfoTbl = $global:PSBlitzSet.Tables[0]
			$DBFileInfoTbl = $global:PSBlitzSet.Tables[1]
			if (($MajorVers -ge 13) -and (!([string]::IsNullOrEmpty($CheckDB)))) {
				#the 3rd result set exists only for SQL Server 2016 and above
				#$DBConfigTbl = New-Object System.Data.DataTable
				$DBConfigTbl = $global:PSBlitzSet.Tables[2]
			}
			elseif (($MajorVers -lt 13) -and (!([string]::IsNullOrEmpty($CheckDB))) -and ($IsAzureSQLMI -eq $false)) {
				Add-LogRow "->Database Scoped Config" "Skipped" "Major Version is $MajorVers"
			}

			if ($ToHTML -eq "Y") {
				$tableName = "Database Info"

				$htmlTable = Convert-TableToHtml $DBInfoTbl -DebugInfo:$DebugInfo
				
				$htmlTable1 = Convert-TableToHtml $DBFileInfoTbl -TblID "DBFileInfoTable" -CSSClass "sortable" -DebugInfo:$DebugInfo
				if (!([string]::IsNullOrEmpty($CheckDB))) {
					$htmlTable = $htmlTable -replace '<table>', '<table id="DBInfoTable" class="DatabaseInfoTable">'
				}
				else {
					$htmlTable = $htmlTable -replace '<table>', '<table id="DBInfoTable" class="DatabaseInfoTable sortable">'
				}

				if ((($MajorVers -ge 13) -or ($IsAzureSQLMI)) -and (!([string]::IsNullOrEmpty($CheckDB)))) {

					$htmlTable2 = Convert-TableToHtml $DBConfigTbl -NoCaseChange -CSSClass "sortable" -DebugInfo:$DebugInfo
					$htmlBlock = "`n<br>`n <h2>Database Scoped Configuration for $CheckDB</h2>"
					$htmlBlock += '<p><a href="https://learn.microsoft.com/en-us/sql/t-sql/statements/alter-database-scoped-configuration-transact-sql?view=sql-server-ver16" target="_blank">More Info</a></p>'
					$htmlBlock += "`n $SortableTable `n $htmlTable2 `n"
					$htmlBlock += '<p><a href="#top">Jump to top</a></p>'
					$htmlBlock += '<br>'
				}
				else {
					$htmlBlock = '<br>'
				}

				$html = $HTMLPre + @"
<title>$tableName</title>
$HTMLBodyStart
<h1 id="top">$tableName</h1>
$(if($DBInfoTbl.Rows.Count -gt 10){$SearchTableDiv -replace $STDivReplace,"'DBInfoTable', 0" -replace 'object', 'database'})
$(if ([string]::IsNullOrEmpty($CheckDB)){$SortableTable})
$htmlTable
$JumpToTop
<br>
<h2>Database Files Info</h2>
$($SearchTableDiv -replace $STDivReplace,"'DBFileInfoTable', 0" -replace 'object', 'database' -replace 'id="SearchBox"', 'id="SearchBox1"')
$SortableTable
$htmlTable1
$JumpToTop
$htmlBlock
$HTMLBodyEnd
"@

				#Save HTML file
				Save-HtmlFile $html "DatabaseInfo.html" $HTMLOutDir $DebugInfo
				Invoke-ClearVariables html, htmlTable, htmlTable1, htmlBlock
			}
			else {
				##Populating the "Database Info" sheet with the database files data first because 
				#it's narrower and leaves room to fit some of the database info
				$ExcelSheet = $ExcelFile.Worksheets.Item("Database Info")
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = 3
				
				Convert-TableToExcel $DBFileInfoTbl $ExcelSheet -StartRow $ExcelStartRow -DebugInfo:$DebugInfo

				##Populating the "Database Info" sheet with the database data
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = 3
				#Specify with which column in the sheet to start
				$ExcelColNum = 20
				
				Convert-TableToExcel $DBInfoTbl $ExcelSheet -StartRow $ExcelStartRow -StartCol $ExcelColNum -DebugInfo:$DebugInfo

				if ((($MajorVers -ge 13) -or ($IsAzureSQLMI)) -and (!([string]::IsNullOrEmpty($CheckDB)))) {
					##Populating the DB Scoped Config sheet
					$ExcelSheet = $ExcelFile.Worksheets.Item("DB Scoped Config")
					#Specify at which row in the sheet to start adding the data
					$ExcelStartRow = 2
					#Specify with which column in the sheet to start
					$ExcelColNum = 2
				
					Convert-TableToExcel $DBConfigTbl $ExcelSheet -StartRow $ExcelStartRow -StartCol $ExcelColNum -DebugInfo:$DebugInfo
				}
				##Saving file 
				Save-ExcelFile $ExcelFile
			}
			Invoke-ClearVariables DBInfoTbl, DBFileInfoTbl, PSBlitzSet
		}
	}

	if ($JobStatus -ne "Running") {
		Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop N
		$BlitzWhoPass += 1
	}
	#####################################################################################
	#						sp_Blitz 													#
	#####################################################################################
	if ($IsAzureSQLDB) {
		$StepStart = get-date
		$StepEnd = get-date
		Write-Host " Azure SQL DB - skipping instance health."
		Add-LogRow "sp_Blitz" "Skipped" "Azure SQL DB"
	}
	else {
		Write-Host " Retrieving instance health data... " -NoNewLine
		$SqlScriptFilePath = Join-Path -Path $ResourcesPath -ChildPath "spBlitz_NonSPLatest.sql"
		[string]$Query = [System.IO.File]::ReadAllText("$SqlScriptFilePath")
		if (($IsIndepth -eq "Y") -and ([string]::IsNullOrEmpty($CheckDB))) {
			[string]$Query = $Query -replace ";SET @CheckUserDatabaseObjects = 0;", ";SET @CheckUserDatabaseObjects = 1;"
			$GetUsrDBObj = $true
		}
		Invoke-PSBlitzQuery -QueryIn $Query -StepNameIn "sp_Blitz" -ConnStringIn $ConnString -CmdTimeoutIn $DefaultTimeout
		if ($global:StepOutcome -eq "Success") {
			#$BlitzTbl = New-Object System.Data.DataTable
			$BlitzTbl = $global:PSBlitzSet.Tables[0]

			if ($ToHTML -eq "Y") {
				$tableName = "Instance Health"
				$htmlTable = Convert-TableToHtml $BlitzTbl -NoCaseChange -TblID "InstanceHealthTable" -HyperlinkCol "FindingHL" -ExclCols Finding, URL -DebugInfo:$DebugInfo
				$html = $HTMLPre + @"
<title>$tableName</title>
$HTMLBodyStart
<h1 id="top">$tableName</h1>
$($SearchTableDiv -replace $STDivReplace, "'InstanceHealthTable', 3" -replace 'object' , 'database')
<br>
$htmlTable
$JumpToTop
$HTMLBodyEnd
"@

				#Save HTML file
				Save-HtmlFile $html "spBlitz.html" $HTMLOutDir $DebugInfo
				Invoke-ClearVariables html, htmlTable
			}
			else {
				##Populating the "sp_Blitz" sheet
				$ExcelSheet = $ExcelFile.Worksheets.Item("Instance Health")
					
				Convert-TableToExcel $BlitzTbl $ExcelSheet -StartRow $DefaultStartRow -DebugInfo:$DebugInfo -URLCols "URL" -MapURLToColNum 3 -URLTextCol "Finding" -ExclCols "FindingHL"

				##Saving file 
				Save-ExcelFile $ExcelFile
			}

			if ($GetUsrDBObj) {
				#get databses with dangerous object set options
				$DangerousObjDBs = $BlitzTbl | Where-Object { $_."Finding" -eq "Objects created with dangerous SET Options" } | Select-Object "DatabaseName"
				$DangerousObjDBsCount = $DangerousObjDBs.Rows.Count
				Write-Host " Found $DangerousObjDBsCount databases with dangerous object SET options."
			}
			##Cleaning up variables
			Invoke-ClearVariables BlitzTbl, PSBlitzSet		
		}
	}

	if ($JobStatus -ne "Running") {
		Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop N
		$BlitzWhoPass += 1
	}

	#####################################################################################
	#						Objects with dangerous SET options							#
	#####################################################################################
	if ((!([string]::IsNullOrEmpty($CheckDB))) -or ($IsAzureSQLDB) -or (($GetUsrDBObj) -and ($DangerousObjDBsCount -gt 0))) {
		Write-Host " Retrieving objects created with dangerous SET options... " -NoNewLine
		$SqlScriptFilePath = Join-Path -Path $ResourcesPath -ChildPath "GetObjectsWithDangerousOptions.sql"
		[string]$Query = [System.IO.File]::ReadAllText("$SqlScriptFilePath")
		if ($IsAzureSQLDB) {
			[string]$Query = $Query -replace 'SET @IsAzureSQLDB = 0;', 'SET @IsAzureSQLDB = 1;'
		}
		elseif (!([string]::IsNullOrEmpty($CheckDB))) {
			$Query = $Query -replace '..PSBlitzReplace..', "$CheckDB"
		}
		elseif ($GetUsrDBObj) {
			$InsertString = ''
			foreach ($DB in $DangerousObjDBs) {
				$InsertString += "(N'$($DB.DatabaseName)'),"
			}
			$InsertString = $InsertString.TrimEnd(',')
			$Query = $Query -replace "\(N'..PSBlitzReplace..'\)", "$InsertString"
		}
		Invoke-PSBlitzQuery -QueryIn $Query -StepNameIn "Objects with dangerous SET options" -ConnStringIn $ConnString -CmdTimeoutIn $DefaultTimeout
		if ($global:StepOutcome -eq "Success") {
			$DangerousSetTbl = $global:PSBlitzSet.Tables[0]
			[int]$RowsReturned = $DangerousSetTbl.Rows.Count
			if ($RowsReturned -le 0) {
				Write-Host " ->No rows returned."
			}
			else {
				if ($ToHTML -eq "Y") {
					$HtmlTabName = "Database objects with dangerous SET options"
					$htmlTable = Convert-TableToHtml $DangerousSetTbl -CSSClass "sortable" -DebugInfo:$DebugInfo
					$html = $HTMLPre + @"
	<title>$HtmlTabName</title>
$HTMLBodyStart
<h1 id="top">$HtmlTabName</h1>
<p><a href='https://vladdba.com/2025/03/03/dangerous-set-options-stored-procedures/' target='_blank'>More information about SET options inheritance in stored procedures</a></p>
$SortableTable
$htmlTable
$JumpToTop
$HTMLBodyEnd
"@
					Save-HtmlFile $html "DangerousSETOpt.html" $HTMLOutDir $DebugInfo
					Invoke-ClearVariables html, htmlTable
				}
				else {
					$ExcelSheet = $ExcelFile.Worksheets.Item("Objects Dangerous SET")
					
					Convert-TableToExcel $DangerousSetTbl $ExcelSheet -StartRow 4 -DebugInfo:$DebugInfo -URLCols "URL" -MapURLToColNum 3 -URLTextCol "Finding"
					##Saving file 
					Save-ExcelFile $ExcelFile
				}
			}
			##Cleaning up variables
			Invoke-ClearVariables DangerousSetTbl, PSBlitzSet
		 	
		}
	}
	if ($JobStatus -ne "Running") {
		Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop N
		$BlitzWhoPass += 1
	}

	#####################################################################################
	#						sp_BlitzFirst 30 seconds									#
	#####################################################################################
	Write-Host " What's happening in a 30 seconds time-frame... " -NoNewLine
	$SqlScriptFilePath = Join-Path -Path $ResourcesPath -ChildPath "spBlitzFirst_NonSPLatest.sql"
	[string]$Query = [System.IO.File]::ReadAllText("$SqlScriptFilePath")
	Invoke-PSBlitzQuery -QueryIn $Query -StepNameIn "sp_BlitzFirst 30 seconds" -ConnStringIn $ConnString -CmdTimeoutIn $DefaultTimeout
	if ($global:StepOutcome -eq "Success") {
		$BlitzFirstTbl = $global:PSBlitzSet.Tables[0]

		if ($ToHTML -eq "Y") {			
			$htmlTable = Convert-TableToHtml $BlitzFirstTbl -NoCaseChange -CSSClass "First30Tbl" -ExclCols "Finding","URL" -HyperlinkCol "FindingHL" -DebugInfo:$DebugInfo
			$HtmlTabName = "What's happening on the instance now?"
			$html = $HTMLPre + @"
<title>$HtmlTabName</title>
$HTMLBodyStart
<h1>$HtmlTabName</h1>
<h2>30 seconds time-frame</h2>
$htmlTable
$HTMLBodyEnd
"@

			#Save HTML file
			Save-HtmlFile $html "BlitzFirst30s.html" $HTMLOutDir $DebugInfo
			Invoke-ClearVariables html, htmlTable
		}
		else {
			##Populating the "sp_BlitzFirst 30s" sheet
			$ExcelSheet = $ExcelFile.Worksheets.Item("Happening Now")
			Convert-TableToExcel $BlitzFirstTbl $ExcelSheet -StartRow $DefaultStartRow -ExclCols "FindingHL" -DebugInfo:$DebugInfo -URLCols "URL" -MapURLToColNum 3 -URLTextCol "Finding"
			##Saving file 
			Save-ExcelFile $ExcelFile
		}
		Invoke-ClearVariables BlitzFirstTbl, PSBlitzSet
	}
	if ($JobStatus -ne "Running") {
		Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop N
		$BlitzWhoPass += 1
	}

	#####################################################################################
	#						sp_BlitzFirst since startup									#
	#####################################################################################
	if ($IsIndepth -eq "Y") {
		Write-Host " Retrieving waits recorded since instance startup... " -NoNewLine
		$SqlScriptFilePath = Join-Path -Path $ResourcesPath -ChildPath "spBlitzFirst_NonSPLatest.sql"
		[string]$Query = [System.IO.File]::ReadAllText("$SqlScriptFilePath")
		[string]$Query = $Query -replace ";SET @SinceStartup = 0;", ";SET @SinceStartup = 1;"
		Invoke-PSBlitzQuery -QueryIn $Query -StepNameIn "sp_BlitzFirst since startup" -ConnStringIn $ConnString -CmdTimeoutIn $DefaultTimeout
		if ($global:StepOutcome -eq "Success") {
			$WaitsTbl = $global:PSBlitzSet.Tables[0]
			$StorageTbl = $global:PSBlitzSet.Tables[1]
			$PerfmonTbl = $global:PSBlitzSet.Tables[2]

			if ($ToHTML -eq "Y") {
				#Waits
				$HtmlTabName = "Wait Stats Since Last Startup"

				$htmlTable = Convert-TableToHtml $WaitsTbl -NoCaseChange -HyperlinkCol "wait_typeHL" -ExclCols "wait_type","URL" -CSSClass "WaitStats" -DebugInfo:$DebugInfo
			 
				$html = $HTMLPre + @"
<title>$HtmlTabName</title>
$HTMLBodyStart
<h1>$HtmlTabName</h1>
$htmlTable
$JumpToTop
$HTMLBodyEnd
"@
				#Save HTML file
				Save-HtmlFile $html "BlitzFirst_Waits.html" $HTMLOutDir $DebugInfo
				Invoke-ClearVariables html, htmlTable
			 
				#Storage
				$HtmlTabName = "Storage Throughput Since Instance Startup"
				$htmlTable = Convert-TableToHtml $StorageTbl -NoCaseChange -TblID "StorageStatsTable" -CSSClass "Storage sortable" -ExclCols "StallRank" -DebugInfo:$DebugInfo
			 
				$html = $HTMLPre + @"
<title>$HtmlTabName</title>
$HTMLBodyStart
<h1>$HtmlTabName</h1>
$($SearchTableDiv -replace $STDivReplace, "'StorageStatsTable', 9" -replace 'object', 'database')
$SortableTable
$htmlTable
$JumpToTop
$HTMLBodyEnd
"@
				#Save HTML file
				Save-HtmlFile $html "BlitzFirst_Storage.html" $HTMLOutDir $DebugInfo
				Invoke-ClearVariables html, htmlTable
			 
				#Perfmon
				$HtmlTabName = "Perfmon Stats Since Instance Startup"
				$htmlTable = Convert-TableToHtml $PerfmonTbl -NoCaseChange -TblID "PerfmonTable" -CSSClass "Perfmon sortable" -DebugInfo:$DebugInfo
			 
				$html = $HTMLPre + @"
<title>$HtmlTabName</title>
$HTMLBodyStart
<h1>$HtmlTabName</h1>
$($SearchTableDiv -replace $STDivReplace, "'PerfmonTable', 1" -replace 'object', 'counter')
$SortableTable
$htmlTable
$JumpToTop
$HTMLBodyEnd
"@

				#Save HTML file
				Save-HtmlFile $html "BlitzFirst_Perfmon.html" $HTMLOutDir $DebugInfo
				Invoke-ClearVariables html, htmlTable
			}
			else { 
				##Populating the "Wait Stats" sheet
				$ExcelSheet = $ExcelFile.Worksheets.Item("Wait Stats")					
				Convert-TableToExcel $WaitsTbl $ExcelSheet -StartRow $DefaultStartRow -DebugInfo:$DebugInfo -URLCols "URL" -MapURLToColNum 4 -URLTextCol "wait_type" -ExclCols "wait_typeHL"

				##Saving file 
				Save-ExcelFile $ExcelFile

				## populating the "Storage" sheet
				$ExcelSheet = $ExcelFile.Worksheets.Item("Storage Stats")					
				Convert-TableToExcel $StorageTbl $ExcelSheet -StartRow $DefaultStartRow -DebugInfo:$DebugInfo -ExclCols "StallRank"

				##Saving file 
				Save-ExcelFile $ExcelFile

				## populating the "Perfmon" sheet
				$ExcelSheet = $ExcelFile.Worksheets.Item("Perfmon Stats")
				Convert-TableToExcel $PerfmonTbl $ExcelSheet -StartRow $DefaultStartRow -DebugInfo:$DebugInfo
		
				##Saving file 
				Save-ExcelFile $ExcelFile
			}

			##Cleaning up variables
			Invoke-ClearVariables WaitsTbl, StorageTbl, PerfmonTbl, PSBlitzSet
		}
		if ($JobStatus -ne "Running") {
			Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop N
			$BlitzWhoPass += 1
		}
	}		

	#####################################################################################
	#						sp_BlitzCache												#
	#####################################################################################
	#Building a list of values for @SortOrder 
	<#
	Ony run through the other sort orders if $IsIndepth = "Y"
	otherwise just do duration and avg duration
	#>
	if ($IsIndepth -eq "Y") {
		$SortOrders = @("'CPU'", "'Average CPU'", "'Reads'", "'Average Reads'",
			"'Duration'", "'Average Duration'", "'Executions'", "'Executions per Minute'",
			"'Writes'", "'Average Writes'", "'Spills'", "'Average Spills'",
			"'Duplicate'", "'Query Hash'",
			"'Memory Grant'", "'Recent Compilations'")
	}
	else {
		$SortOrders = @("'CPU'", "'Average CPU'", "'Duration'",
			"'Average Duration'")
	}
	#Set initial SortOrder value
	$OldSortOrder = "'CPU'"
	$SqlScriptFilePath = Join-Path -Path $ResourcesPath -ChildPath "spBlitzCache_NonSPLatest.sql"
	[string]$Query = [System.IO.File]::ReadAllText("$SqlScriptFilePath")
	#Set specific database to check if a name was provided
	if (!([string]::IsNullOrEmpty($CheckDB))) {
		[string]$Query = $Query -replace $OldCheckDBStr, $NewCheckDBStr
		Write-Host " Retrieving plan cache info for $CheckDB" -NoNewline
	}
	elseif ($IsAzureSQLDB) {
		Write-Host " Retrieving plan cache info for $ASDBName" -NoNewline
	}
	else {
		Write-Host " Retrieving plan cache info for all user databases" -NoNewline
		#Create array to store database names
		$DBArray = New-Object System.Collections.ArrayList
		[int]$BlitzCacheRecs = 0
	}
	$OrigCacheMinutesBack = $CacheMinutesBack
	if ($CacheMinutesBack -gt 0) {
		
		$OrigCacheMinutesBack = $CacheMinutesBack
		$OldCacheMinutesBackStr = ";SET @MinutesBack = NULL;"
		$NewCacheMinutesBackStr = ";SET @MinutesBack = " + $CacheMinutesBack + ";"
		[string]$Query = $Query -replace $OldCacheMinutesBackStr, $NewCacheMinutesBackStr
		Write-Host " for the past $CacheMinutesBack minutes + current execution time"
	}
	else { 
		Write-Host "" 
	}
	#Loop through sort orders
	foreach ($SortOrder in $SortOrders) {
		#Filename sort order portion
		$FileSOrder = $SortOrder.Replace('Average', 'Avg')
		$FileSOrder = $SortOrder.Replace('Executions per Minute', 'ExPM')
		$FileSOrder = $SortOrder.Replace(' ', '_')
		$FileSOrder = $FileSOrder.Replace("'", '')

		#Replace old sort order with new one
		$OldSortString = ";SELECT @SortOrder = " + $OldSortOrder
		$NewSortString = ";SELECT @SortOrder = " + $SortOrder
		#Replace number of records returned if sorting by recent compilations
		if ($SortOrder -eq "'recent compilations'") {
			$OldSortString = $OldSortString + ", @Top = $CacheTop;"
			$NewSortString = $NewSortString + ", @Top = 50;"
		}
		elseif (($CacheTop -ne 10) -and ($SortOrder -eq "'CPU'")) {
			#Since we're only reading the script once and then using it from memory, 
			#we only have to change @Top once if it's not the default
			$OldSortString = $OldSortString + ", @Top = 10;"
			$NewSortString = $NewSortString + ", @Top = $CacheTop;"
		}
		#Adjust the value of -CacheMinutesBack/@MinutesBack to the current runtime
		if ($OrigCacheMinutesBack -gt 0) {
			$CurrTime = get-date
			$CurrRunTime = (New-TimeSpan -Start $StartDate -End $CurrTime).TotalMinutes
			$CurrMin = [Math]::Round($CurrRunTime)
			
			$CacheMinutesBack = $CurrMin + $OrigCacheMinutesBack
			if ($DebugInfo) {
				Write-Host " ->Adjusting the value of -CacheMinutesBack to the current runtime of $CurrMin minutes" -fore yellow
				Write-Host "  ->The past $CacheMinutesBack minutes ($CurrMin + $OrigCacheMinutesBack) will now be analyzed" -fore yellow
			}			
			$NewCacheMinutesBackStr = ";SET @MinutesBack = " + $CacheMinutesBack + ";"
			[string]$Query = $Query -replace $OldCacheMinutesBackStr, $NewCacheMinutesBackStr
		}

		[string]$Query = $Query -replace $OldSortString, $NewSortString
		Write-Host " ->Top $(if($SortOrder -eq "'recent compilations'"){"50"}else{$CacheTop}) queries by $($SortOrder -replace "'",'')... " -NoNewLine
		if ($OrigCacheMinutesBack -ne 0) {
			$AdditionalInfo = ", MinutesBack=$CacheMinutesBack"
		}
		else {
			$AdditionalInfo = ""
		}
		$PreviousOutcome = $global:StepOutcome
		Invoke-PSBlitzQuery -QueryIn $Query -StepNameIn "sp_BlitzCache $SortOrder  $AdditionalInfo" -ConnStringIn $ConnString -CmdTimeoutIn $MaxTimeout
	
		if ($global:StepOutcome -eq "Success") {
			$BlitzCacheTbl = $global:PSBlitzSet.Tables[0]
			$BlitzCacheWarnTbl = $global:PSBlitzSet.Tables[1]

			Export-PlansAndDeadlocks $BlitzCacheTbl $PlanOutDir "Query Plan" "SQLPlan File" -FPrefix $FileSOrder -DebugInfo:$DebugInfo

			##Add database names to array
			if (([string]::IsNullOrEmpty($CheckDB)) -and ($IsAzureSQLDB -eq $false)) {
				foreach ($row in $BlitzCacheTbl."Database") {
					if ($row -ne [System.DBNull]::Value) {
						$DBArray.Add($row) | Out-Null
						$BlitzCacheRecs += 1
					}
				}
			}
			<#Set Excel sheet names based on $SortOrder
			Since we're already checking for sort order, I'll also add the column number for CSS#>
			$SheetName = "Top Queries - "
			if ($SortOrder -like '*CPU*') {
				$SheetName = $SheetName + "CPU"
				$HighlightCol = 16
			}
			elseif ($SortOrder -like '*Reads*') {
				$SheetName = $SheetName + "Reads"
				$HighlightCol = 24
			}
			elseif ($SortOrder -like '*Duration*') {
				$SheetName = $SheetName + "Duration"
				$HighlightCol = 20
			}
			elseif ($SortOrder -like '*Executions*') {
				$SheetName = $SheetName + "Executions"
				$HighlightCol = 10
			}
			elseif ($SortOrder -like '*Writes*') {
				$SheetName = $SheetName + "Writes"
				$HighlightCol = 28
			}
			elseif ($SortOrder -like '*Spills*') {
				$SheetName = $SheetName + "Spills"
				$HighlightCol = 43
			}
			elseif ("'Duplicate'", "'Query Hash'" -contains $SortOrder) {
				$SheetName = $SheetName + "Dupl & Single Use"
				$HighlightCol = 0
			}
			elseif ($SortOrder -like '*Memory*') {
				$SheetName = $SheetName + "Mem & Recent Comp"
				$HighlightCol = 40
			}
			elseif ($SortOrder -eq "'Recent compilations'") {
				$SheetName = $SheetName + "Mem & Recent Comp"
				$HighlightCol = 47
			}

			if ($ToHTML -eq "Y") {
				$SheetName = $SheetName -replace "Top Queries - ", ""

				Add-QueryName $BlitzCacheTbl "Query" "Query Text" $FileSOrder				
					
				$htmlTable1 = Convert-TableToHtml $BlitzCacheTbl -NoCaseChange -ExclCols "Query Text", "Query Plan" -CSSClass "CacheTabx" -DebugInfo:$DebugInfo -AnchorFromHere -AnchorIDs $FileSOrder
				
				$htmlTable2 = Convert-TableToHtml $BlitzCacheWarnTbl -NoCaseChange -HyperlinkCol "FindingHL" -ExclCols "Finding","URL" -DebugInfo:$DebugInfo

				$htmlTable3 = Convert-QueryTableToHtml $BlitzCacheTbl -DebugInfo:$DebugInfo -Cols "Query", "Query Text" -CSSClass "QueryTbl" -AnchorToHere -AnchorID $FileSOrder
		
				#pairing up related tables in the same HTML file
				if ("'CPU'", "'Reads'", "'Duration'", "'Executions'", "'Writes'",
					"'Spills'", "'Duplicate'", "'Memory Grant'" -contains $SortOrder) {
					#Handling CSS
					$CacheHTMLPre = $HTMLPre
					$CacheHTMLPre = $CacheHTMLPre -replace 'CacheTab1High', $HighlightCol
					$htmlTable1 = $htmlTable1 -replace "<table class='CacheTabx'>", '<table class="CacheTable1">'
					
					if ($SheetName -eq "Mem & Recent Comp") {
						$HtmlTabName = "Queries by Memory Grants & Recent Compilations"
					}
					elseif ($SheetName -eq "Dupl & Single Use") {
						$HtmlTabName = "Queries by Duplicate Plans & Query Hash"
					}
					else {
						$HtmlTabName = "Queries by $SheetName"
					}
					if (!([string]::IsNullOrEmpty($CheckDB))) {
						$HtmlTabName += " for $CheckDB" 
					}
					elseif ($IsAzureSQLDB) {
						$HtmlTabName += " for $ASDBName"
					}
					
					$HtmlFileName = $SheetName -replace " & ", "_"
					$HtmlFileName = $HtmlFileName -replace " ", "_"
					$HtmlFileName = "BlitzCache_$HtmlFileName.html"
					$HtmlTabName2 = $SortOrder -replace "'", ""
					
					$html = @"
					<title>$HtmlTabName</title>
					$HTMLBodyStart
					<h1 id="top">$HtmlTabName</h1>
					<br>
					<h2>Top $CacheTop Queries by $HtmlTabName2</h2>
					<p><a href="#Queries1">Jump to query text</a></p>
					$htmlTable1
					<br>
					<h2>Warnings Explained</h2>
					$htmlTable2
					$JumpToTop
					<br>

"@

					$html2 = @"
					<h2 id="Queries1">Query text for $HtmlTabName2</h2>
					$htmlTable3
					$JumpToTop
					<br>

"@
					$FirstHalf = "Done"
					$SecondHalf = "NotDone"

				}
		
				#adding the second half of each html page and writing to file
				if (($SortOrder -like '*Average*') -or ($SortOrder -eq "'Executions per Minute'") -or ($SortOrder -eq "'Recent Compilations'") -or ($SortOrder -eq "'Query Hash'")) {
					$HtmlTabName2 = $SortOrder -replace "'", ""
					#Handling CSS
					$htmlTable1 = $htmlTable1 -replace "<table class='CacheTabx'>", '<table class="CacheTable2">'
					
					#Add heading if first half of the table failed
					if ($PreviousOutcome -eq "Failure") {
						$CacheHTMLPre = $HTMLPre
						#$html = $CacheHTMLPre
						$html2 = @"
						<br>
"@
					} 					
					if ($SortOrder -eq "'Recent Compilations'") {
						$TopCount = "50"						
					}
					else {
						$TopCount = "$CacheTop"
						$HighlightCol += 1
					}
					$CacheHTMLPre = $CacheHTMLPre -replace 'CacheTab2High', $HighlightCol
					$html += @"
				<h2>Top $TopCount Queries by $HtmlTabName2</h2>
				<p><a href="#Queries2">Jump to query text</a></p>
				$htmlTable1
				<br>
				<h2>Warnings Explained</h2>
				$htmlTable2
				$JumpToTop

"@

					$html2 += @"
					<h2 id="Queries2">Query text for $HtmlTabName2</h2>					
					$htmlTable3
					$JumpToTop
"@
					#putting it all together
					$html3 = $CacheHTMLPre + $html + $html2 + @"
					$HTMLBodyEnd
"@
					$SecondHalf = "Done"					
					#Save the HTML file containing both pairs
					Save-HtmlFile $html3 $HtmlFileName $HTMLOutDir $DebugInfo "Complete "
				
				}

				#Only writing the file here if this is the first half
				if (($FirstHalf -eq "Done") -and ($SecondHalf -eq "NotDone")) {
					$html3 = $CacheHTMLPre + $html + $html2 + @"
					$HTMLBodyEnd
"@
					#Save the partial HTML file
					Save-HtmlFile $html3 $HtmlFileName $HTMLOutDir $DebugInfo "Partial "
				}
				

			}
			else {
				#Specify worksheet
				$ExcelSheet = $ExcelFile.Worksheets.Item($SheetName)

				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = 3
				#$SortOrder containing avg or xpm will export data starting with row 16
				if (($SortOrder -like '*Average*') -or ($SortOrder -eq "'Executions per Minute'") -or ($SortOrder -eq "'Recent Compilations'") -or ($SortOrder -eq "'Query Hash'")) {
					$ExcelStartRow = 17
				}
	
				Convert-TableToExcel $BlitzCacheTbl $ExcelSheet -StartRow $ExcelStartRow -DebugInfo:$DebugInfo -ExclCols "Query", "Query Plan"

				####Plan Cache warning
				$SheetName = "Plan Cache Warnings"

				#Specify worksheet
				$ExcelSheet = $ExcelFile.Worksheets.Item($SheetName)

				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = 3
				#$SortOrder containing avg or xpm will export data starting with row 16
				if (($SortOrder -like '*Average*') -or ($SortOrder -eq "'Executions per Minute'") -or ($SortOrder -eq "'Recent Compilations'")) {
					$ExcelStartRow = 36
				}

				if ($SortOrder -like '*CPU*') {
					$ExcelWarnInitCol = 1
				}
				elseif ($SortOrder -like '*Duration*') {
					$ExcelWarnInitCol = 6
				}
				elseif ($SortOrder -like '*Reads*') {
					$ExcelWarnInitCol = 11
				}
				elseif ($SortOrder -like '*Writes*') {
					$ExcelWarnInitCol = 16
				}
				elseif ($SortOrder -eq "'Executions'") {
					$ExcelWarnInitCol = 21
				}
				elseif ($SortOrder -eq "'Executions per Minute'") {
					$ExcelWarnInitCol = 21
				}
				elseif ($SortOrder -like '*Spills*') {
					$ExcelWarnInitCol = 26
				}
				elseif ($SortOrder -like '*Memory*') {
					$ExcelWarnInitCol = 31
				}
				elseif ($SortOrder -eq "'Recent Compilations'") {
					$ExcelWarnInitCol = 31
				}

				$ExcelURLCol = $ExcelWarnInitCol + 2
				$ExcelColNum = $ExcelWarnInitCol

				Convert-TableToExcel $BlitzCacheWarnTbl $ExcelSheet -StartRow $ExcelStartRow -StartCol $ExcelWarnInitCol -ExclCols "FindingHL" -DebugInfo:$DebugInfo -URLCols "URL" -MapURLToColNum $ExcelURLCol -URLTextCol "Finding"
				##Saving file 
				Save-ExcelFile $ExcelFile
			}	
			##Cleaning up variables 
			Invoke-ClearVariables BlitzCacheWarnTbl, BlitzCacheTbl, PSBlitzSet

		}

		$OldSortOrder = $SortOrder

		# Set @MinutesBack to NULL for the next sort order
		if (($OrigCacheMinutesBack -gt 0) -and $SortOrder -ne "'Recent Compilations'") {
			if ($DebugInfo) {
				Write-Host " ->Setting @MinutesBack to NULL for the next sort order" -fore yellow
			}
			[string]$Query = $Query -replace $NewCacheMinutesBackStr, $OldCacheMinutesBackStr
		}

		if ($JobStatus -ne "Running") {
			Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop Y
			$BlitzWhoPass += 1
		}
	}
	
	#####################################################################################
	#						sp_BlitzQueryStore											#
	#####################################################################################

	<#
		if no specific database name has been provided, check BlitzCache results for any database that
		might account for 2/3 of all the records returned by BlitzCache
	#>
	if (([string]::IsNullOrEmpty($CheckDB)) -and ($IsAzureSQLDB -eq $false)) {
		[int]$TwoThirdsBlitzCache = [Math]::Floor([decimal]($BlitzCacheRecs / 1.5))
		[string]$DBName = $DBArray | Group-Object -NoElement | Sort-Object Count | ForEach-Object Name | Select-Object -Last 1
		[int]$DBCount = $DBArray | Group-Object -NoElement | Sort-Object Count | ForEach-Object Count | Select-Object -Last 1
		if (($DBCount -ge $TwoThirdsBlitzCache) -and ($DBName -ne "-- N/A --") -and (!([string]::IsNullOrEmpty($DBName)))) {
			Write-Host " $DBName accounts for 2/3 of the records returned from cache"
			Write-Host " ->" -NoNewLine
			$StepStart = get-date
			[string]$CheckDB = $DBName
			$DBSwitched = "Y"
			$StepEnd = get-date
			Add-LogRow "CheckDB value" "Switched" "$DBName accounts for at least 2/3 of the records returned by sp_BlitzCache"
		}
		
	}

	##Check if DB is eligible for sp_BlitzQueryStore first
	if ((!([string]::IsNullOrEmpty($CheckDB))) -or ($IsAzureSQLDB)) {
		if ($DBSwitched -ne "Y") {
			Write-Host " " -NoNewLine
		}
		$CheckDBQuery = new-object System.Data.SqlClient.SqlCommand
		if (!([string]::IsNullOrEmpty($CheckDB))) {
			Write-Host "Checking if $CheckDB is eligible for Query Store check... " -NoNewline
			$DBQuery = @" 
		IF ( (SELECT PARSENAME(CONVERT(NVARCHAR(128), SERVERPROPERTY ('PRODUCTVERSION')), 4)) < 13 )
  BEGIN
      SELECT 'No' AS [EligibleForBlitzQueryStore]
  END
ELSE IF ( (SELECT PARSENAME(CONVERT(NVARCHAR(128), SERVERPROPERTY ('PRODUCTVERSION')), 4)) >= 13 )
  BEGIN
      IF(SELECT COUNT(*)
         FROM   sys.databases AS d
         WHERE  d.is_query_store_on = 1
                AND d.user_access_desc = 'MULTI_USER'
                AND d.state_desc = 'ONLINE'
                AND d.name = @DBName
                AND d.is_distributor = 0) > 0
        BEGIN
            SELECT 'Yes' AS [EligibleForBlitzQueryStore]
        END
      ELSE
        BEGIN
            SELECT 'No' AS [EligibleForBlitzQueryStore]
        END
  END;
"@
			$CheckDBQuery.CommandText = $DBQuery
			$CheckDBQuery.Parameters.Add("@DBName", [Data.SQLDBType]::NVarChar, 256) | Out-Null
			$CheckDBQuery.Parameters["@DBName"].Value = $CheckDB
		}
		elseif ($IsAzureSQLDB) {
			Write-Host "Checking if $ASDBName is eligible for Query Store check..." -NoNewline
			$DBQuery = @"
			IF ( (SELECT CAST(SERVERPROPERTY('Edition') AS NVARCHAR(128))) = N'SQL Azure' )
			BEGIN
				IF ( (SELECT SERVERPROPERTY ('EngineEdition')) NOT IN (5,8)
					  OR (SELECT [compatibility_level]
						  FROM   sys.[databases]
						  WHERE  [name] = DB_NAME()) < 130 )
				  BEGIN
					  SELECT 'No' AS [EligibleForBlitzQueryStore];
				  END;
				ELSE
				  BEGIN
					  SELECT 'Yes' AS [EligibleForBlitzQueryStore];
				  END;
			END;
		  ELSE
			BEGIN
				SELECT 'Dunno what this is' AS [EligibleForBlitzQueryStore];
			END;
"@
			$CheckDBQuery.CommandText = $DBQuery
		}
		
		$CheckDBQuery.Connection = $SqlConnection
		$CheckDBQuery.CommandTimeout = 100
		$CheckDBAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
		$CheckDBAdapter.SelectCommand = $CheckDBQuery
		$CheckDBSet = new-object System.Data.DataSet
		Try {
			$StepStart = get-date
			$CheckDBAdapter.Fill($CheckDBSet) | Out-Null -ErrorAction Stop
			$SqlConnection.Close()
			if ($CheckDBSet.Tables[0].Rows[0]["EligibleForBlitzQueryStore"] -eq "Yes") {
				Write-Host @GreenCheck
				
				$CheckQueryStore = 'Y'
			}
			elseif ($CheckDBSet.Tables[0].Rows[0]["EligibleForBlitzQueryStore"] -eq "No") {
				$StepEnd = Get-Date
				Write-Host "X (not eligible)" -Fore Yellow
				Add-LogRow "sp_BlitzQueryStore" "Skipped" "$CheckDB is not eligible"
			}
			else {
				$StepEnd = Get-Date
				$QSCheckResult = $CheckDBSet.Tables[0].Rows[0]["EligibleForBlitzQueryStore"] 
				Write-Host "X (not eligible)" -Fore Yellow
				Add-LogRow "sp_BlitzQueryStore" "Skipped" $QSCheckResult
			}
		}
		Catch {
			$CheckQueryStore = 'N'
			Invoke-ErrMsg
			$StepEnd = Get-Date
			Add-LogRow "sp_BlitzQueryStore precheck" "Failure"
		}
		if ($CheckQueryStore -eq 'Y') {
			$SqlScriptFilePath = Join-Path -Path $ResourcesPath -ChildPath "spQuickieStore_NonSPLatest.sql"
			[string]$Query = [System.IO.File]::ReadAllText("$SqlScriptFilePath")

			if ($IsAzureSQLDB) {
				Write-Host " Retrieving Query Store info for $ASDBName..." 
			}
			else {
				#if ($DBSwitched -eq "Y") {
					$OldCheckDBStr = ";SET @database_name = NULL;"
					$NewCheckDBStr = ";SET @database_name = N'" + $CheckDB + "';"
				#}
				Write-Host " Retrieving Query Store info for $CheckDB..." 
				[string]$Query = $Query -replace $OldCheckDBStr, $NewCheckDBStr
			}
			$SortOrders = @("cpu","duration")
			foreach ($SortOrder in $SortORders){ 
				Write-Host " ->Top 20 queries by $SortOrder..." -NoNewline
				#There are only 2 sort orders here and CPU is the default one, so I can be lazy for the time being
				[string]$Query = $Query -replace ";SET @sort_order = 'cpu';", ";SET @sort_order = '$SortOrder';"

			
			
			if ($IsAzureSQLDB) {
				
				Invoke-PSBlitzQuery -QueryIn $Query -StepNameIn "Query Store check for $ASDBName - $SortOrder" -ConnStringIn $ConnString -CmdTimeoutIn $MaxTimeout 
			}
			else {
				Invoke-PSBlitzQuery -QueryIn $Query -StepNameIn "Query Store check for $CheckDB - $SortOrder" -ConnStringIn $ConnString -CmdTimeoutIn $MaxTimeout
			}
			if ($global:StepOutcome -eq "Success") {
			
				$BlitzQSTbl = $global:PSBlitzSet.Tables[0]
				#$BlitzQSSumTbl = $global:PSBlitzSet.Tables[1]

				Export-PlansAndDeadlocks $BlitzQSTbl $PlanOutDir "query_plan" "sql_plan_file" -FPrefix "QueryStore_$SortOrder" -DebugInfo:$DebugInfo
				
				if ($ToHTML -eq "Y") {
					
					Add-QueryName $BlitzQSTbl "query" "query_sql_text" "QueryStore"

					$htmlTable1 = Convert-TableToHtml $BlitzQSTbl -ExclCols "query_sql_text", "query_plan", "database_name","n" -CSSClass "QueryStoreTab sortable" -AnchorFromHere -AnchorIDs "QueryStore" -DebugInfo:$DebugInfo

					$htmlTable3 = Convert-QueryTableToHtml $BlitzQSTbl -Cols "query", "query_sql_text" -CSSClass "QueryTbl" -AnchorToHere -AnchorID "QueryStore" -DebugInfo:$DebugInfo

					if ($IsAzureSQLDB) {
						$HtmlTabName = "Query Store results for $ASDBName - $SortOrder"
					}
					else {
						$HtmlTabName = "Query Store results for $CheckDB - $SortOrder"
					}
					$html = $HTMLPre + @"
				<title>$HtmlTabName</title>
					$HTMLBodyStart
					<h1 id="top">$HtmlTabName</h1>
					<br>
					<p><a href="#Queries">Jump to query text</a></p>
					$htmlTable1
					<br>
					<h2 id="Queries">Query text</h2>
					$htmlTable3
					$JumpToTop
					$HTMLBodyEnd
"@

					Save-HtmlFile $html "BlitzQueryStore_$SortOrder.html" $HTMLOutDir $DebugInfo
					Invoke-ClearVariables html, htmlTable1, htmlTable2, htmlTable3

				}
				else {
					##export to excel
					$ExcelSheet = $ExcelFile.Worksheets.Item("Query Store Info")
					#Specify at which row in the sheet to start adding the data
					if($SortOrder -eq "duration"){
						$ExcelStartRow = 27
					} else {
					$ExcelStartRow = 3
					}
						
					Convert-TableToExcel $BlitzQSTbl $ExcelSheet -StartRow $ExcelStartRow -DebugInfo:$DebugInfo -ExclCols "query", "query_plan", "n"
					Save-ExcelFile $ExcelFile					
				}
				Invoke-ClearVariables BlitzQSTbl, BlitzQSSumTbl, PSBlitzSet
			}
		}
		}
		if ($DBSwitched -eq "Y") {
			$StepStart = get-date
			$CheckDB = ""
			$StepEnd = Get-Date
			Add-LogRow "CheckDB value" "Switched" "Switched back to empty from $DBName"
		}
	}
	if ($JobStatus -ne "Running") {
		Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop N
		$BlitzWhoPass += 1
	}

	#####################################################################################
	#						sp_BlitzIndex												#
	#####################################################################################
	#Building a list of values for $Modes
	if ($IsIndepth -eq "Y") {
		$Modes = @("1", "2", "4")
	}
	else {
		$Modes = @("0")
	}
	# Set OldMode variable 
	$OldMode = ";SET @Mode = 0;"
	$SqlScriptFilePath = Join-Path -Path $ResourcesPath -ChildPath "spBlitzIndex_NonSPLatest.sql"
	[string]$Query = [System.IO.File]::ReadAllText("$SqlScriptFilePath")
	#Set specific database to check if a name was provided
	if (!([string]::IsNullOrEmpty($CheckDB))) {
		[string]$Query = $Query -replace $OldCheckDBStr, $NewCheckDBStr
		[string]$Query = $Query -replace ";SET @GetAllDatabases = 1;", ";SET @GetAllDatabases = 0;"
		Write-Host " Retrieving index info for $CheckDB"
	}
	elseif ($IsAzureSQLDB) {
		[string]$Query = $Query -replace ";SET @GetAllDatabases = 1;", ";SET @GetAllDatabases = 0;"
		Write-Host " Retrieving index info for $ASDBName"
	}
	elseif ($UsrDBCount -ge $MaxUsrDBs) {
		#If the number of user databases >= MaxUsrDBs
		#set the database to the one that accounts for the most records in the plan cache
		$TopDBinCache = $DBArray | Where-Object { $_ -ne "-- N/A --" } | Group-Object | Sort-Object Count -Descending | Select-Object -First 1
		[string]$TopCacheDB = $TopDBinCache.Name
		[int]$TopCacheDBCount = $TopDBinCache.Count
		$TopCacheReplace = ";SET @DatabaseName = '" + $TopCacheDB + "';"
		Write-Host " You're trying to get index info on an instance with  $UsrDBCount databases." -ForegroundColor Yellow
		Write-Host " Doing so may cause temporary problems for the server and/or PSBlitz." -ForegroundColor Yellow
		Write-Host " Limiting index info to $($TopDBinCache.Name) which accounts for $TopCacheDBCount records returned from cache"
		Write-Host " Retrieving index info for $($TopDBinCache.Name)"
		[string]$Query = $Query -replace ';SET @DatabaseName = NULL;', $TopCacheReplace
		[string]$Query = $Query -replace ';SET @GetAllDatabases = 1;', ';SET @GetAllDatabases = 0;'
		Add-LogRow "sp_BlitzIndex" "User database count>= $MaxUsrDBs" "Limiting index info to $TopCacheDB which accounts for $TopCacheDBCount records in the plan cache results"
	}
 
	else {
		Write-Host " Retrieving index info for all user databases"

	}
	#Loop through $Modes
	foreach ($Mode in $Modes) {
		if ($Mode -eq "0") {
			Write-Host " ->Index diagnosis... " -NoNewLine
		}
		elseif ($Mode -eq "1") {
			Write-Host " ->Index summary... " -NoNewLine
		}
		elseif ($Mode -eq "2") {
			Write-Host " ->Index usage details... " -NoNewLine
		}
		elseif ($Mode -eq "4") {
			Write-Host " ->Detailed index diagnosis... " -NoNewLine
		}
		$NewMode = ";SET @Mode = " + $Mode + ";"
		[string]$Query = $Query -replace $OldMode, $NewMode
		Invoke-PSBlitzQuery -QueryIn $Query -StepNameIn "sp_BlitzIndex mode $Mode" -ConnStringIn $ConnString -CmdTimeoutIn $MaxTimeout
		
		if ($global:StepOutcome -eq "Success") {
			$BlitzIxTbl = $global:PSBlitzSet.Tables[0]
			if ("0", "4" -Contains $Mode) {
				#Export sample execution plans for missing indexes (SQL Server 2019 only)
					
				Export-PlansAndDeadlocks $BlitzIxTbl $PlanOutDir "Sample Query Plan" "Sample Plan File" -FPrefix "MissingIndex" -DebugInfo:$DebugInfo
			}
			if ($ToHTML -eq "Y") {
				$htmlTabSearch = ""
				if ($Mode -eq "0") {
					$HtmlTabName = "Index Diagnosis"
				}
				elseif ($Mode -eq "1") {
					$HtmlTabName = "Index Summary"
					if($BlitzIxTbl.Rows.Count -ge 5){
						$htmlTabSearch = $SearchTableDiv -replace $STDivReplace, "'IndexSummaryTable', 0" -replace 'object', 'database'
						$htmlTabSearch +="<br>"
					}
				}
				elseif ($Mode -eq "2") {
					$HtmlTabName = "Index Usage Details"

				}
				elseif ($Mode -eq "4") {
					$HtmlTabName = "Detailed Index Diagnosis"
				}
				if ((!([string]::IsNullOrEmpty($CheckDB))) -or ($IsAzureSQLDB)) {
					$HtmlTabName += " for $ASDBName$CheckDB"
					$ExclCols = @("Sample Query Plan","Display Order", "Database Name","Finding","URL")
					$Mode2SearchCol = 0
					$Mode2CSS = "IndexUsageTableDB sortable"
				}
				else {
					$ExclCols = @("Sample Query Plan","Display Order","Finding","URL")
					$Mode2SearchCol = 1
					$Mode2CSS = "IndexUsageTable sortable"
				}						
		
				if ("0", "4" -Contains $Mode) {	
					if (([string]::IsNullOrEmpty($CheckDB)) -and ($IsAzureSQLDB -eq $false)) {
						$htmlTabSearch = $SearchTableDiv -replace $STDivReplace, "'IndexUsgTable', 2" -replace 'object', 'database'
						$htmlTabSearch +="<br>"
					}							
					$htmlTable = Convert-TableToHtml $BlitzIxTbl -ExclCols $ExclCols -NoCaseChange -HyperlinkCol "FindingHL" -TblID "IndexUsgTable" -DebugInfo:$DebugInfo
				}
				elseif ($Mode -eq "1") {
					$htmlTable = Convert-TableToHtml $BlitzIxTbl -NoCaseChange -TblID "IndexSummaryTable" -ExclCols $ExclCols -DebugInfo:$DebugInfo
				}
				elseif ($Mode -eq "2") {
					$htmlTable = Convert-TableToHtml $BlitzIxTbl -TblID "IndexUsgTable" -CSSClass $Mode2CSS -ExclCols $ExclCols -NoCaseChange -DebugInfo:$DebugInfo
					$htmlTabSearch = $SearchTableDiv -replace $STDivReplace, "'IndexUsgTable', $Mode2SearchCol"
					$htmlTabSearch += "`n$SortableTable"
				}
		
				$html = $HTMLPre + @"
				<title>$HtmlTabName</title>
				$HTMLBodyStart
				<h1 id="top">$HtmlTabName</h1>
				$htmlTabSearch
				$htmlTable 
				<br>
				$(if ($Mode -ne "1") {$JumpToTop})
				$HTMLBodyEnd
"@

				Save-HtmlFile $html "BlitzIndex_$Mode.html" $HTMLOutDir $DebugInfo
				Invoke-ClearVariables html, htmlTable
			}
			else {
			
				if ($Mode -eq "0") {
					$SheetName = "Index Diagnostics"
				}
				elseif ($Mode -eq "1") {
					$SheetName = "Index Summary"
				}
				elseif ($Mode -eq "2") {
					$SheetName = "Index Usage"
				}
				elseif ($Mode -eq "4") {
					$SheetName = "Extended Index Diagnostics"
				}
			
				#Specify worksheet
				$ExcelSheet = $ExcelFile.Worksheets.Item($SheetName)
				if ("0", "4" -Contains $Mode) {
					Convert-TableToExcel $BlitzIxTbl $ExcelSheet -StartRow $DefaultStartRow -DebugInfo:$DebugInfo -ExclCols "Sample Query Plan","FindingHL" -URLCols "URL" -MapURLToColNum 2 -URLTextCol "Finding"
				}
				else {
					Convert-TableToExcel $BlitzIxTbl $ExcelSheet -StartRow $DefaultStartRow -DebugInfo:$DebugInfo
				}
			
				##Saving file 
				Save-ExcelFile $ExcelFile
			}
			##Cleaning up variables
			Invoke-ClearVariables BlitzIxTbl, PSBlitzSet
		}
		#Update $OldMode
		$OldMode = $NewMode

		if ($JobStatus -ne "Running") {
			Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop Y
			$BlitzWhoPass += 1
		}
	}	

	####################################################################
	#						sp_BlitzLock
	####################################################################
	$CurrTime = get-date
	$CurrRunTime = (New-TimeSpan -Start $StartDate -End $CurrTime).TotalMinutes
	if (!([string]::IsNullOrEmpty($CheckDB))) {
		Write-Host " Retrieving deadlock info for $CheckDB... " -NoNewLine
	}
	elseif ($IsAzureSQLDB) {
		Write-Host " Retrieving deadlock info for $ASDBName... " -NoNewLine
	}
	else {
		Write-Host " Retrieving deadlock info for all user databases... " -NoNewLine
	}
	$SqlScriptFilePath = Join-Path -Path $ResourcesPath -ChildPath "spBlitzLock_NonSPLatest.sql"
	[string]$Query = [System.IO.File]::ReadAllText("$SqlScriptFilePath")
	#Set specific database to check if a name was provided
	if (!([string]::IsNullOrEmpty($CheckDB))) {
		[string]$Query = $Query -replace $OldCheckDBStr, $NewCheckDBStr
	}
	#Change date range if execution time so far > 15min
	if ([Math]::Round($CurrRunTime) -gt 15) {
		$CurrMin = [Math]::Round($CurrRunTime)
		Write-Host ""
		Write-Host " ->Current execution time is $CurrMin minutes"
		Write-Host " ->Retrieving deadlock info for the last 7 days instead of 15... " -NoNewLine
		[string]$Query = $Query -replace "@StartDate = DATEADD(DAY,-15, GETDATE()),", "@StartDate = DATEADD(DAY,-7, GETDATE()),"
	}
	Invoke-PSBlitzQuery -QueryIn $Query -StepNameIn "sp_BlitzLock" -ConnStringIn $ConnString -CmdTimeoutIn $MaxTimeout
		
	if ($global:StepOutcome -eq "Success") {
		$TblLockDtl = $global:PSBlitzSet.Tables[0]
		$TblLockPlans = $global:PSBlitzSet.Tables[1]
		$TblLockOver = $global:PSBlitzSet.Tables[2]
		[int]$RowsReturned = $TblLockDtl.Rows.Count
		if ($RowsReturned -le 0) {
			Write-Host " ->No deadlocks found"
		}
		else {
			##Exporting deadlock graphs to file
			Export-PlansAndDeadlocks $TblLockDtl $XDLOutDir "deadlock_graph" "deadlock_graph_file" -DebugInfo:$DebugInfo -FileNameFromColumn

			##Exporting execution plans to file
			Export-PlansAndDeadlocks $TblLockPlans $PlanOutDir "query_plan" "sqlplan_file" -FPrefix "DeadlockPlan" -DebugInfo:$DebugInfo
		
			if ($ToHTML -eq "Y") {
				$HtmlTabName = "Deadlocks"
				if ((!([string]::IsNullOrEmpty($CheckDB))) -or ($IsAzureSQLDB)) {
					$HtmlTabName += " for $ASDBName$CheckDB" 
				}
				
				$htmlTable1 = Convert-TableToHtml $TblLockOver -DebugInfo:$DebugInfo
			
				$htmlTable2 = Convert-TableToHtml $TblLockDtl -TblID "DeadlockDtlTable" -CSSClass "DeadlockDetailsTable" -AnchorFromHere -AnchorIDs "DL" -ExclCols "query_text", "deadlock_graph" -DebugInfo:$DebugInfo

				$htmlTable3 = Convert-QueryTableToHtml $TblLockDtl -Cols "query", "query_text" -CSSClass "QueryTbl" -AnchorToHere -AnchorID "DeadlockDtlTable" -DebugInfo:$DebugInfo

				Add-QueryName $TblLockPlans "query" "query_text" "DeadlockPlan"

				$htmlTable4 = Convert-TableToHtml $TblLockPlans -AnchorFromHere -ExclCols "query_text", "query_plan" -AnchorIDs "DeadlockPlan" -DebugInfo:$DebugInfo

				$htmlTable5 = Convert-QueryTableToHtml $TblLockPlans -Cols "query", "query_text" -CSSClass "QueryTbl" -AnchorToHere -AnchorID "DeadlockPlan" -DebugInfo:$DebugInfo
		
				$html = $HTMLPre + @"
		<title>$HtmlTabName</title>
		$HTMLBodyStart
		<h1 id="top">$HtmlTabName</h1>
		<h2>Deadlock Overview</h2>
		<p><a href="#Deadlocks1">Jump to deadlock details</a></p>
"@
				if ($TblLockPlans.Rows.Count -gt 0) {
					$html += @"
		<p><a href="#Deadlocks2">Jump to execution plans</a></p>
"@
				}
				$html += @"
		$htmlTable1
		$JumpToTop
		<br>
		<h2 id="Deadlocks1">Deadlock Details</h2>
		$(if($TblLockDtl.Rows.Count -ge 10){
			$SearchTableDiv -replace $STDivReplace, "'DeadlockDtlTable',7"
			'<br>'})
		$htmlTable2
		$JumpToTop
		
"@
				if ($TblLockPlans.Rows.Count -gt 0) {
					$html += @"
	    <br>
		<h2 id="Deadlocks2">Execution Plans Involved in Deadlocks</h2>
		$htmlTable4
		$JumpToTop
		<br>
		<h2>Query Text For Execution Plans Involved in Deadlocks</h2>
		$htmlTable5
		$JumpToTop
"@
				}

				$html += @"
		<br>
		<h2>Query Text For Deadlock Details</h2>
		$htmlTable3
		$JumpToTop
		$HTMLBodyEnd
"@
				
				
				Save-HtmlFile $html "BlitzLock.html" $HTMLOutDir $DebugInfo
				Invoke-ClearVariables html, htmlTable1, htmlTable2, htmlTable3, htmlTable4, htmlTable5
				
			}
			else {
				## populating the "sp_BlitzLock Details" sheet
				$ExcelSheet = $ExcelFile.Worksheets.Item("Deadlock Details")

				Convert-TableToExcel $TblLockDtl $ExcelSheet -StartRow $DefaultStartRow -DebugInfo:$DebugInfo -ExclCols "deadlock_graph", "query"

				##Saving file 
				Save-ExcelFile $ExcelFile

				## populating the "sp_BlitzLock Overview" sheet
				$ExcelSheet = $ExcelFile.Worksheets.Item("Deadlock Overview")

				Convert-TableToExcel $TblLockOver $ExcelSheet -StartRow $DefaultStartRow -DebugInfo:$DebugInfo

				##Saving file 
				Save-ExcelFile $ExcelFile

				## populating the "sp_BlitzLock Plans" sheet
				$ExcelSheet = $ExcelFile.Worksheets.Item("Deadlock Plans")
				
				Convert-TableToExcel $TblLockPlans $ExcelSheet -StartRow $DefaultStartRow -DebugInfo:$DebugInfo -ExclCols "query_plan", "query"

				##Saving file 
				Save-ExcelFile $ExcelFile
			}
			##Cleaning up variables
			Invoke-ClearVariables TblLockDtl, TblLockPlans, TblLockOver, PSBlitzSet
		}
	}

	if ($JobStatus -ne "Running") {
		Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop N
		$BlitzWhoPass += 1
	}


	#####################################################################################
	#						Stats & Index info											#
	#####################################################################################

	<#
		if db was switched for querystore we can switch it again without doing all the math again
	#>
	if ($DBSwitched -eq "Y") {
		Write-Host " $DBName accounts for 2/3 of the records returned from cache"
		$StepStart = get-date
		Write-Host " ->" -NoNewline
		[string]$CheckDB = $DBName
		$DBSwitched = "Y"
		$StepEnd = get-date
		Add-LogRow "CheckDB value" "Switched" "$DBName accounts for at least 2/3 of the records returned by sp_BlitzCache"
	}
	
	#Only run the check if a specific database name has been provided
	if ((!([string]::IsNullOrEmpty($CheckDB))) -or ($IsAzureSQLDB)) {
		if ($DBSwitched -ne "Y") {
			Write-Host " " -NoNewLine
		}
		$SqlScriptFilePath = Join-Path -Path $ResourcesPath -ChildPath "GetStatsInfoForWholeDB.sql"
		[string]$Query = [System.IO.File]::ReadAllText("$SqlScriptFilePath")
		if ($IsAzureSQLDB) {
			Write-Host "Retrieving stats info for $ASDBName... " -NoNewLine
			#if it's Azure SQL DB, we can't switch databases
			[string]$Query = $Query.replace('USE [..PSBlitzReplace..];', '')
		}
		else {
			Write-Host "Retrieving stats info for $CheckDB... " -NoNewLine		
			[string]$Query = $Query -replace "..PSBlitzReplace.." , $CheckDB
		}
		Invoke-PSBlitzQuery -QueryIn $Query -StepNameIn "Stats Info" -ConnStringIn $ConnString -CmdTimeoutIn $MaxTimeout
		
		if ($global:StepOutcome -eq "Success") {
			$StatsTbl = $global:PSBlitzSet.Tables[0]
			[int]$RowsReturned = $StatsTbl.Rows.Count
			if ($RowsReturned -le 0) {
				Write-Host " ->No rows returned."
			}
			else {
				if ($ToHTML -eq "Y") {

					$htmlTable = Convert-TableToHtml $StatsTbl -TblID "StatsOrIxFragTable" -ExclCols "database" -DebugInfo:$DebugInfo
					#add tooltips
					$htmlTable = $htmlTable -replace '<th>Update ', '<th class="tooltip" title="The commented options are suggestions based on record counts.">Update '
					#add buttons
					$htmlTable = $htmlTable -replace '<th>Get Details', '<th>Get Details<button class="copyButton" title="Click to copy the commands from this column" data-table-id="StatsOrIxFragTable" data-column-index="20">Copy all commands</button>'
					$htmlTable = $htmlTable -replace 'counts.">Update Table Stats', 'counts.">Update Table Stats<button class="copyButton" title="Click to copy the commands from this column" data-table-id="StatsOrIxFragTable" data-column-index="21">Copy all commands</button>'
					$htmlTable = $htmlTable -replace 'counts.">Update Individual Stats', 'counts.">Update Individual Stats<button class="copyButton" title="Click to copy the commands from this column" data-table-id="StatsOrIxFragTable" data-column-index="22">Copy all commands</button>'
					$htmlTable = $htmlTable -replace 'counts.">Update Partition Stats', 'counts.">Update Partition Stats<button class="copyButton" title="Click to copy the commands from this column" data-table-id="StatsOrIxFragTable" data-column-index="23">Copy all commands</button>'
					if ($IsAzureSQLDB) {
						$HtmlTabName = "Statistics info for $ASDBName"
						$HtmlFileName = "StatsInfo_$ASDBName.html"
					}
					else {
						$HtmlTabName = "Statistics info for $CheckDB"
						$HtmlFileName = "StatsInfo_$CheckDB.html"
					}
					$html = $HTMLPre + @"
				<title>$HtmlTabName</title>
				$HTMLBodyStart
				<h1>$HtmlTabName</h1>
				$($SearchTableDiv -replace $STDivReplace, "'StatsOrIxFragTable', 0")
				<!-- Message container -->
                <div id="message">Copied to clipboard!</div>
				<br>
				$htmlTable
				$JumpToTop
				$HTMLBodyEnd
"@
					Save-HtmlFile $html $HtmlFileName $HTMLOutDir $DebugInfo
					Invoke-ClearVariables html, htmlTable			
				}
				else {

					$ExcelSheet = $ExcelFile.Worksheets.Item("Statistics Info")

					Convert-TableToExcel $StatsTbl $ExcelSheet -StartRow $DefaultStartRow -DebugInfo:$DebugInfo
					##Saving file
					Save-ExcelFile $ExcelFile
				}
			}
			##Cleaning up variables
			Invoke-ClearVariables StatsTbl, PSBlitzSet		
		}

		if ($JobStatus -ne "Running") {
			Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop N
			$BlitzWhoPass += 1
		}
		### get index frag info
		$SqlScriptFilePath = Join-Path -Path $ResourcesPath -ChildPath "GetIndexInfoForWholeDB.sql"
		[string]$Query = [System.IO.File]::ReadAllText("$SqlScriptFilePath")
		if ($DBSwitched -ne "Y") {
			Write-Host " " -NoNewLine
		}
		elseif ($DBSwitched -eq "Y") {
			Write-Host " ->" -NoNewLine
		}
		if ($IsAzureSQLDB) { 
			Write-Host "Retrieving index fragmentation info for $ASDBName... " -NoNewLine
			#if it's Azure SQL DB, we can't switch databases
			[string]$Query = $Query.replace('USE [..PSBlitzReplace..];', '')
			[string]$Query = $Query -replace "AzureSQLDBReplace", "$DirDate"
		}
		else {
			Write-Host "Retrieving index fragmentation info for $CheckDB... " -NoNewLine
		
			[string]$Query = $Query -replace "..PSBlitzReplace.." , $CheckDB
		}
		Invoke-PSBlitzQuery -QueryIn $Query -StepNameIn "Index Frag Info" -ConnStringIn $ConnString -CmdTimeoutIn $MaxTimeout	
		if ($global:StepOutcome -eq "Success") {
			$IndexTbl = $global:PSBlitzSet.Tables[0]
			$IndexLckTbl = $global:PSBlitzSet.Tables[1]
			$RecordsReturned = $IndexTbl.Rows.Count
			if ($RecordsReturned -le 0) {
				Write-Host " ->No rows returned."
			}
			else {
				if ($IndexLckTbl.Rows.Count -gt 0) {
					$RowNum = 0
					Write-Host " ->Exclusive lock detected on table(s):"
					$LockedTabList = ""
					$LockedTabLogMsg = "Exclusive locks on table(s):"
					foreach ($row in $IndexLckTbl) {
						$LockedTab = $IndexLckTbl.Rows[$RowNum]["object_name"]
						Write-Host "  - $LockedTab"
						if ($RowNum -eq 0) { 
							$LockedTabList += "$LockedTab" 
						}
						else {
							$LockedTabList += ", $LockedTab"
						}
						$RowNum += 1
					}
				
					Add-LogRow "->Index Frag Info" "Skipped XLocked Tables" "$LockedTabLogMsg $LockedTabList"
				}
				if ($ToHTML -eq "Y") {
				
					if ($DebugInfo) {
						Write-Host " ->Converting index info to HTML" -fore yellow
					}

					$htmlTable = Convert-TableToHtml $IndexTbl -TblID "StatsOrIxFragTable" -ExclCols "database" -CSSClass "sortable" -DebugInfo:$DebugInfo
					if ($IsAzureSQLDB) {
						$HtmlTabName = "Index fragmentation info for $ASDBName"
						$HtmlFileName = "IndexFragInfo_$ASDBName.html"
					}
					else {
						$HtmlTabName = "Index fragmentation info for $CheckDB"
						$HtmlFileName = "IndexFragInfo_$CheckDB.html"
					}
			
					$html = $HTMLPre + @"
				<title>$HtmlTabName</title>
				$HTMLBodyStart
				<h1>$HtmlTabName</h1>
				$($SearchTableDiv -replace $STDivReplace, "'StatsOrIxFragTable', 0")
				$SortableTable
				$htmlTable
				$JumpToTop
				$HTMLBodyEnd
"@

					Save-HtmlFile $html $HtmlFileName $HTMLOutDir $DebugInfo
					Invoke-ClearVariables html, htmlTable
				}
				else {
					$ExcelSheet = $ExcelFile.Worksheets.Item("Index Fragmentation")
					Convert-TableToExcel $IndexTbl $ExcelSheet -StartRow $DefaultStartRow -DebugInfo:$DebugInfo
					##Saving file
					Save-ExcelFile $ExcelFile
				}
				##Cleaning up variables
				Invoke-ClearVariables IndexTbl, PSBlitzSet
			} 
		}
	

		if ($JobStatus -ne "Running") {
			Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop N
			$BlitzWhoPass += 1
		}

		if ($DBSwitched -eq "Y") {
			$StepStart = get-date
			$CheckDB = ""
			$StepEnd = Get-Date
			Add-LogRow "CheckDB value" "Switched" "Switched back to empty from $DBName"
		}
	}

	$TryCompleted = "Y"
}

finally {
	if ($TryCompleted -eq "N") {
		Write-Host ""
		Write-Host " Script execution was interrupted." -Fore yellow
		Write-Host " ->Latest exception (if any):"
		[string]$TerminatingErrorMessage = Format-ExceptionMsg
		if ($TerminatingErrorMessage -eq "No exceptions encountered.") {
			Write-Host " $TerminatingErrorMessage" -Fore green
		}
		else {
			Write-Host " $TerminatingErrorMessage" -fore red
			if ($ToHTML -ne "Y") {
				Write-Host "  Debug Column: $global:DebugCol"
				Write-Host "  Debug Value: $global:DebugValue"
			}
		}
		#[string]$TerminatingErrorMessage = $error[0] | Select-Object -ExpandProperty Exception | Select-Object -ExpandProperty Message
		#Write-Host " $TerminatingErrorMessage"
		Add-LogRow "PSBlitz Execution" "Interrupted" "$TerminatingErrorMessage"
		Write-Host " Finishing up..." -Fore yellow
	}
	
	#####################################################################################
	#						sp_BlitzWho													#
	#####################################################################################
	###Create flag table to stop the job
	if ($JobStatus -eq "Running") {
		#Make sure the current state of the job is still Running
		$JobStatus = Get-Job -Name $JobName | Select-Object -ExpandProperty State
		if ($JobStatus -eq "Running") {
			if ($TryCompleted -eq "N") {
				Write-Host " Attempting to stop session activity collection background process... " -NoNewline
			}
			else {
				Write-Host " Stopping session activity collection background process... " -NoNewline
			}
			$CreatFlagTbl = "DECLARE @SQL NVARCHAR(400);`nSELECT @SQL = N'CREATE TABLE '+ CASE "
			$CreatFlagTbl += "`nWHEN CAST(SERVERPROPERTY('Edition') AS NVARCHAR(100)) = N'SQL Azure' "
			$CreatFlagTbl += "`nAND SERVERPROPERTY('EngineEdition') IN (5, 6) "
			$CreatFlagTbl += "`nTHEN N'[BlitzWhoOutFlag_$DirDate](ID INT);' "
			$CreatFlagTbl += "`nELSE N'[tempdb].[dbo].[BlitzWhoOutFlag_$DirDate](ID INT);' `nEND; `nEXEC(@SQL);"
			$CreatFlagTblCommand = new-object System.Data.SqlClient.SqlCommand
			$CreatFlagTblCommand.CommandText = $CreatFlagTbl
			$CreatFlagTblCommand.CommandTimeout = 30
			Try {
				$StepStart = Get-Date
				$SqlConnection.Open() | Out-Null -ErrorAction Stop
				$CreatFlagTblCommand.Connection = $SqlConnection
				$CreatFlagTblCommand.ExecuteNonQuery() | Out-Null -ErrorAction Stop
				$SqlConnection.Close()
				$FlagCreated = "Y"
				if ($DebugInfo) {
					Write-Host ""
					Write-Host " ->Flag Table created" -Fore Yellow
				}
				$StepOutcome = "Success"
				$StepEnd = Get-Date
				Add-LogRow "BlitzWho Flag table creation" $StepOutcome
			}
			Catch {
				$StepEnd = Get-Date
				$JobOutcome = Stop-Job $JobName
				Write-Host $JobOutcome 
				$LogtxtFilePath = Join-Path -Path $OutDir -ChildPath "sp_BlitzWhoBackgroundJobLog.txt"
				$JobOutcome | Out-File utf8 -FilePath "$LogtxtFilePath" -Append
				if ($DebugInfo) {
					Write-Host ""
					Write-Host " ->Failed to create " -NoNewline -Fore Yellow
					if ($IsAzureSQLDB) {
						Write-Host "[BlitzWhoOutFlag_$DirDate]" -Fore Yellow
					}
					else {
						Write-Host "[tempdb].[dbo].[BlitzWhoOutFlag_$DirDate]" -Fore Yellow
					}
					Write-Host " ->Forcing background process stop." -Fore Yellow
					
				}
				$StepOutcome = "Failure"
				Add-LogRow "BlitzWho Flag table creation" $StepOutcome
			}
			if ($FlagCreated -eq "Y") {
				$BlitzWhoDelay += 10
				Start-Sleep -Seconds $BlitzWhoDelay
				if ($DebugInfo) {
					Write-Host " ->Waiting for $BlitzWhoDelay seconds before getting session activity output." -Fore Yellow
				}
			}
			$JobStatus = Get-Job -Name $JobName | Select-Object -ExpandProperty State
			if ($JobStatus -ne "Running") {
				if ($DebugInfo) {
					Write-Host " ->Session activity collection process no longer running " -NoNewline -Fore Yellow
				}
				Write-Host @GreenCheck
				if ($DebugInfo) {
					Write-Host ""
				}
				$JobOutcome = Receive-Job -Name $JobName
				Write-Host $JobOutcome
				$LogtxtFilePath = Join-Path -Path $OutDir -ChildPath "sp_BlitzWhoBackgroundJobLog.txt"
				$JobOutcome | Out-File utf8 -FilePath "$LogtxtFilePath" -Append
				Add-LogRow "sp_BlitzWho background process" $JobStatus $JobOutcome
				#temp lines(2)
				#Write-Host $JobName.JobStateInfo.Reason.Message
				#Write-Host $JobName.Error
				Remove-Job -Name $JobName -Force
			}

		}
	}
	if ($TryCompleted -eq "N") {
		Write-Host	" Attempting to retrieve session actvity data... " -NoNewLine
	}
	else {
		Write-Host " Retrieving session actvity data... " -NoNewLine
	}
	$SqlScriptFilePath = Join-Path -Path $ResourcesPath -ChildPath "GetBlitzWhoData.sql"
	[string]$Query = [System.IO.File]::ReadAllText("$SqlScriptFilePath")
	[string]$Query = $Query -replace "BlitzWho_..BlitzWhoOut.." , "BlitzWho_$DirDate"
	[string]$Query = $Query -replace "BlitzWhoOutFlag_..BlitzWhoOut.." , "BlitzWhoOutFlag_$DirDate"
	if ($IsAzureSQLDB) {
		[string]$Query = $Query.replace('[tempdb].[dbo].', '')
		[string]$Query = $Query.replace('tempdb.dbo.', '')
	}
	Invoke-PSBlitzQuery -QueryIn $Query -StepNameIn "Return sp_BlitzWho" -ConnStringIn $ConnString -CmdTimeoutIn 800
	
	if ($global:StepOutcome -eq "Success") {
		$BlitzWhoTbl = $global:PSBlitzSet.Tables[0]
		$BlitzWhoAggTbl = $global:PSBlitzSet.Tables[1]
		[int]$RowsReturned = $BlitzWhoTbl.Rows.Count
		if ($RowsReturned -le 0) {
			Write-Host " ->No active sessions"
		}
		else {

			##Exporting execution plans to file and setting plan file names
			Export-PlansAndDeadlocks $BlitzWhoAggTbl $PlanOutDir "query_plan" "sqlplan_file" -FPrefix "RunningNow" -DebugInfo:$DebugInfo

			#Get capture time-frame
			$BtilzWhoStartTime = $BlitzWhoTbl | Sort-Object -Property "CheckDate" | Select-Object -ExpandProperty "CheckDate" -First 1
			$BtilzWhoEndTime = $BlitzWhoTbl | Sort-Object -Property "CheckDate" -Descending | Select-Object -ExpandProperty "CheckDate" -First 1

			if ($ToHTML -eq "Y") {
				$HtmlTabName = "Session Activity"
				if (!([string]::IsNullOrEmpty($CheckDB))) {
					$HtmlTabName += " for $CheckDB" 
				}
				elseif ($IsAzureSQLDB) {
					$HtmlTabName += " for $ASDBName"
				}

				$htmlTable = Convert-TableToHtml $BlitzWhoTbl -CSSClass "sortable" -DebugInfo:$DebugInfo
				$html = $HTMLPre + @"
				<title>$HtmlTabName</title>
				$HTMLBodyStart
				<h1>$HtmlTabName</h1>
				<br>
				$SortableTable
				$htmlTable
				$JumpToTop
				$HTMLBodyEnd
"@ 

				Save-HtmlFile $html "BlitzWho.html" $HTMLOutDir $DebugInfo
				Invoke-ClearVariables html, htmlTable

				$HtmlTabName = "Aggregated Session Activity"
				if (!([string]::IsNullOrEmpty($CheckDB))) {
					$HtmlTabName += " for $CheckDB" 
				}
				elseif ($IsAzureSQLDB) {
					$HtmlTabName += " for $ASDBName"
				}
				Add-QueryName $BlitzWhoAggTbl "Query" "query_text" "RunningNow"
				$htmlTable = Convert-TableToHtml $BlitzWhoAggTbl -CSSClass "ActiveSessionsTab sortable" -AnchorFromHere -AnchorIDs "RunningNow" -ExclCols "query_text", "query_plan" -DebugInfo:$DebugInfo
				$htmlTable1 = Convert-QueryTableToHtml $BlitzWhoAggTbl -Cols "query", "query_text" -CSSClass "QueryTbl" -AnchorToHere -AnchorID "RunningNow" -DebugInfo:$DebugInfo

				$html = $HTMLPre + @"
				<title>$HtmlTabName</title>
				$HTMLBodyStart
				<h1 id="top">$HtmlTabName</h1>
				<h3>Based on session activity captured between $BtilzWhoStartTime and $BtilzWhoEndTime server time.</h3>
				<p><a href="#Queries">Jump to query text</a></p>
				<br>
				$SortableTable
				$htmlTable 
				$JumpToTop
				<br>
				<h1 id="Queries">Query text</h1>
				<br>
				$htmlTable1
				<br>
				$JumpToTop
				$HTMLBodyEnd
"@ 
				Save-HtmlFile $html "BlitzWho_Agg.html" $HTMLOutDir $DebugInfo
				Invoke-ClearVariables html, htmlTable, htmlTable1

			}
			else {

				###Populating the "sp_BlitzWho" sheet
				$ExcelSheet = $ExcelFile.Worksheets.Item("Session Activity - Raw")
				
				##Saving file 
				Convert-TableToExcel $BlitzWhoTbl $ExcelSheet -StartRow $DefaultStartRow -DebugInfo:$DebugInfo
				$ExcelFile.Save()

				###Populating the "sp_BlitzWho Aggregate" sheet
				$ExcelSheet = $ExcelFile.Worksheets.Item("Session Activity - Aggregated")
				##Add session capture interval
				$ExcelSheet.Cells.Item(1, 6) = $BtilzWhoStartTime
				$ExcelSheet.Cells.Item(1, 8) = $BtilzWhoEndTime
				
				Convert-TableToExcel $BlitzWhoAggTbl $ExcelSheet -ExclCols "query", "query_plan" -StartRow 3 -DebugInfo:$DebugInfo

				##Saving file 
				Save-ExcelFile $ExcelFile
			}
		}
		##Cleaning up variables
		Invoke-ClearVariables BlitzWhoTbl, BlitzWhoAggTbl, PSBlitzSet
	}
	$SqlConnection.Close()
	$SqlConnection.Dispose()

	#####################################################################################
	#						Delete unused sheets 										#
	#####################################################################################
	$StepStart = get-date
	$StepEnd = Get-Date
	Add-LogRow "Check end" "Finished"

	if ($ToHTML -ne "Y") {
		if ($IsIndepth -ne "Y") {
			$DeleteSheets = @("Wait Stats", "Storage Stats", "Perfmon Stats", "Index Summary",
				"Index Usage", "Extended Index Diagnostics", 
				"Top Queries - Reads", "Top Queries - Executions", "Top Queries - Writes",
				"Top Queries - Spills", "Top Queries - Mem & Recent Comp", "Intro")
			foreach ($SheetName in $DeleteSheets) {
				$ExcelSheet = $ExcelFile.Worksheets.Item($SheetName)
				#$ExcelSheet.Visible = $false
				$ExcelSheet.Delete()
			}
			if ($IsAzureSQLDB) {
				#Delete the "Database Info" and sp_Blitz rows in the Intro sheet
				$ExcelSheetUpd = $ExcelFile.Worksheets.Item("Intro ")
				$ExcelSheetUpd.Cells.Item(13, 1).EntireRow.Delete() | Out-Null
				$ExcelSheetUpd.Cells.Item(12, 1).EntireRow.Delete() | Out-Null
				$ExcelSheetUpd.Cells.Item(11, 1).EntireRow.Delete() | Out-Null		
				
				$DeleteSheets = @("Database Info", "Instance Health", "DB Scoped Config")
				foreach ($SheetName in $DeleteSheets) {
					$ExcelSheet = $ExcelFile.Worksheets.Item($SheetName)
					$ExcelSheet.Delete()
				}
			}
			elseif ($IsAzureSQLDB -eq $false) {
				if (($MajorVers -lt 13) -or ([string]::IsNullOrEmpty($CheckDB))) {
					$ExcelSheetUpd = $ExcelFile.Worksheets.Item("Intro ")
					$ExcelSheetUpd.Cells.Item(12, 1).EntireRow.Delete() | Out-Null
					$ExcelSheet = $ExcelFile.Worksheets.Item("DB Scoped Config")
					$ExcelSheet.Delete()
				}
				#delete the Azure SQL DB Info row
				$ExcelSheetUpd = $ExcelFile.Worksheets.Item("Intro ")
				$ExcelSheetUpd.Cells.Item(10, 1).EntireRow.Delete() | Out-Null
				$ExcelSheet = $ExcelFile.Worksheets.Item("Azure SQL DB Info")
				$ExcelSheet.Delete()
			}
		}
		else {
			#Delete unused sheet (yes, this sheet has a space in its name)
			$DeleteSheets = @("Intro ", "Index Diagnostics")
			foreach ($SheetName in $DeleteSheets) {
				$ExcelSheet = $ExcelFile.Worksheets.Item($SheetName)
				$ExcelSheet.Delete()
			}

			if ($IsAzureSQLDB) {
				#Delete the "Database Info" and sp_Blitz rows in the Intro sheet
				$ExcelSheetUpd = $ExcelFile.Worksheets.Item("Intro")
				$ExcelSheetUpd.Cells.Item(13, 1).EntireRow.Delete() | Out-Null
				$ExcelSheetUpd.Cells.Item(12, 1).EntireRow.Delete() | Out-Null
				$ExcelSheetUpd.Cells.Item(11, 1).EntireRow.Delete() | Out-Null
				$DeleteSheets = @("Database Info", "Instance Health", "DB Scoped Config")
				foreach ($SheetName in $DeleteSheets) {
					$ExcelSheet = $ExcelFile.Worksheets.Item($SheetName)
					$ExcelSheet.Delete()
				}
			}
			elseif ($IsAzureSQLDB -eq $false) {
				if (($MajorVers -lt 13) -or ([string]::IsNullOrEmpty($CheckDB))) {
					$ExcelSheetUpd = $ExcelFile.Worksheets.Item("Intro")
					$ExcelSheetUpd.Cells.Item(12, 1).EntireRow.Delete() | Out-Null
					$ExcelSheet = $ExcelFile.Worksheets.Item("DB Scoped Config")
					$ExcelSheet.Delete()
				}
				#delete the Azure SQL DB Info row
				$ExcelSheetUpd = $ExcelFile.Worksheets.Item("Intro")
				$ExcelSheetUpd.Cells.Item(10, 1).EntireRow.Delete() | Out-Null
				$ExcelSheet = $ExcelFile.Worksheets.Item("Azure SQL DB Info")
				$ExcelSheet.Delete()
			}

		}

		if (([string]::IsNullOrEmpty($CheckDB)) -and ([string]::IsNullOrEmpty($DBName)) -and ($IsAzureSQLDB -eq $false)) {
			$DeleteSheets = @("Statistics Info", "Index Fragmentation")
			foreach ($SheetName in $DeleteSheets) {
				$ExcelSheet = $ExcelFile.Worksheets.Item($SheetName)
				$ExcelSheet.Delete()
			}
		}

		##Insert log data in Excel
		##Populating the "ExecutionLog" sheet
		if ($DebugInfo) {
			Write-Host " Saving execution log for this run of PSBlitz..."
		}
		$ExcelSheet = $ExcelFile.Worksheets.Item("ExecutionLog")

		Convert-TableToExcel $LogTbl $ExcelSheet -StartRow 3 -DebugInfo:$DebugInfo
		##Saving file 
		Save-ExcelFile $ExcelFile
	}

	#####################################################################################
	#							Check end												#
	#####################################################################################
	###Record execution start and end times
	$EndDate = get-date
	if ($ToHTML -ne "Y") {
		if ($IsIndepth -eq "Y") {
			$ExcelSheet = $ExcelFile.Worksheets.Item("Intro")
		}
		else {
			$ExcelSheet = $ExcelFile.Worksheets.Item("Intro ")
		}
		$ExcelSheet.Cells.Item(5, 6) = $StartDate.ToString("yyyy-MM-dd HH:mm:ss")
		$ExcelSheet.Cells.Item(6, 6) = $EndDate.ToString("yyyy-MM-dd HH:mm:ss")
		$ExcelSheet.Cells.Item(6, 4) = $Vers

		###Save and close Excel file and app
		Save-ExcelFile $ExcelFile
		Start-Sleep -Seconds 1
		$ExcelFile.Close()
		Start-Sleep -Seconds 1
		$ExcelApp.Quit()
		[System.Runtime.Interopservices.Marshal]::ReleaseComObject($ExcelApp) | Out-Null
		Remove-Variable -Name ExcelApp
		###Rename output file 
		if (!([string]::IsNullOrEmpty($CheckDB))) {
			$OutExcelFName = "PSBlitzOutput_$InstName_$CheckDB.xlsx"
		}
		else {
			$OutExcelFName = "PSBlitzOutput_$InstName.xlsx"
		}
		Rename-Item -Path $OutExcelF -NewName $OutExcelFName -Force
	}

	$ExecTime = (New-TimeSpan -Start $StartDate -End $EndDate).ToString()
	$ExecTime = $ExecTime.Substring(0, $ExecTime.IndexOf('.'))
	if ($ToHTML -eq "Y") {
		if ($DebugInfo) {
			Write-Host " ->Generating index and execution log pages." -fore yellow
		} 
		$HTMLChk = "&#10004;"
		$HtmlTabName = "PSBlitz Execution Log"
		$htmlTable = Convert-TableToHtml $LogTbl -NoCaseChange -CSSClass LogTbl -DebugInfo:$DebugInfo
		$html = $HTMLPre + @"
						<title>$HtmlTabName</title>
						$HTMLBodyStart
						<h1 id="top">$HtmlTabName</h1>
						<p>To report an issue, plese use <a href='https://github.com/VladDBA/PSBlitz/issues' target='_blank'>GitHub</a>, but make sure to read <a href='https://github.com/VladDBA/PSBlitz/issues/216' target='_blank'>this</a> first.</p>
						$htmlTable
						$JumpToTop
				 		$Footer 
						$HTMLBodyEnd
"@ 

		Save-HtmlFile $html "ExecutionLog.html" $HTMLOutDir $DebugInfo
		Invoke-ClearVariables html, htmlTable

		### Index page intro portion
		$AzureEnv = ""
		if ($IsAzureSQLMI) {
			$AzureEnv = "- Azure SQL MI"
		}
		if ($IsAzureSQLDB) {
			$AzureEnv = "- Azure SQL DB"
			$DbPortion = "- $ASDBName"
		}
		elseif (!([string]::IsNullOrEmpty($CheckDB))) {
			$DbPortion = "- database-specific check: $CheckDB"
		}
		else {
			$DbPortion = "- instance-wide check"
		}
		$IndexContent = @"
				<!DOCTYPE html>
				<html>
				<head>
				<link rel="stylesheet" href="HTMLFiles\styles.css">
				<title>PSBlitz Output For $InstName</title>
				</head>
				<body>
    <h1>PSBlitz Output For $($InstName.Replace(".database.windows.net", "")) $AzureEnv $DbPortion</h1>
    <table class="IntroTbl">
				<tr>
				<th>Generated With</th>
				<th>Version</th>
				<th>Execution start</th>
				<th>Execution end</th>
				<th>Duration<br>(hh:mm:ss)</th>
				</tr>
				<tr>
				<td><a href='https://github.com/VladDBA/PSBlitz' target='_blank'>PSBlitz.ps1</a></td>
				<td>$Vers</td>
				<td>$($StartDate.ToString("yyyy-MM-dd HH:mm:ss"))</td>
				<td>$($EndDate.ToString("yyyy-MM-dd HH:mm:ss"))</td>
				<td>$ExecTime</td>
				</tr>
    </table>
    <br>
    <h1>Table of contents</h1>
    <table class="IndexPageTbl">
				<tr>
				<th>Report Page</th>
				<th>Description<br>(hover over descriptions for query sources)</th>
				<th class=`"tooltip`" title=`"Exports execution plan files`">sqlplan</th>
				<th class=`"tooltip`" title=`"Exports deadlock graph files`">xdl</th>
				<th class=`"tooltip`" title=`"Max rows per page to ensure the it&apos;s still usabe in a browser.`">Max Rows</th>
				</tr>
"@

		# Build an HTML file that acts as the index pointing to all the HTML files that make up the report	
		$HtmlFiles = Get-ChildItem -Path $HTMLOutDir -Filter *.html | Sort-Object CreationTime
		foreach ($File in $HtmlFiles) {
			$AdditionalInfo = ""
			$Plans = "<td></td>"
			$DLGraphs = "<td></td>"
			$RLim = "<td></td>"
			$QuerySource = "Query source: "
			# Get the file name without the extension and replace any underscores with spaces for the description.
			$Description = $File.BaseName.Replace("_", " ")
			# Create a row in the table with a link to the file and its description.
			$RelativePath = Join-Path -Path . -ChildPath "HTMLFiles" 
			$RelativePath = Join-Path -Path $RelativePath -ChildPath $File.Name
			if ($File.Name -eq "spBlitz.html") {
				$Description = "Instance-level health information"
				$PageName = "Instance Health"
				$QuerySource += "Similar to sp_Blitz @CheckServerInfo = 1"
				if ($GetUsrDBObj) {
					$QuerySource += ", @CheckUserDatabaseObjects = 1"
					$Description += " including a review of user databases for misconfigurations"
				}	
				$QuerySource += ";"
				$Description += "."
			}
			elseif ($File.Name -like "InstanceInfo*") {
				$PageName = "Instance Information"
				$QuerySource += "sys.dm_os_sys_info, sys.dm_os_performance_counters and SERVERPROPERTY()"
				$Description = "Summary information about the instance and its resources."
			}
			elseif ($File.Name -like "TempDBInfo*") {
				$PageName = "TempDB Information"
				$QuerySource += "dm_db_file_space_usage, dm_db_partition_stats, dm_exec_requests"
				$Description = "Information pertaining to TempDB usage, size and configuration."
			}
			elseif ($File.Name -like "OpenTransactions*") {
				$PageName = "Open Transactions"
				$Plans="<td>$HTMLChk</td>"
				$QuerySource += "sys.dm_tran_session_transactions, sys.dm_tran_active_transactions, sys.dm_exec_sessions, sys.dm_exec_connections, and sys.dm_exec_requests"
				$Description = "Information about currently open transactions."
			}
			elseif ($File.Name -like "BlitzIndex*") {
				$Mode = $File.Name.Replace('BlitzIndex_', '')
				$Mode = $Mode.Replace('.html', '')
				$QuerySource += "Similar to sp_BlitzIndex @Mode = $Mode"
				if (!([string]::IsNullOrEmpty($CheckDB))) {
					$QuerySource += ", @DatabaseName = '$CheckDB'; "
				}
				elseif ($UsrDBCount -ge $MaxUsrDBs) {
					$QuerySource += ", @DatabaseName = '$TopCacheDB'; "
				}
				else {
					$QuerySource += ", @GetAllDatabases = 1; "
				}
				$AdditionalInfo = ""
				if (($File.Name -like "BlitzIndex_0*") -or ($File.Name -like "BlitzIndex_4*")) {
					$PageName = "Index Diagnostics"
					if ($File.Name -like "BlitzIndex_4*") {
						$PageName = "Extended $PageName"
					}
					$Description = "Index-related diagnosis outlining high-value missing indexes,<br> duplicate or almost duplicate indexes, indexes with more writes than reads, etc."
					$RLim = "<td>10k</td>"
					$Plans="<td class=`"tooltip`" title=`"Only for SQL Server 2019 and above`">$HTMLChk*</td>"
				}
				elseif ($File.Name -like "BlitzIndex_1*") {
					$PageName = "Index Summary"
					$Description = "Summary of database, tables and index sizes and counts."
				}
				elseif ($File.Name -like "BlitzIndex_2*") {
					$PageName = "Index Usage"
					$Description = "Index details and usage information.<br>If your browser struggles to load the page,"
					$Description += "<br>you can load it into SQL Server using <a href='https://github.com/VladDBA/PSBlitzHTMLParser/blob/main/PSBlitzIndexUsage_HTML2SQL.sql' target='_blank'>this script</a>"
				}
			}
			elseif ($File.Name -like "BlitzCache*") {
				$SortOrder = $File.Name.Replace('BlitzCache_', '')
				$SortOrder = $SortOrder.Replace('.html', '')
				$PageName = "Top $CacheTop Queries - $SortOrder"
				$Plans="<td>$HTMLChk</td>"
				if ($SortOrder -eq "Mem_Recent_Comp") {
					$PageName = "Top $CacheTop Queries - Memory <br>Top 50 Queries - Recently Compiled"
					$QuerySource += "Similar to sp_BlitzCache @SortOrder = 'memory grant', @Top = $CacheTop/'recent compilations' , @Top = 50"
					if (!([string]::IsNullOrEmpty($CheckDB))) {
						$QuerySource += ", @DatabaseName = '$CheckDB'; "
					}
					else {
						$QuerySource += "; "
					}
					$Description = "Top $CacheTop queries found in the plan cache, sorted by memory grant size,<br>and the top 50 most recently compiled queries."
				}
				elseif ($SortOrder -eq "Dupl_Single_Use") {
					$PageName = "Top $CacheTop Queries - Duplicates &amp; Single Use"
					$QuerySource += "Similar to sp_BlitzCache @Top = $CacheTop, @SortOrder = 'Duplicate'/'Query Hash'"
					if (!([string]::IsNullOrEmpty($CheckDB))) {
						$QuerySource += ", @DatabaseName = '$CheckDB'; "
					}
					else {
						$QuerySource += "; "
					}
					$Description = "Top $CacheTop queries found in the plan cache, sorted by number of cached plans and query hash."
					$Description += "<br>Helps finding queries that have multiple plans and potential parameterization problems."
					
				}
				else {
					$QuerySource += "Similar to sp_BlitzCache , @Top = $CacheTop, @SortOrder = '$SortOrder'/'Avg $SortOrder'"
					if (!([string]::IsNullOrEmpty($CheckDB))) {
						$QuerySource += ", @DatabaseName = '$CheckDB'; "
					}
					else {
						$QuerySource += "; "
					}
					$Description = "Top $CacheTop queries found in the plan cache, sorted by Total $SortOrder and "
					if($SortOrder -eq "Executions"){
						$Description += "$SortOrder per Minute."
					} else {
						$Description += "Average $SortOrder."
					}
					
				}
			}
			elseif ($File.Name -like "BlitzQueryStore*") {
				$SortOrder = $File.Name.Replace('BlitzQueryStore_', '')
				$SortOrder = $SortOrder.Replace('.html', '')
				$PageName = "Query Store Info - $SortOrder"
				$Plans="<td>$HTMLChk</td>"
				#$AdditionalInfo = "Outputs execution plans as .sqlplan files."
				$Description = "Top 20 queries captured by the Query Store in the past 7 days"
				if ($DBSwitched -eq "Y") {
					$Description += " for $DBName"
				}
				 $Description += ",<br>sorted by $SortOrder."
				$QuerySource += "Similar to sp_QuickieStore @top = 20, @sort_order='$SortOrder'"
				if ($IsAzureSQLDB) {
					$QuerySource += ";"
				}
				elseif ($DBSwitched -eq "Y") {
					$QuerySource += ", @database_name = '$DBName';"
				}
				else {
					$QuerySource += ", @database_name = '$CheckDB';"
				}
			}
			elseif ($File.Name -like "BlitzFirst3*") {
				$QuerySource += "Similar to sp_BlitzFirst @ExpertMode = 1, @Seconds = 30; "
				$Description = "What's happening on the instance during a 30 seconds time-frame."
				$PageName = "Happening Now"
			}
			elseif ($File.Name -like "BlitzFirst_*") {
				$QuerySource += "Similar to sp_BlitzFirst @SinceStartup = 1;"
				if ($File.Name -like "BlitzFirst_Perfmon*") {
					$PageName = "Perfmon Stats"
					$Description = "Perfmon stats since last instance restart."
				}
				elseif ($File.Name -like "BlitzFirst_Storage*") {
					$PageName = "Storage Stats"
					$Description = "Database file usage and throughput since the last instance restart."
				}
				elseif ($File.Name -like "BlitzFirst_Waits*") {
					$PageName = "Wait Stats"
					$Description = "Instance-wide wait stats since last instance restart."
				}
			}
			elseif ($File.Name -like "BlitzWho*") {
				$QuerySource += "Similar to sp_BlitzWho @ExpertMode = 1"
				if (!([string]::IsNullOrEmpty($CheckDB))) {
					$QuerySource += ", @DatabaseName = '$CheckDB'; "
				}
				else {
					$QuerySource += "; "
				}
				if ($File.Name -like "BlitzWho_Agg*") {
					$Plans="<td>$HTMLChk</td>"
					$Description = "Aggregatd session activity sorted by duration descending."
					$PageName = "Session Activity - Aggregated"
					#$AdditionalInfo = "Outputs execution plans as .sqlplan files."
				}
				else {
					$PageName = "Session Activity - Raw"
					$Description = "All session activity data collected while PSBlitz was running."
				}
			}
			elseif ($File.Name -like "StatsInfo*") {
				$PageName = "Statistics Information"
				$QuerySource += "sys.stats, sys.dm_db_stats_properties, dm_db_incremental_stats_properties"
				$RLim = "<td>10k</td>"
				$Description = "Statistics information"
				if ($DBSwitched -eq "Y") {
					$Description += " for $DBName"
				}
				$Description += ".<br>Tables with at lest 10k records ordered by modified% descending." 
			}
			elseif ($File.Name -like "IndexFragInfo*") {
				$QuerySource += "dm_db_index_physical_stats"
				$PageName = "Index Fragmentation"
				$RLim = "<td>20k</td>"
				$Description = "Index fragmentation information"
				if ($DBSwitched -eq "Y") {
					$Description += " for $DBName"
				}
				$Description += ".<br>Tables/partitions containing at least 52k pages (~400MB),<br>ordered by avg fragmentation% & size descending."
			}
			elseif ($File.Name -like "BlitzLock*") {
				$PageName = "Deadlock Information"
				$Plans="<td>$HTMLChk</td>"
				$DLGraphs="<td>$HTMLChk</td>"
				$QuerySource += "Similar to sp_BlitzLock @StartDate = DATEADD(DAY, -15, GETDATE()), @EndDate = GETDATE(); "
				$Description = "Information about the deadlocks recorded in the default extended events session."
				#$AdditionalInfo = "Outputs deadlock graphs as .xdl files and execution plans as .sqlplan files."
			}
			elseif ($File.Name -like "ExecutionLog*") {
				$QuerySource = ""
				$PageName = "Execution Log"
				$Description = "Log for the current run of PSBlitz.<br>Contains step status and potential error messages."
				#$AdditionalInfo = "Contains step status and any error messages that might have been thrown"
			}
			elseif ($File.Name -like "DatabaseInfo*") {
				$PageName = "Database Information"
				$QuerySource += "sys.databases, sys.master_files, sys.database_files, sys.dm_db_log_info"
				if (($MajorVers -ge 13) -and (!([string]::IsNullOrEmpty($CheckDB)))) {
					$QuerySource += ", sys.database_scoped_configurations"
				}
				$Description = "Database and database files information for "
				if (!([string]::IsNullOrEmpty($CheckDB))) {
					$Description += "$CheckDB and system databases."
				}
				else {
					$Description += "all databases on the instance."
				}
			
				$AdditionalInfo = ""
			}
			elseif ($File.Name -like "AzureSQLDBInfo*") {
				$PageName = "Azure SQL DB Info"
				$QuerySource += "sys.dm_user_db_resource_governance, sys.database_files, sys.dm_db_resource_stats, sys.dm_db_wait_stats, sys.databases, database_scoped_configurations, sys.dm_db_objects_impacted_on_version_change"
				$Description = "Azure SQL DB resources, resource and database usage, and database configuration for $ASDBName"
			
				$AdditionalInfo = ""
			}
			
			elseif ($File.Name -like "DangerousSETOpt*") {
				$PageName = "Objects with dangerous SET options"
				$Description = "A list of database objects created with dangerous SET options"
				$QuerySource += "sys.sql_modules, sys.objects"
			}
			$IndexContent += "<tr><td><a href=`"$RelativePath`" target='_blank'>$PageName</a></td><td class=`"tooltip`" title=`"$QuerySource`">$Description</td>$Plans $DLGraphs $RLim</tr>"
		}

		# Close the HTML tags.
		$IndexContent += @"
    </table>
				<br>
				 $Footer 
				</body>
				</html>
"@
		if (!([string]::IsNullOrEmpty($CheckDB))) {
			$IndexFileName = "PSBlitzOutput_$InstName_$CheckDB.html"
		}
		else {
			$IndexFileName = "PSBlitzOutput_$InstName.html"
		}
		#Save index page
		Save-HtmlFile $IndexContent $IndexFileName $OutDir $DebugInfo
		Invoke-ClearVariables IndexContent

		#copy js resources
		foreach ($htmlResource in $HtmlResources) {
			$htmlResource = Join-Path -Path $ResourcesPath -ChildPath $htmlResource
			Copy-Item -Path "$htmlResource" -Destination "$HTMLOutDir"
		}
	}
	Write-Host $("-" * 80)
	Write-Host "Execution completed in: " -NoNewLine
	Write-Host $ExecTime -fore green
	if ($OutDir.Length -gt 40) {
		Write-Host "Generated files have been saved in: "
		Write-Host " $OutDir"
	}
	else {
		Write-Host "Generated files have been saved in: " -NoNewLine
		Write-Host "$OutDir"
	}
	
	if ($ZipOutput -eq "Y") {
		$ZipFilePath = Join-Path -Path $OutputDir -ChildPath $ZipFile
		Compress-Archive -Path "$OutDir" -DestinationPath "$ZipFilePath"
		
		if ($ZipFile.Length -gt 30) {
			Write-Host "The following zip archive has also been created: "
			Write-Host " $ZipFile"
		}
		else {
			Write-Host "The following zip archive has also been created: " -NoNewLine
			Write-Host " $ZipFile"
		}
	}
	Write-Host " "
	Write-Host $("-" * 80)

	If ($DebugInfo) {
		Write-Host "  If you want to report an issue, please use GitHub and read this first:" -Fore Yellow
		Write-Host "      >>>>>>>  https://github.com/VladDBA/PSBlitz/issues/216 <<<<<<<" -Fore Yellow
	}

	if ($InteractiveMode -eq 1) {
		Read-Host -Prompt "Done. Press Enter to close this window."
	}
	$SqlConnection.Close()
	$SqlConnection.Dispose()
	Remove-Variable -Name SqlConnection
	if ((!([string]::IsNullOrEmpty($SQLLogin))) -and (!([string]::IsNullOrEmpty($BSTR))) ) {
		#remove plain text password from memory
		[System.Runtime.InteropServices.Marshal]::ZeroFreeBSTR($BSTR)
	}
}
## Experimental fix for https://github.com/VladDBA/PSBlitz/issues/161
Remove-Variable * -ErrorAction SilentlyContinue
$error.Clear();