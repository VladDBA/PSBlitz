<# 
.SYNOPSIS
 Outputs SQL Server health and performance diagnostics data to either Excel or HTML, 
 and saves execution plans and deadlock graphs as .sqlplan and .xdl files.

.DESCRIPTION
 Outputs the following to an Excel spreadsheet or to an HTML report:

    Instance information
    Wait stats - from sp_BlitzFirst
	Currently opened transactions (if any)
    Currently running queries - from sp_BlitzWho
    Instance health-related findings - from sp_Blitz
    tempdb size and usage information per object and session
    Index-related issues and recommendations - from sp_BlitzIndex
    Top 10 most resource intensive queries - from sp_BlitzCache
    Deadlock related information from the past 15 days - from sp_BlitzLock
	Information about all databases and their files or for a single database in 
	case of a database-specific check
	Query Store information in the case of a database-specific check on an eligible database - from 
	sp_BlitzQueryStore
    Statistics details for a given database - in the case of database-specific check or if a database 
	accounts for at least 2/3 of the sp_BlitzCache data
    Index Fragmentation information for a given database - in the case of database-specific check or if 
	a database accounts for at least 2/3 of the sp_BlitzCache data

 Note: If the execution of PSBlitz took longer than 15 minutes up until the call to sp_BlitzLock, the timeframe for 
 sp_BlitzLock will be narrowed down to the last 7 days in order to keep execution time within a reasonable amount.

 Exports the following files:

    Execution plans (as .sqlplan files) - from the same dataset generated by sp_BlitzCache
    Execution plans (as .sqlplan files) - from the sample execution plans provided by sp_BlitzIndex @Mode = 0 
	and sp_BlitzIndex @Mode = 4 for missing index suggestions (only on SQL Server 2019)
    Execution plans (as .sqlplan files) of currently running sessions - from the same dataset generated by sp_BlitzWho
    Deadlock graphs (as .xdl files) - from the same dataset generated by sp_BlitzLock
	Execution plans (as .sqlplan files) - from sp_BlitzLock if any of the execution plans involved in deadlocks are still
	in the plan cache at the time of the check
	Execution plans (as .sqlplan files) - from sp_BlitzQueryStore in the case of a database-specific check 
	on an eligible database

 PSBlitz.ps1 uses slightly modified, non-stored procedure versions, of the following components from Brent Ozar's 
 SQL Server First Responder Kit:

    sp_Blitz
    sp_BlitzCache
    sp_BlitzFirst
    sp_BlitzIndex
    sp_BlitzLock
    sp_BlitzWho
	sp_BlitzQueryStore
 
 Aside from the above scripts, PSBlitz also runs the following scripts to return sp_BlitzWho data, instance and resource 
 information, index fragmentation and stats info, database and database files info, as well as TempDB usage:

    GetDbInfo.sql
    GetBlitzWhoData.sql
    GetInstanceInfo.sql
	GetAzureSQLDBInfo.sql
    GetTempDBUsageInfo.sql
	GetStatsInfoForWholeDB.sql
	GetIndexInfoForWholeDB.sql

 Prerequisites 
    
    If you want the report to be in Excel format, then the MS Office suite needs to be installed on the machine where 
	you're executing PSBlitz, otherwise use the HTML format.
	PSBlitz will auto-default to HTML output on when ran on a host that does not have the MS Office suite installed.
	Sufficient permissions to query DMVs, server state, and get database objects' definitions.

	You don't need to have any of the sp_Blitz stored procedures present on the instance that you're executing PSBlitz.ps1 for, 
	all the scripts are contained in the PSBlitz\Resources directory in non-stored procedure format.

 Eecution

    You can run PSBlitz.ps1 by simply right-clicking on the script and then clicking on "Run With PowerShell" which will execute 
    the script in interactive mode, prompting you for the required input.

    Otherwise you can navigate to the directory where the script is in PowerShell and execute it by providing parameters 
	and appropriate values.

 License
 MIT License
 Copyright for sp_Blitz, sp_BlitzCache, sp_BlitzFirst, sp_BlitzIndex, 
 sp_BlitzLock, and sp_BlitzWho is held by Brent Ozar Unlimited under MIT licence:
 SQL Server First Responder Kit - https://github.com/BrentOzarULTD/SQL-Server-First-Responder-Kit
 Copyright for PSBlitz.ps1, GetStatsInfoForWholeDB.sql, GetOpenTransactions.sql, 
 GetIndexInfoForWholeDB.sql, GetInstanceInfo.sql, and GetTempDBUsageInfo.sql 
 is held by Vlad Drumea, 2024 as described below.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.

.PARAMETER ServerName
 Accepts either HostName\InstanceID (for named instances), HostName,Port when using a port number instead of an instance ID, 
 or just HostName for default instances. If you provide either ? or Help as a value for -ServerName, 
 the script will return a brief help menu.

.PARAMETER SQLLogin
 The name of the SQL login used to run the script. If not provided, the script will use integrated security.

.PARAMETER SQLPass
 The password for the SQL login provided via the -SQLLogin parameter, omit if -SQLLogin was not used.

.PARAMETER IsIndepth
 Providing Y as a value will tell PSBlitz.ps1 to run a more in-depth check against the instance/database. 
 Omit for default check.

.PARAMETER CheckDB
 Used to provide the name of a specific database against which sp_BlitzIndex, sp_BlitzCache, 
 and sp_BlitzLock will be ran. Omit to run against the whole instance.

.PARAMETER CacheTop
 Used to specify if more/less than the default top 10 queries should be returned for the 
 sp_BlitzCache step. Only works for HTML output (-ToHTM Y).

.PARAMETER OutputDir
 Used to provide a path where the output directory should be saved to. Defaults to PSBlitz.ps1's directory 
 if not specified or a non-existent path is provided.

.PARAMETER ToHTML
 Providing Y as a value will tell PSBlitz.ps1 to output the report as HTML instead of an Excel file. 
 This is perfect when running PSBlitz from a machine that doesn't have Office installed.

.PARAMETER ZipOutput
 Providing Y as a value will tell PSBlitz.ps1 to also create a zip archive of the output files.

.PARAMETER BlitzWhoDelay
 Used to sepcify the number of seconds between each sp_BlitzWho execution. Defaults to 10 if not specified.

.PARAMETER ConnTimeout
 Can be used to increased the timeout limit in seconds for connecting to SQL Server. Defaults to 15 seconds if not specified.

.PARAMETER MaxTimeout
 Can be used to set a higher timeout for sp_BlitzIndex and Stats and Index info retrieval. Defaults to 1000 (16.6 minutes)

.PARAMETER DebugInfo
 Switch used to get more information for debugging and troubleshooting purposes.

.NOTES
 Author: Vlad Drumea (VladDBA)
 Website: https://vladdba.com/

 Copyright: (c) 2024 by Vlad Drumea, licensed under MIT
 License: MIT https://opensource.org/licenses/MIT

.LINK
 https://github.com/VladDBA/PSBlitz

.EXAMPLE
 PS>.\PSBlitz.ps1 ?
 PS>.\PSBlitz.ps1 Help
 Print the help menu

.EXAMPLE
 PS>.\PSBlitz.ps1 Server01\SQL01
 Run it against the whole instance (named instance SQL01), with default checks via integrated security

.EXAMPLE 
 PS>.\PSBlitz.ps1 Server01,1433
 Run it against the whole instance listening on port 1433 on host Server01, with default checks via integrated security

.EXAMPLE
 PS>.\PSBlitz.ps1 Server01\SQL01 -IsIndepth Y
 Run it against the whole instance, with in-depth checks via integrated security

.EXAMPLE
 PS>.\PSBlitz.ps1 Server01\SQL01 -IsIndepth Y -CheckDB YourDatabase
 Run it with in-depth checks, limit sp_BlitzIndex, sp_BlitzCache, and sp_BlitzLock to YourDatabase only, via integrated security

.EXAMPLE
 PS>.\PSBlitz.ps1 Server01\SQL01 -SQLLogin DBA1 -SQLPass SuperSecurePassword
 Run it against the whole instance, with default checks via SQL login and password

.EXAMPLE
 PS>.\PSBlitz.ps1 yourserver.database.windows.net,1433:YourDatabase -SQLLogin DBA1 -SQLPass SuperSecurePassword
 Run it against the YourDatabase database hosted in Azure SQL DB at myserver.database.windows.net port 1433 via SQL login and password

.EXAMPLE
  PS>.\PSBlitz.ps1 Server02 -SQLLogin DBA1 -SQLPass SuperSecurePassword -IsIndepth Y -CheckDB YourDatabase
  Run it against a default instance residing on Server02, with in-depth checks via SQL login and password, 
 while limmiting sp_BlitzIndex, sp_BlitzCache, and sp_BlitzLock to YourDatabase only

.EXAMPLE
 PS>.\PSBlitz.ps1 Server02 -SQLLogin DBA1 -SQLPass SuperSecurePassword -IsIndepth Y -CheckDB YourDatabase -MaxTimeout 1200 -BlitzWhoDelay 20 -DebugInfo -OutputDir C:\Temp
 Run the same command as above, but increase execution timeout for sp_BlitzIndex, stats and index info retrieval, 
 while also increasing delay between sp_BlitzWHo executions as well as getting more verbose console output 
 and saving the output directory to C:\temp

.EXAMPLE
 PS>.\PSBlitz.ps1 Server01\SQL01 -ToHTML Y -ZipOutput Y
 Run PSBlitz but output the report as HTML instead of XLSX while also creating a zip archive of the output files.

.EXAMPLE
 PS>.\PSBlitz.ps1 yourserver.database.windows.net,1433:YourDatabase -SQLLogin DBA1 -SQLPass SuperSecurePassword
 Run it against the YourDatabase database hosted in Azure SQL DB at yourserver.database.windows.net port 1433 via SQL login and password

.EXAMPLE
 PS>.\PSBlitz.ps1 yourserver.database.windows.net -SQLLogin DBA1 -SQLPass SuperSecurePassword
 Run it against the Azure SQL Managed Instance yourserver.database.windows.net

.EXAMPLE
 PS>.\PSBlitz.ps1 yourserver.database.windows.net -SQLLogin DBA1 -SQLPass SuperSecurePassword -IsIndepth Y -CheckDB YourDatabase
 Run it against the Azure SQL Managed Instance yourserver.database.windows.net with an in-depth check while limiting index, stats, plan cache, and database info to YourDatabase

#>

###Input Params
##Params for running from command line
[cmdletbinding()]
param(
	[Parameter(Position = 0, Mandatory = $False)]
	[string[]]$ServerName,
	[Parameter(Mandatory = $False)]
	[string]$SQLLogin,
	[Parameter(Mandatory = $False)]
	[string]$SQLPass,
	[Parameter(Mandatory = $False)]
	[string]$IsIndepth,
	[Parameter(Mandatory = $False)]
	[string]$CheckDB,
	[Parameter(Mandatory = $False)]
	[string]$Help,
	[Parameter(Mandatory = $False)]
	[int]$BlitzWhoDelay = 10,
	[Parameter(Mandatory = $False)]
	[switch]$DebugInfo,
	[Parameter(Mandatory = $False)]
	[int]$MaxTimeout = 1000,
	[Parameter(Mandatory = $False)]
	[int]$ConnTimeout = 15,
	[Parameter(Mandatory = $False)]
	[string]$OutputDir,
	[Parameter(Mandatory = $False)]
	[string]$ToHTML = "N",
	[Parameter(Mandatory = $False)]
	[string]$ZipOutput = "N",
	[Parameter(Mandatory = $False)]
	[int]$CacheTop = 10
)

###Internal params
#Version
$Vers = "4.1.0"
$VersDate = "2024-05-27"
$TwoMonthsFromRelease = [datetime]::ParseExact("$VersDate", 'yyyy-MM-dd', $null).AddMonths(2)
$NowDate = Get-Date
#Get script path
$ScriptPath = split-path -parent $MyInvocation.MyCommand.Definition
#Set resources path
$ResourcesPath = $ScriptPath + "\Resources"
#Set name of the input Excel file
$OrigExcelFName = "PSBlitzOutput.xlsx"
$ResourceList = @("PSBlitzOutput.xlsx", "spBlitz_NonSPLatest.sql",
	"spBlitzCache_NonSPLatest.sql", "spBlitzFirst_NonSPLatest.sql",
	"spBlitzIndex_NonSPLatest.sql", "spBlitzLock_NonSPLatest.sql",
	"spBlitzWho_NonSPLatest.sql",
	"GetBlitzWhoData.sql", "GetInstanceInfo.sql",
	"GetTempDBUsageInfo.sql", "GetOpenTransactions.sql",
	"GetStatsInfoForWholeDB.sql", "GetIndexInfoForWholeDB.sql",
	"GetDbInfo.sql", "GetAzureSQLDBInfo.sql",
	"spBlitzQueryStore_NonSPLatest.sql")
#Set path+name of the input Excel file
$OrigExcelF = $ResourcesPath + "\" + $OrigExcelFName
#Set default start row for Excel output
$DefaultStartRow = 2
#BlitzWho initial pass number
$BlitzWhoPass = 1

if ($DebugInfo) {
	#Success
	$GreenCheck = @{
		Object          = [Char]8730
		ForegroundColor = 'Green'
		NoNewLine       = $true
	}
	#Failure
	$RedX = @{
		Object          = 'x (Failed)'
		ForegroundColor = 'Red'
		NoNewLine       = $true
	}
	#Command Timeout
	$RedXTimeout = @{
		Object          = 'x (Command timeout)'
		ForegroundColor = 'Red'
		NoNewLine       = $true
	}
	#Connection Timeout
	$RedXConnTimeout = @{
		Object          = 'x (Connection timeout)'
		ForegroundColor = 'Red'
		NoNewLine       = $true
	}
}
else {
	#Success
	$GreenCheck = @{
		Object          = [Char]8730
		ForegroundColor = 'Green'
		NoNewLine       = $false
	}
	#Failure
	$RedX = @{
		Object          = 'x (Failed)'
		ForegroundColor = 'Red'
		NoNewLine       = $false
	}
	#Command Timeout
	$RedXTimeout = @{
		Object          = 'x (Command timeout)'
		ForegroundColor = 'Red'
		NoNewLine       = $false
	}
	#Connection Timeout
	$RedXConnTimeout = @{
		Object          = 'x (Connection timeout)'
		ForegroundColor = 'Red'
		NoNewLine       = $false
	}
}

###Functions
#Function to properly output hex strings like Plan Handle and SQL Handle
function Get-HexString {
	param (
		[System.Array]$HexInput
	)
	if ($HexInput -eq [System.DBNull]::Value) {
		$HexString = ""
	}
 else {
		#Formatting value as hex and stripping extra stuff
		$HexSplit = ($HexInput | Format-Hex -ErrorAction Ignore | Select-String "00000")
		<#
	Converting to string, prepending 0x, removing spaces 
	and joining it in one single string
	#>
		$HexString = "0x"
		for ($i = 0; $i -lt $HexSplit.Length; $i++) {
			$HexString = $HexString + "$($HexSplit[$i].ToString().Substring(11,47).replace(' ','') )"
		}
	}
	Write-Output $HexString
}
#Function to return a brief help menu
function Get-PSBlitzHelp {
	Write-Host "`n######	PSBlitz		######`n Version $Vers - $VersDate
	`n Updates/more info: https://github.com/VladDBA/PSBlitz
	`n######	Parameters	######
-ServerName		- accepts either [hostname]\[instance] (for named instances), 
		[hostname,port], or just [hostname] for default instances
-SQLLogin		- the name of the SQL login used to run the script; if not provided, 
		the script will use integrated security
-SQLPass		- the password for the SQL login provided via the -SQLLogin parameter,
		omit if -SQLLogin was not used
-IsIndepth		- Y will run a more in-depth check against the instance/database, omit for a basic check
-CheckDB		- used to provide the name of a specific database to run some of the checks against, 
		omit to run against the whole instance
-OutputDir		- used to provide a path where the output directory should be saved to.
		Defaults to PSBlitz.ps1's directory if not specified or a non-existent path is provided.
-ToHTML			- Y will output the report as HTML instead of an Excel file.
-ZipOutput		- Y to also create a zip archive of the output files.
-BlitzWhoDelay	- used to sepcify the number of seconds between each sp_BlitzWho execution.
		Defaults to 10 if not specified
-CacheTop       - used to specify if more/less than the default top 10 queries should be returned 
        for the sp_BlitzCache step. Only works for HTML output (-ToHTM Y).
-MaxTimeout		- can be used to set a higher timeout for sp_BlitzIndex and Stats and Index info
		retrieval. Defaults to 1000 (16.6 minutes)
-ConnTimeout	- used to increased the timeout limit in seconds for connecting to SQL Server.
		Defaults to 15 seconds if not specified
-DebugInfo		- switch used to get more information for debugging and troubleshooting purposes.
`n######	Execution	######
You can either run the script directly in PowerShell from its directory:
 Run it against the whole instance (named instance SQL01), with default checks via integrated security"
	Write-Host ".\PSBlitz.ps1 Server01\SQL01" -fore green
	Write-Host "`n Same as the above, but have sp_BlitzWho execute every 5 seconds instead of 10"
	Write-Host ".\PSBlitz.ps1 Server01\SQL01 -BlitzWhoDelay 5" -fore green
	Write-Host "`n Run it against an instance listening on port 1433 on Server01"
	Write-Host ".\PSBlitz.ps1 Server01,1433" -fore green
	Write-Host "`n Run it against a default instance installed on Server01"
	Write-Host ".\PSBlitz.ps1 Server01" -fore green
	Write-Host "`n Run it against the whole instance, with in-depth checks via integrated security"
	Write-Host ".\PSBlitz.ps1 Server01\SQL01 -IsIndepth Y" -fore green
	Write-Host "`n Run it against the whole instance and output the report as HTML"
	Write-Host ".\PSBlitz.ps1 Server01\SQL01 -IsIndepth Y -ToHTML Y" -fore green
	Write-Host "`n Run it with in-depth checks, limit sp_BlitzIndex, sp_BlitzCache, and sp_BlitzLock to 
YourDatabase only, via integrated security"
	Write-Host ".\PSBlitz.ps1 Server01\SQL01 -IsIndepth Y -CheckDB YourDatabase" -fore green
	Write-Host "`n Run it against the whole instance, with default checks via SQL login and password"
	Write-Host ".\PSBlitz.ps1 Server01\SQL01 -SQLLogin DBA1 -SQLPass SuperSecurePassword" -fore green
	Write-Host "`n Run it against the YourDatabase database hosted in Azure SQL DB at myserver.database.windows.net port 1433 via SQL login and password"
	Write-Host "\PSBlitz.ps1 yourserver.database.windows.net,1433:YourDatabase -SQLLogin DBA1 -SQLPass SuperSecurePassword"
	Write-Host "`n Or you can run it in interactive mode by just right-clicking on the PSBlitz.ps1 file 
-> 'Run with PowerShell', and the script will prompt you for input.
`n######	What it runs	######
PSBlitz.ps1 uses slightly modified, non-stored procedure versions, of the following components 
from Brent Ozar's FirstResponderKit (https://www.brentozar.com/first-aid/):
   sp_Blitz
   sp_BlitzCache
   sp_BlitzFirst
   sp_BlitzIndex
   sp_BlitzLock
   sp_BlitzWho
   sp_BlitzQueryStore
`n You can find the scripts in the '$ResourcesPath' directory
"
}
#Function to execute sp_BlitzWho
function Invoke-BlitzWho {
	param (
		[string]$BlitzWhoQuery,
		[string]$IsInLoop
	)
	if ($IsInLoop -eq "Y") {
		Write-Host " ->Running sp_BlitzWho - pass $BlitzWhoPass... " -NoNewLine
	}
 else {
		Write-Host " Running sp_BlitzWho - pass $BlitzWhoPass... " -NoNewLine
	}
	$StepStart = Get-Date
	$StepName = "sp_BlitzWho - pass $BlitzWhoPass"
	$BlitzWhoCommand = new-object System.Data.SqlClient.SqlCommand
	$BlitzWhoCommand.CommandText = $BlitzWhoQuery
	$BlitzWhoCommand.CommandTimeout = 120
	$SqlConnection.Open()
	$BlitzWhoCommand.Connection = $SqlConnection
	Try {
		$BlitzWhoCommand.ExecuteNonQuery() | Out-Null -ErrorAction Stop
		$SqlConnection.Close()
		Write-Host @GreenCheck
		$StepEnd = Get-Date
		Add-LogRow $StepName "Success"
	}
 Catch {
		Write-Host @RedX
		$StepEnd = Get-Date
		Add-LogRow $StepName "Failure"
	}
}

#Function to properly format XML contents for deadlock graphs and execution plans
function Format-XML {
	[CmdletBinding()]
	Param ([
		Parameter(ValueFromPipeline = $true, Mandatory = $true)]
		[string]$XMLContent)
	$XMLDoc = New-Object -TypeName System.Xml.XmlDocument
	$XMLDoc.LoadXml($XMLContent)
	$SW = New-Object System.IO.StringWriter
	$Writer = New-Object System.Xml.XmlTextwriter($SW)
	$Writer.Formatting = [System.XML.Formatting]::Indented
	$XMLDoc.WriteContentTo($Writer)
	$SW.ToString()
}

#Function to format exception messages
function Format-ExceptionMsg {
	[string]$ErrorMessage = $error[0] | Select-Object -ExpandProperty Exception | Select-Object -ExpandProperty Message
	try {#Get SQL related error info
	[string]$SQLErrNo = $error[0] | Select-Object -ExpandProperty Exception | Select-Object -ExpandProperty InnerException | Select-Object -ExpandProperty Number
	[string]$SQLErrLev = $error[0] | Select-Object -ExpandProperty Exception | Select-Object -ExpandProperty InnerException | Select-Object -ExpandProperty Class
	[string]$SQLErrState = $error[0] | Select-Object -ExpandProperty Exception | Select-Object -ExpandProperty InnerException | Select-Object -ExpandProperty State
	[string]$SQLErrLineNo = $error[0] | Select-Object -ExpandProperty Exception | Select-Object -ExpandProperty InnerException | Select-Object -ExpandProperty LineNumber
	[string]$SQLErrMsg = $error[0] | Select-Object -ExpandProperty Exception | Select-Object -ExpandProperty InnerException | Select-Object -ExpandProperty Message
	##formatting the error message in SQL Server style if there's an error number
	Write-Output "MSg $SQLErrNo, Level $SQLErrLev, State $SQLErrState, Line $SQLErrLineNo `n $SQLErrMsg"
	}
 catch {
		Write-Output $ErrorMessage
	}
}
#Function to return error messages in the catch block
function Invoke-ErrMsg {
	$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
	$RunTime = [Math]::Round($StepRunTime, 2)
	if ($RunTime -ge $CmdTimeout) {
		Write-Host @RedXTimeout
		if ($DebugInfo) {
			Write-Host " - $RunTime seconds" -Fore Yellow
		}
		$OutErr = Format-ExceptionMsg
		Write-Host "  $OutErr" -fore Red	
	}
 <#elseif ($RunTime -ge $ConnTimeout) {
		Write-Host @RedXConnTimeout
		if ($DebugInfo) {
			Write-Host " - $RunTime seconds" -Fore Yellow
		}
		
	}#>
 else {
		Write-Host @RedX
		if ($DebugInfo) {
			Write-Host " - $RunTime seconds" -Fore Yellow
		}
		$OutErr = Format-ExceptionMsg
		Write-Host "  $OutErr" -fore Red		
	}
}

function Get-ExecTime {
	$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
	[string]$StepDUration = [Math]::Round($StepRunTime, 2).ToString()
	Write-Output $StepDUration
}
function Add-LogRow {
	[CmdletBinding()]
	Param ([
		Parameter(Position = 0, Mandatory = $true)]
		[string]$StepName,
		[Parameter(Position = 1, Mandatory = $true)]
		[string]$StepStatus,
		[Parameter(Position = 2, Mandatory = $false)]
		[string]$MoreInfo = ""
	)
	$ExecTime = Get-ExecTime
	$ErrMsg = Format-ExceptionMsg
	$LogRow = $LogTbl.NewRow()
	$LogRow.Step = $StepName
	$LogRow.StartDate = $StepStart.ToString("yyyy-MM-dd HH:mm:ss")
	$LogRow.EndDate = $StepEnd.ToString("yyyy-MM-dd HH:mm:ss")
	$LogRow.Duration = $ExecTime
	$LogRow.Outcome = $StepStatus
	if ("Failure", "Interrupted" -contains $StepStatus) {
		$LogRow.ErrorMsg = $ErrMsg
	}
 elseif ($StepStatus -eq "Success") {
		$LogRow.ErrorMsg = $MoreInfo
	}
	else {
		$LogRow.ErrorMsg = $MoreInfo
	}
	$LogTbl.Rows.Add($LogRow)
}

###Job preparation
#sp_BlitzWho
$InitScriptBlock = {
	function Invoke-BlitzWho {
		param (
			[string]$BlitzWhoQuery
		)
		$BlitzWhoCommand = new-object System.Data.SqlClient.SqlCommand
		$BlitzWhoCommand.CommandText = $BlitzWhoQuery
		#increased BlitzWho command timeout from 20 to 60 because some people have been getting errors
		#considering setting @ExpertMode = 0 if this keeps up
		$BlitzWhoCommand.CommandTimeout = 60
		$SqlConnection.Open()
		$BlitzWhoCommand.Connection = $SqlConnection
		$BlitzWhoCommand.ExecuteNonQuery() | Out-Null 
		$SqlConnection.Close()
	}
	function Format-ExceptionMsg {
		[string]$ErrorMessage = $error[0] | Select-Object -ExpandProperty Exception | Select-Object -ExpandProperty Message
		#Get SQL related error info
		try {
			[string]$SQLErrNo = $error[0] | Select-Object -ExpandProperty Exception | Select-Object -ExpandProperty InnerException | Select-Object -ExpandProperty Number -ErrorAction Stop
			[string]$SQLErrLev = $error[0] | Select-Object -ExpandProperty Exception | Select-Object -ExpandProperty InnerException | Select-Object -ExpandProperty Class -ErrorAction Stop
			[string]$SQLErrState = $error[0] | Select-Object -ExpandProperty Exception | Select-Object -ExpandProperty InnerException | Select-Object -ExpandProperty State -ErrorAction Stop
			[string]$SQLErrLineNo = $error[0] | Select-Object -ExpandProperty Exception | Select-Object -ExpandProperty InnerException | Select-Object -ExpandProperty LineNumber -ErrorAction Stop
			[string]$SQLErrMsg = $error[0] | Select-Object -ExpandProperty Exception | Select-Object -ExpandProperty InnerException | Select-Object -ExpandProperty Message -ErrorAction Stop
			Write-Output "MSg $SQLErrNo, Level $SQLErrLev, State $SQLErrState, Line $SQLErrLineNo `n $SQLErrMsg" -ErrorAction Stop
		}
		catch {
			Write-Output $ErrorMessage
		}
	}
	function Invoke-FlagTableCheck {
		param (
			[string]$FlagTblDt
		)
		$CheckFlagTblQuery = new-object System.Data.SqlClient.SqlCommand
		$FlagTblQuery = "DECLARE @FlagTable NVARCHAR(300); `n SELECT @FlagTable = CASE "
		$FlagTblQuery += "WHEN CAST(SERVERPROPERTY('Edition') AS NVARCHAR(128)) = N'SQL Azure' "
		$FlagTblQuery += "`nAND SERVERPROPERTY('EngineEdition') IN (5, 6) "
		$FlagTblQuery += "`nTHEN  N'BlitzWhoOutFlag_$FlagTblDt' ELSE "
		$FlagTblQuery += "`nN'tempdb.dbo.BlitzWhoOutFlag_$FlagTblDt' END; "
		$FlagTblQuery += "`nSELECT CASE WHEN OBJECT_ID(@FlagTable, N'U') IS NOT NULL "
		$FlagTblQuery += "`nTHEN 'Y' ELSE 'N' END AS [FlagFound];"
		$CheckFlagTblQuery.CommandText = $FlagTblQuery
		$CheckFlagTblQuery.Connection = $SqlConnection
		$CheckFlagTblQuery.CommandTimeout = 30
		$CheckFlagTblAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
		$CheckFlagTblAdapter.SelectCommand = $CheckFlagTblQuery
		$CheckFlagTblSet = new-object System.Data.DataSet
		Try {
			$CheckFlagTblAdapter.Fill($CheckFlagTblSet) | Out-Null -ErrorAction Stop
			$SqlConnection.Close()
			[string]$IsFlagTbl = $CheckFlagTblSet.Tables[0].Rows[0]["FlagFound"]
            
		}
		Catch {
			[string]$IsFlagTbl = "X"
            
		}
		if ($IsFlagTbl -eq "Y") {
			$CleanupCommand = new-object System.Data.SqlClient.SqlCommand
			$Cleanup = "DECLARE @SQL NVARCHAR(400);`nSELECT @SQL = N'DROP TABLE '+ CASE "
			$Cleanup += "`nWHEN CAST(SERVERPROPERTY('Edition') AS NVARCHAR(100)) = N'SQL Azure' "
			$Cleanup += "`nAND SERVERPROPERTY('EngineEdition') IN (5, 6) "
			$Cleanup += "`nTHEN N'[BlitzWhoOutFlag_$FlagTblDt];' "
			$Cleanup += "`nELSE N'[tempdb].[dbo].[BlitzWhoOutFlag_$FlagTblDt];' `nEND; `nEXEC(@SQL);"
			$CleanupCommand.CommandText = $Cleanup
			$CleanupCommand.CommandTimeout = 20
			$SqlConnection.Open()
			$CleanupCommand.Connection = $SqlConnection
			$CleanupCommand.ExecuteNonQuery() | Out-Null 
			$SqlConnection.Close()
		}
		return $IsFlagTbl
	}
}

$MainScriptblock = {
	Param([string]$ConnStringIn , [string]$BlitzWhoIn, [string]$DirDateIn, [int]$BlitzWhoDelayIn)
	$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
	$SqlConnection.ConnectionString = $ConnStringIn
	[int]$SuccessCount = 0
	[int]$FailedCount = 0
	[int]$FlagCheckRetry = 0    
	[string]$IsFlagTbl = "N"
	[string]$FlagErrCheck = "N"
	while (($IsFlagTbl -ne "Y") -and ($FlagCheckRetry -le 3)) {

		Try {
			Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoIn 
			$SuccessCount += 1
		}
		Catch {
			$FailedCount += 1
		}
		[string]$IsFlagTbl = Invoke-FlagTableCheck -FlagTblDt $DirDateIn
		#Reset retry count if failures aren't consecutive
		if (($FlagErrCheck -eq "X") -and ($IsFlagTbl -ne "X")) {
			$FlagCheckRetry = 0
		}
		if ($IsFlagTbl -eq "N") {
			Start-Sleep -Seconds $BlitzWhoDelayIn
		}
		if ($IsFlagTbl -eq "X") {
            
			$FlagCheckRetry += 1
			$FlagErrCheck = $IsFlagTbl
			$IsFlagTbl = "N"
		}
	}
	if ($FailedCount -gt 0) {
		$OutMsg = " ->Successful runs: $SuccessCount"
		#Write-Host " ->Successful runs: $SuccessCount" -NoNewLine
		$OutMsg += "; Failed runs: $FailedCount"
		#Write-Host "; Failed runs: $FailedCount" -NoNewLine
		if ($FlagCheckRetry -gt 0) {
			$OutMsg += "; Retries: $FlagCheckRetry"
			#Write-Host "; Retries: $FlagCheckRetry"
			$OutErr = Format-ExceptionMsg
			$OutMsg += "`n $OutErr"
			Write-Output $OutMsg
		}
		else {
			$OutMsg += ""
			#Write-Host ""
			$OutErr = Format-ExceptionMsg
			$OutMsg += "`n $OutErr"
			Write-Output $OutMsg
			#Write-Host "  $OutErr" -fore Red
		}
		$SqlConnection.Dispose()
	}
	else {
		$OutMsg = " ->Successful runs: $SuccessCount"
		#Write-Host " ->Successful runs: $SuccessCount" -NoNewLine
		if ($FlagCheckRetry -gt 0) {
			$OutMsg += "; Consecutive retries: $FlagCheckRetry"
			#Write-Host "; Consecutive retries: $FlagCheckRetry"
			Write-Output $OutMsg
		}
		else {
			$OutMsg += ""
			#Write-Host ""
			Write-Output $OutMsg
		}
		$SqlConnection.Dispose()
	}
}

###Convert $ServerName from array to string 
[string]$ServerName = $ServerName -join ","

###Return help if requested during execution
if (("Y", "Yes" -Contains $Help) -or ("?", "Help" -Contains $ServerName)) {
	Get-PSBlitzHelp
	Exit
}

###Validate existence of dependencies
#Check resources path
if (!(Test-Path $ResourcesPath )) {
	Write-Host "The Resources directory was not found in $ScriptPath!" -fore red
	Write-Host " Make sure to download the latest release from https://github.com/VladDBA/PSBlitz/releases" -fore yellow
	Write-Host "and properly extract the contents" -fore yellow
	Read-Host -Prompt "Press Enter to close this window."
	Exit
}
#Check individual files
$MissingFiles = @()
foreach ($Rsc in $ResourceList) {
	$FileToTest = $ResourcesPath + "\" + $Rsc
	if (!(Test-Path $FileToTest -PathType Leaf)) {
		$MissingFiles += $Rsc
	}			
}
if ($MissingFiles.Count -gt 0) {
	Write-Host "The following files are missing from"$ResourcesPath":" -fore red
	foreach ($MIAFl in $MissingFiles) {
		Write-Host "  $MIAFl" -fore red
	}
	Write-Host " Make sure to download the latest release from https://github.com/VladDBA/PSBlitz/releases" -fore yellow
	Write-Host "and properly extract the contents" -fore yellow
	Read-Host -Prompt "Press Enter to close this window."
	Exit
}
$IsAzureSQLDB = $false
$IsAzureSQLMI = $false
$IsAzure = $false
###Switch to interactive mode if $ServerName is empty
if ([string]::IsNullOrEmpty($ServerName)) {
	Write-Host "Running in interactive mode"
	$InteractiveMode = 1
	##Instance
	while ([string]::IsNullOrEmpty($ServerName)) {
		$ServerName = Read-Host -Prompt "Server"
	}
	#Make ServerName filename friendly and get host name
	if ($ServerName -like "*`"*") {
		$ServerName = $ServerName -replace "`"", ""
	}
	if ($ServerName -like "*\*") {
		$pos = $ServerName.IndexOf("\")
		$InstName = $ServerName.Substring($pos + 1)
		$HostName = $ServerName.Substring(0, $pos)
	}
	#Azure SQL DB 
	elseif ($ServerName -like "*database.windows.net*") {
		$IsAzure = $true
		#let's strip "tcp: first just in case"
		if ($ServerName -like "tcp:*") {
			$TCPStripped = $true
			$ServerName = $ServerName -replace "tcp:", ""
		}
		#get the database name if it was provided
		if ($ServerName -like "*:*") {
			$pos = $ServerName.IndexOf(":")
			[string]$ASDBName = $ServerName.Substring($pos + 1)
			$ServerName = $ServerName.Substring(0, $pos)
			if (!([string]::IsNullOrEmpty($ASDBName))) {
				$IsAzureSQLDB = $true
			}
		}
		#Get the hostname
		if ($ServerName -like "*,*") {
			$pos = $ServerName.IndexOf(",")
			$HostName = $ServerName.Substring(0, $pos)		
		}
		else {
			$HostName = $ServerName
		}
	
		$InstName = $HostName

		#slap tcp: back on because why not
		if ($TCPStripped) {
			$ServerName = "tcp:$ServerName"
		}
	}
 elseif ($ServerName -like "*,*") {
		$pos = $ServerName.IndexOf(",")
		$HostName = $ServerName.Substring(0, $pos)
		$InstName = $ServerName -replace ",", "-"
		if ($HostName -like "tcp:*") {
			$HostName = $HostName -replace "tcp:", ""
		}
		if ($HostName -like ".") {
			$pos = $HostName.IndexOf(".")
			$HostName = $HostName.Substring(0, $pos)

		}
	}
 else	{
		$InstName = $ServerName
		$HostName = $ServerName
	}
	if ($HostName -like "tcp:*") {
		$HostName = $HostName -replace "tcp:", ""
	}
	if ($HostName -like ".") {
		$pos = $HostName.IndexOf(".")
		$HostName = $HostName.Substring(0, $pos)
	}
	#Return help menu if $ServerName is ? or Help
	if ("?", "Help" -Contains $ServerName) {
		Get-PSBlitzHelp
		Read-Host -Prompt "Press Enter to close this window."
		Exit
	}
	
	##Have sp_BlitzIndex, sp_BlitzCache, sp_BlitzLock executed against a specific database
	if ($IsAzure -eq $false) {
		$CheckDB = Read-Host -Prompt "Name of the database you want to check (leave empty for all)"
	}
	
	##SQL Login
	$SQLLogin = Read-Host -Prompt "SQL login name (leave empty to use integrated security)"
	if (!([string]::IsNullOrEmpty($SQLLogin))) {
		##SQL Login pass
		$SecSQLPass = Read-Host -Prompt "Password" -AsSecureString
	}
	##Indepth check 
	$IsIndepth = Read-Host -Prompt "Perform an in-depth check?[Y/N]"
	##sp_BlitzWho delay
	if (!([int]$BlitzWhoDelay = Read-Host "Seconds of delay between sp_BlizWho executions (empty defaults to 10)")) { 
		$BlitzWhoDelay = 10 
	}
	##Output file type
	if (!([string]$ToHTML = Read-Host -Prompt "Output the report as HTML instead of Excel?(empty defaults to N)[Y/N]")) {
		$ToHTML = "N"
	}
	##Zip output files
	if (!([string]$ZipOutput = Read-Host -Prompt "Create a zip archive of the output files?(empty defaults to N)[Y/N]")) {
		$ZipOutput = "N"
	}
}
else {
	$InteractiveMode = 0
	if ($ServerName -like "*\*") {
		$pos = $ServerName.IndexOf("\")
		$InstName = $ServerName.Substring($pos + 1)
		$HostName = $ServerName.Substring(0, $pos)
	}
 #Azure SQL DB 
 elseif ($ServerName -like "*database.windows.net*") {
		$IsAzure = $true
		#let's strip "tcp: first just in case"
		if ($ServerName -like "tcp:*") {
			$TCPStripped = $true
			$ServerName = $ServerName -replace "tcp:", ""
		}
		#get the database name if it was provided
		if ($ServerName -like "*:*") {
			$pos = $ServerName.IndexOf(":")
			[string]$ASDBName = $ServerName.Substring($pos + 1)
			$ServerName = $ServerName.Substring(0, $pos)
			if (!([string]::IsNullOrEmpty($ASDBName))) {
				$IsAzureSQLDB = $true
			}
		}
		#Get the hostname
		if ($ServerName -like "*,*") {
			$pos = $ServerName.IndexOf(",")
			$HostName = $ServerName.Substring(0, $pos)		
		}
		else {
			$HostName = $ServerName
		}
	
		$InstName = $HostName

		#slap tcp: back on because why not
		if ($TCPStripped) {
			$ServerName = "tcp:$ServerName"
		}
	}
	elseif ($ServerName -like "*,*") {
		$pos = $ServerName.IndexOf(",")
		$HostName = $ServerName.Substring(0, $pos)
		$InstName = $ServerName -replace ",", "-"
	}
	else	{
		$InstName = $ServerName
		$HostName = $ServerName
	}
}

if(($InteractiveMode -eq 0) -and (!([string]::IsNullOrEmpty($SQLLogin))) -and ([string]::IsNullOrEmpty($SQLPass))){
	Write-Host " You've provided a SQL login, but no password." -Fore Yellow
	$SecSQLPass = Read-Host -Prompt "Password" -AsSecureString
	#Convert the secure password to plain text for SqlConnection
	$BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecSQLPass)
	$SQLPass = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
}

#Convert the secure password to plain text for SqlConnection
if (($InteractiveMode -eq 1) -and (!([string]::IsNullOrEmpty($SQLLogin))) ) {
	$BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecSQLPass)
	$SQLPass = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
}

###If release is older than 2 months print an info message
if ($NowDate -ge $TwoMonthsFromRelease) {
	Write-Host "Informational: This release of PSBlitz is two months old" -Fore Yellow
	Write-Host "->You can check for a newer release at https://github.com/VladDBA/PSBlitz/releases"
}

### If Azure and database name was not provided, do a preliminary test for the type of env
if (($IsAzure) -and ([string]::IsNullOrEmpty($ASDBName)) -and ($IsAzureSQLDB -eq $false)) {
	$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
	$AppName = "PSBlitz " + $Vers
	if (!([string]::IsNullOrEmpty($SQLLogin))) {
		$ConnString = "Server=$ServerName;Database=master;User Id=$SQLLogin;Password=$SQLPass;Connection Timeout=$ConnTimeout;Application Name=$AppName"
	}
	else {

		$ConnString = "Server=$ServerName;Database=master;trusted_connection=true;Connection Timeout=$ConnTimeout;Application Name=$AppName"
	}
	$SqlConnection.ConnectionString = $ConnString

	[int]$CmdTimeout = 100
	Write-Host "Detecting type of Azure environment... " -NoNewLine
	$AzCheckQuery = new-object System.Data.SqlClient.SqlCommand
	$Query = "SELECT CAST(SERVERPROPERTY('EngineEdition') AS INT) AS [EngineEdition],"
	$Query += "`nCAST(SERVERPROPERTY('Edition') AS NVARCHAR(128)) AS [Edition];"
	$AzCheckQuery.CommandText = $Query
	$AzCheckQuery.Connection = $SqlConnection
	$AzCheckQuery.CommandTimeout = $CmdTimeout
	$AzCheckAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
	$AzCheckAdapter.SelectCommand = $AzCheckQuery
	$AzCheckSet = new-object System.Data.DataSet
	Try {
		$StepStart = get-date
		$AzCheckAdapter.Fill($AzCheckSet) | Out-Null -ErrorAction Stop
		$SqlConnection.Close()
		$StepEnd = get-date
	}
	Catch {
		$StepEnd = get-date
		Invoke-ErrMsg
		$Help = Read-Host -Prompt "Need help?[Y/N]"
		if ($Help -eq "Y") {
			Get-PSBlitzHelp
			#Don't close the window automatically if in interactive mode
			if ($InteractiveMode -eq 1) {
				Read-Host -Prompt "Press Enter to close this window."
				Exit
			}
		}
		else {
			Exit
		}
	}
	if ($AzCheckSet.Tables[0].Rows.Count -eq 1) {
		$AzCheckTbl = New-Object System.Data.DataTable
		$AzCheckTbl = $AzCheckSet.Tables[0]
		[int]$EngineEdition = $AzCheckTbl.Rows[0]["EngineEdition"]
		[string]$Edition = $AzCheckTbl.Rows[0]["Edition"]
		Write-Host @GreenCheck
		$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
		if ($DebugInfo) {
			Write-Host " Engine Edition - $EngineEdition"  -Fore Yellow
		}
		if ($Edition -eq "SQL Azure") {
			if ($EngineEdition -eq 8) {
				$IsAzureSQLMI = $true
				Write-Host " ->Azure SQL MI"
			}
			elseif ($EngineEdition -eq 5) {
				$IsAzureSQLDB = $true
				Write-Host " ->Azure SQL DB"
			}
		}
		else {
			Write-Host " ->Well this is awquard, use the following info to debug:"
			Write-Host " Edition - $Edition; EngineEdition - $EngineEdition"
		}
	}

}

#If Azure SQL DB make sure database name is provided regardless of mode
if (($IsAzureSQLDB) -and ([string]::IsNullOrEmpty($ASDBName))) {
	Write-Host " The environment has been identified as Azure SQL DB, but a database name was not provide." -Fore yellow
	while ([string]::IsNullOrEmpty($ASDBName)) {
		$ASDBName = Read-Host -Prompt "Name of the Azure SQL DB database (cannot be empty)"
	}
}
elseif (($IsAzureSQLMI) -and ($InteractiveMode -eq 1) -and ([string]::IsNullOrEmpty($CheckDB))) {
	$CheckDB = Read-Host -Prompt "Name of the database you want to check (leave empty for all)"
}

#Set the string to replace for $CheckDB
if (!([string]::IsNullOrEmpty($CheckDB))) {
	$OldCheckDBStr = ";SET @DatabaseName = NULL;"
	$NewCheckDBStr = ";SET @DatabaseName = '" + $CheckDB + "';" 
}

###Define connection
$AppName = "PSBlitz " + $Vers
$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
if (!([string]::IsNullOrEmpty($SQLLogin))) {
	if ($IsAzureSQLDB) {
		$ConnString = "Server=$ServerName;Database=$ASDBName;User Id=$SQLLogin;Password=$SQLPass;Connection Timeout=$ConnTimeout;Application Name=$AppName"
	}
 else {
		$ConnString = "Server=$ServerName;Database=master;User Id=$SQLLogin;Password=$SQLPass;Connection Timeout=$ConnTimeout;Application Name=$AppName"
	}
}
else {
	if ($IsAzureSQLDB) {
		$ConnString = "Server=$ServerName;Database=$ASDBName;trusted_connection=true;Connection Timeout=$ConnTimeout;Application Name=$AppName"
	}
 else {
		$ConnString = "Server=$ServerName;Database=master;trusted_connection=true;Connection Timeout=$ConnTimeout;Application Name=$AppName"
	}
}
$SqlConnection.ConnectionString = $ConnString

###Test connection to instance
[int]$CmdTimeout = 100
Write-Host "Testing connection to $ServerName... " -NoNewLine
$ConnCheckQuery = new-object System.Data.SqlClient.SqlCommand
$Query = "SELECT CAST(SERVERPROPERTY('Edition') AS NVARCHAR(128)) AS [Edition],"
$Query += "`nCAST(ISNULL(SERVERPROPERTY('ProductMajorVersion'),0) AS TINYINT) AS [MajorVersion];"
$ConnCheckQuery.CommandText = $Query
$ConnCheckQuery.Connection = $SqlConnection
$ConnCheckQuery.CommandTimeout = $CmdTimeout
$ConnCheckAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
$ConnCheckAdapter.SelectCommand = $ConnCheckQuery
$ConnCheckSet = new-object System.Data.DataSet
Try {
	$StepStart = get-date
	$ConnCheckAdapter.Fill($ConnCheckSet) | Out-Null -ErrorAction Stop
	$SqlConnection.Close()
	$StepEnd = get-date
}
Catch {
	$StepEnd = get-date
	Invoke-ErrMsg
	$Help = Read-Host -Prompt "Need help?[Y/N]"
	if ($Help -eq "Y") {
		Get-PSBlitzHelp
		#Don't close the window automatically if in interactive mode
		if ($InteractiveMode -eq 1) {
			Read-Host -Prompt "Press Enter to close this window."
			Exit
		}
	}
 else {
		Exit
	}
}
if ($ConnCheckSet.Tables[0].Rows.Count -eq 1) {
	$ConnChec = New-Object System.Data.DataTable
	$ConnChec = $ConnCheckSet.Tables[0]
	[int]$MajorVers = $ConnChec.Rows[0]["MajorVersion"]
	Write-Host @GreenCheck
	$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
	$ConnTest = [Math]::Round($StepRunTime, 3)
	if ($DebugInfo) {
		Write-Host " - $ConnTest seconds"
		Write-Host " Product Major Version - $MajorVers"  -Fore Yellow
	}
 else {
		if ($ConnTest -ge 2) {
			Write-Host "->Estimated response latency: $ConnTest seconds" -Fore Red
		}
		elseif ($ConnTest -ge 0.5) {
			Write-Host "->Estimated response latency: $ConnTest seconds" -Fore Yellow
		}
		elseif ($ConnTest -ge 0.2) {
			Write-Host "->Estimated response latency: $ConnTest seconds"
		}
		elseif ($ConnTest -lt 0.2) {
			Write-Host "->Estimated response latency: $ConnTest seconds" -Fore Green
		}

	}
}
###Test existence of value provided for $CheckDB
if (!([string]::IsNullOrEmpty($CheckDB))) {
	Write-Host "Checking existence of database $CheckDB..."
	$CheckDBQuery = new-object System.Data.SqlClient.SqlCommand
	$DBQuery = "SELECT [name] from sys.databases WHERE [name] = @DBName AND [state] = 0 AND [user_access_desc] = 'MULTI_USER';"
	$CheckDBQuery.CommandText = $DBQuery
	$CheckDBQuery.Parameters.Add("@DBName", [Data.SQLDBType]::NVarChar, 256) | Out-Null
	$CheckDBQuery.Parameters["@DBName"].Value = $CheckDB
	$CheckDBQuery.Connection = $SqlConnection
	$CheckDBQuery.CommandTimeout = 100
	$CheckDBAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
	$CheckDBAdapter.SelectCommand = $CheckDBQuery
	$CheckDBSet = new-object System.Data.DataSet
	$CheckDBAdapter.Fill($CheckDBSet) | Out-Null
	$SqlConnection.Close()
	Try {
		if ($CheckDBSet.Tables[0].Rows[0]["name"] -eq $CheckDB) {
			Write-Host "->Database $CheckDB - " -NoNewLine -ErrorAction Stop
			Write-Host "is online" -fore green -ErrorAction Stop
		}
	}
 Catch {
		Write-Host "->Database $CheckDB either does not exist or is offline" -fore red
		$InstanceWide = Read-Host -Prompt "Switch to instance-wide plan cache, index, and deadlock check?[Y/N]"
		if ($InstanceWide -eq "Y") {
			$CheckDB = ""
		}
		else {
			$Help = Read-Host -Prompt "Need help?[Y/N]"
			if ($Help -eq "Y") {
				Get-PSBlitzHelp
				#Don't close the window automatically if in interactive mode
				if ($InteractiveMode -eq 1) {
					Read-Host -Prompt "Press Enter to close this window."
					Exit
				}
			}
			else {
				Exit
			}
		}
	}
	Remove-Variable -Name CheckDBSet

}

###Create directories
#Turn current date time into string for output directory name
$sdate = get-date
$DirDate = $sdate.ToString("yyyyMMddHHmm")
#Set output directory
if ((!([string]::IsNullOrEmpty($OutputDir))) -and (Test-Path $OutputDir)) {
	if ($OutputDir -notlike "*\") {
		$OutputDir = $OutputDir + "\"
	}
	$OutDir = $OutputDir
	if ($IsAzureSQLDB) {
		$OutDir += "AzureSQLDB_$ASDBName" + "_"
	}
	elseif ($IsAzureSQLMI) {
		$OutDir += $InstName.Replace('.database.windows.net', '') + "_"
	}
	elseif ($HostName -ne $InstName) {
		$OutDir += $HostName + "_" + $InstName + "_"
	}
	else {
		$OutDir += $InstName + "_"
	}
	if (!([string]::IsNullOrEmpty($CheckDB))) {
		$OutDir += $CheckDB + "_"
	}
	$OutDir += $DirDate
}
else {
	$OutDir = $scriptPath + "\"
	if ($IsAzureSQLDB) {
		$OutDir += "AzureSQLDB_$ASDBName" + "_"
	}
	elseif ($IsAzureSQLMI) {
		$OutDir += $InstName.Replace('.database.windows.net', '') + "_"
	}
 elseif ($HostName -ne $InstName) {
		$OutDir += $HostName + "_" + $InstName + "_"
	}
	else {
		$OutDir += $InstName + "_"
	}
	if (!([string]::IsNullOrEmpty($CheckDB))) {
		$OutDir += $CheckDB + "_"
	}
	$OutDir += $DirDate
}
if ($ZipOutput -eq "Y") {
	if ($IsAzureSQLDB) {
		$ZipFile = "AzureSQLDB_$ASDBName" + "_"
	}
	elseif ($IsAzureSQLMI) {
		$OutDir += $InstName.Replace('.database.windows.net', '') + "_"
	}
	elseif ($HostName -ne $InstName) {
		$ZipFile = $HostName + "_" + $InstName + "_" 
	}
	else {
		$ZipFile = $InstName + "_"
	}
	if (!([string]::IsNullOrEmpty($CheckDB))) {
		$ZipFile += $CheckDB + "_" 
	}
	$ZipFile += $DirDate + ".zip"
	if ($DebugInfo) {
		Write-Host " Output directory: $OutDir" -Fore Yellow
	}
}


#Check if output directory exists
if (!(Test-Path $OutDir)) {
	New-Item -ItemType Directory -Force -Path $OutDir | Out-Null
}
#Set plan output directory
$PlanOutDir = $OutDir + "\" + "Plans"
#Check if plan output directory exists
if (!(Test-Path $PlanOutDir)) {
	New-Item -ItemType Directory -Force -Path $PlanOutDir | Out-Null
}
#Set deadlock graph output directory
$XDLOutDir = $OutDir + "\" + "Deadlocks"
#Check if deadlock graph output directory exists
if (!(Test-Path $XDLOutDir)) {
	New-Item -ItemType Directory -Force -Path $XDLOutDir | Out-Null
}

#Initiate Excel app here
if ($ToHTML -ne "Y") {
	###Open Excel
	if ($DebugInfo) {
		$ErrorActionPreference = "Continue"
		Write-Host "Opening excel file" -fore yellow
	}
	else {
		#Do not display the occasional "out of memory" errors
		$ErrorActionPreference = "SilentlyContinue"
	}

	try {
		$ExcelApp = New-Object -comobject Excel.Application	-ErrorAction Stop	
	}
	catch {
		Write-Host "Could not open Excel." -fore Red
		Write-Host "->Switching to HTML output."
		$ToHTML = "Y"
		$ErrorActionPreference = "Continue"
	}
	
}

if (($ToHTML -ne "Y") -and ($CacheTop -ne 10)) {
	Write-Host " Output type is Excel, but -CacheTop was specified with a value <> 10." -Fore Red
	Write-Host " ->These two options aren't compatible."
	Write-Host " ->Switching -CacheTop back to 10"
	$CacheTop = 10
}

if ($ToHTML -eq "Y") {
	#Set HTML files output directory
	$HTMLOutDir = $OutDir + "\" + "HTMLFiles"
	if (!(Test-Path $HTMLOutDir)) {
		New-Item -ItemType Directory -Force -Path $HTMLOutDir | Out-Null
	}
	#HTML elements and styles used in most report pages
	$HTMLPre = @"
	<!DOCTYPE html>
	<html>
	<head>
	<style>
	body 
	{ 
	background-color:#FFFFFF;
	font-family:Tahoma;
	font-size:11pt; 
	}
	table {
        margin-left: auto;
        margin-right: auto;
		border-spacing: 1px;
    }
	th {
		background-color: dodgerblue;
		color: white;
		font-weight: bold;
		padding: 5px;
		text-align: center;
		border: 1px solid black;
		position: sticky; 
		top: 0; 
		z-index: 1;
	}
	td {
		padding: 5px;
		border: 1px solid black;
		vertical-align: top;
	}
	tr:hover{
		background-color: rgba(255, 255, 0, 0.4);
	}
	td:first-child {
		font-weight: bold;
		text-align: left;
	}
	.CacheTable1{
		td:nth-child(3) {
			position: sticky; left: 0;
			background-color: rgba(255, 255, 255, 0.7);
		}
		td:nth-child(CacheTab1High) {
			font-weight: bold;
			background-color: rgba(255, 255, 0, 0.4);
		}
	}
	.CacheTable2{
		td:nth-child(3) {
			position: sticky; left: 0;
			background-color: rgba(255, 255, 255, 0.7);
		}
		td:nth-child(CacheTab2High) {
			font-weight: bold;
			background-color: rgba(255, 255, 0, 0.4);
		}
	}
	.QueryStoreTab{
		td:nth-child(6) {
			position: sticky; left: 0;
			background-color: rgba(255, 255, 255, 0.7);
		}
	}
	.ActiveSessionsTab{
		td:nth-child(5) {
			position: sticky; left: 0;
			background-color: rgba(255, 255, 255, 0.7);
		}
	}
	h1 {
		text-align: center;
	}
	h2 {
		text-align: Left;
	}
	</style>
	
"@
	$URLRegex = '(?i)\b((?:https?://|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:\".,<>?«»“”]))'
}
else {
	###Set output Excel name and destination
	if (!([string]::IsNullOrEmpty($CheckDB))) {
		$OutExcelFName = "Active_$InstName_$CheckDB.xlsx"
	}
	else {
		$OutExcelFName = "Active_$InstName.xlsx"
	}
	$OutExcelF = $OutDir + "\" + $OutExcelFName
	###Copy Excel template to output directory
	<#
	This is a fix for https://github.com/VladDBA/PSBlitz/issues/4
	#>
	Copy-Item $OrigExcelF  -Destination $OutExcelF
}
#Set output table for sp_BlitzWho
#Set replace strings
$OldBlitzWhoOut = "@OutputTableName = 'BlitzWho_..PSBlitzReplace..',"
$NewBlitzWhoOut = "@OutputTableName = 'BlitzWho_$DirDate',"

if ($ToHTML -ne "Y") {
	###Open Excel FIle
	if ($DebugInfo) {
		$ExcelApp.visible = $True
	}
	else {
		$ExcelApp.visible = $False
	}
	$ExcelFile = $ExcelApp.Workbooks.Open("$OutExcelF")
	$ExcelApp.DisplayAlerts = $False
}
###Check instance uptime
$UptimeQuery = new-object System.Data.SqlClient.SqlCommand
$Query = "SELECT CAST(DATEDIFF(HH, [sqlserver_start_time], GETDATE()) / 24.00 AS NUMERIC(23, 2)) AS [uptime_days]	"
$Query = $Query + "`nFROM [sys].[dm_os_sys_info];"
$UptimeQuery.CommandText = $Query
$UptimeQuery.Connection = $SqlConnection
$UptimeQuery.CommandTimeout = 100
$UptimeAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
$UptimeAdapter.SelectCommand = $UptimeQuery
$UptimeSet = new-object System.Data.DataSet
$UptimeAdapter.Fill($UptimeSet) | Out-Null
$SqlConnection.Close()
if ($UptimeSet.Tables[0].Rows[0]["uptime_days"] -lt 7.00) {
	[string]$DaysUp = $UptimeSet.Tables[0].Rows[0]["uptime_days"]
	Write-Host "Warning: Instance uptime is less than 7 days - $DaysUp" -Fore Red
	Write-Host "->Diagnostics data might not be reliable with less than 7 days of uptime." -Fore Red
}

###Create log table
$LogTbl = New-Object System.Data.DataTable
$LogTbl.Columns.Add("Step", [string]) | Out-Null
$LogTbl.Columns.Add("StartDate", [string]) | Out-Null
$LogTbl.Columns.Add("EndDate", [string]) | Out-Null
$LogTbl.Columns.Add("Duration", [string]) | Out-Null
$LogTbl.Columns.Add("Outcome", [string]) | Out-Null
$LogTbl.Columns.Add("ErrorMsg", [string]) | Out-Null

#####################################################################################
#						Check start													#
#####################################################################################
$StepStart = get-date
$StepEnd = Get-Date
$ParametersUsed = "IsIndepth:$IsIndepth; CheckDB:$CheckDB; BlitzWhoDelay:$BlitzWhoDelay; MaxTimeout:$MaxTimeout"
$ParametersUsed += "; ConnTimeout:$ConnTimeout; CacheTop:$CacheTop; ASDBName:$ASDBName"
Add-LogRow "Check start" "Started" $ParametersUsed
try {
	###Set completion flag
	$TryCompleted = "N"

	Write-Host $("-" * 80)
	Write-Host "       Starting" -NoNewLine 
	if ($IsIndepth -eq "Y") {
		Write-Host " in-depth" -NoNewLine
	}
	if (!([string]::IsNullOrEmpty($CheckDB))) {
		Write-Host " database-specific" -NoNewLine
	}
	Write-Host " check for " -NoNewLine 
	if ($IsAzureSQLDB) {
		Write-Host "Azure SQL DB - $ASDBName"
	}
	elseif ($IsAzureSQLMI) {
		Write-Host "Azure SQL MI - $($ServerName.Replace('.database.windows.net',''))" 
	}
	else {
		Write-Host "$ServerName"
	}
	Write-Host $("-" * 80)

	if (($DebugInfo) -and ($MaxTimeout -ne 1000)) {
		Write-Host " ->MaxTimeout has been set to $MaxTimeout"
	}

	###Load sp_BlitzWho in memory
	[string]$Query = [System.IO.File]::ReadAllText("$ResourcesPath\spBlitzWho_NonSPLatest.sql")
	#Replace output table name
	[string]$BlitzWhoRepl = $Query -replace $OldBlitzWhoOut, $NewBlitzWhoOut

	###Execution start time
	$StartDate = get-date
	###Collecting first pass of sp_BlitzWho data
	$JobName = "BlitzWho"
	Write-Host " Starting BlitzWho background process... " -NoNewline
	
	$Job = Start-Job -Name $JobName -InitializationScript $InitScriptBlock -ScriptBlock $MainScriptblock -ArgumentList $ConnString, $BlitzWhoRepl, $DirDate, $BlitzWhoDelay
	$JobStatus = $Job | Select-Object -ExpandProperty State
	if ($JobStatus -ne "Running") {
		Write-Host @RedX
		if ($DebugInfo) {
			Write-Host ""
		}
		$JobError = $Job | Select-Object -ExpandProperty Error
		Add-LogRow "Start sp_BlitzWho background process" $JobStatus $JobError
		Write-Host " ->Switching to foreground execution."
		Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop N
		$BlitzWhoPass += 1
	}
 else {
		Write-Host @GreenCheck
		if ($DebugInfo) {
			Write-Host ""
		}
		Add-LogRow "Start sp_BlitzWho background process" $JobStatus
		Write-Host " ->sp_BlitzWho will collect data every $BlitzWhoDelay seconds."

	}


	#####################################################################################
	#						Instance Info												#
	#####################################################################################
	Write-Host " Retrieving instance information... " -NoNewLine
	$CmdTimeout = 600
	[string]$Query = [System.IO.File]::ReadAllText("$ResourcesPath\GetInstanceInfo.sql")
	$InstanceInfoQuery = new-object System.Data.SqlClient.SqlCommand
	$InstanceInfoQuery.CommandText = $Query
	$InstanceInfoQuery.Connection = $SqlConnection
	$InstanceInfoQuery.CommandTimeout = $CmdTimeout
	$InstanceInfoAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
	$InstanceInfoAdapter.SelectCommand = $InstanceInfoQuery
	$InstanceInfoSet = new-object System.Data.DataSet
	try {
		$StepStart = get-date
		$InstanceInfoAdapter.Fill($InstanceInfoSet) | Out-Null -ErrorAction Stop
		$SqlConnection.Close()
		$StepEnd = get-date
		Write-Host @GreenCheck
		$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
		$RunTime = [Math]::Round($StepRunTime, 2)
		if ($DebugInfo) {
			Write-Host " - $RunTime seconds" -Fore Yellow
		}
		$StepOutcome = "Success"
		Add-LogRow "Instance Info" $StepOutcome
	}
	Catch {
		$StepEnd = get-date
		Invoke-ErrMsg
		$StepOutcome = "Failure"
		Add-LogRow "Instance Info" $StepOutcome
	}
		
	if ($StepOutcome -eq "Success") {
		$InstanceInfoTbl = New-Object System.Data.DataTable
		$InstanceInfoTbl = $InstanceInfoSet.Tables[0]
		$ResourceInfoTbl = New-Object System.Data.DataTable
		$ResourceInfoTbl = $InstanceInfoSet.Tables[1]
		$ConnectionsInfoTbl = New-Object System.Data.DataTable
		$ConnectionsInfoTbl = $InstanceInfoSet.Tables[2]
		$SessOptTbl = New-Object System.Data.DataTable
		$SessOptTbl = $InstanceInfoSet.Tables[3]
		
		if ($ToHTML -eq "Y") {
			if ($DebugInfo) {
				Write-Host " ->Converting instance info to HTML" -fore yellow
			}
			$InstanceInfoTbl.Columns.Add("Estimated Response Latency (Sec)", [decimal]) | Out-Null
			$InstanceInfoTbl.Rows[0]["Estimated Response Latency (Sec)"] = $ConnTest

			$htmlTable1 = $InstanceInfoTbl | Select-Object  @{Name = "Machine Name"; Expression = { $_."machine_name" } },
			@{Name = "Instance Name"; Expression = { $_."instance_name" } }, 
			@{Name = "Version"; Expression = { $_."product_version" } }, 
			@{Name = "Product Level"; Expression = { $_."product_level" } },
			@{Name = "Patch Level"; Expression = { $_."patch_level" } },
			@{Name = "Edition"; Expression = { $_."edition" } }, 
			@{Name = "Is Clustered?"; Expression = { $_."is_clustered" } }, 
			@{Name = "Is AlwaysOnAG?"; Expression = { $_."always_on_enabled" } },
			@{Name = "FILESTREAM Access Level"; Expression = { $_."filestream_access_level" } },
			@{Name = "Tempdb Metadata Memory Optimized"; Expression = { $_."mem_optimized_tempdb_metadata" } },
			@{Name = "Fulltext Instaled"; Expression = { $_."fulltext_installed" } },
			@{Name = "Instance Collation"; Expression = { $_."instance_collation" } },
			@{Name = "Process ID"; Expression = { $_."process_id" } },
			@{Name = "Last Startup"; Expression = { ($_."instance_last_startup").ToString("yyyy-MM-dd HH:mm:ss") } },
			@{Name = "Uptime (days)"; Expression = { $_."uptime_days" } },
			@{Name = "Client Connections"; Expression = { $_."client_connections" } },
			"Estimated Response Latency (Sec)", 
			@{Name = "Server Time"; Expression = {($_."server_time").ToString("yyyy-MM-dd HH:mm:ss")}} | ConvertTo-Html -As Table -Fragment

			if (($DebugInfo) -and ($IsAzureSQLDB -eq $false)) {
				Write-Host " ->Converting resource info to HTML" -fore yellow
			}
			elseif (($DebugInfo) -and ($IsAzureSQLDB)) {
				Write-Host " ->Skipping resource instance resource info for Azure SQL DB" -fore yellow
			} 
			if ($IsAzureSQLDB) {
				$htmlTable2 = '<p style="text-align: center;">Instance resource information is not available for Azure SQL DB.</p>'
			}
			else {
				$htmlTable2 = $ResourceInfoTbl | Select-Object  @{Name = "Logical Cores"; Expression = { $_."logical_cpu_cores" } }, 
				@{Name = "Physical Cores"; Expression = { $_."physical_cpu_cores" } }, 
				@{Name = "Physical memory GB"; Expression = { $_."physical_memory_GB" } }, 
				@{Name = "Max Server Memory GB"; Expression = { $_."max_server_memory_GB" } }, 
				@{Name = "Target Server Memory GB"; Expression = { $_."target_server_memory_GB" } },
				@{Name = "Total Memory Used GB"; Expression = { $_."total_memory_used_GB" } },
				@{Name = "Process physical memory low"; Expression = { $_."proc_physical_memory_low" } },
				@{Name = "Process virtual memory low"; Expression = { $_."proc_virtual_memory_low" } },
				@{Name = "Available Physical Memory GB"; Expression = { $_."available_physical_memory_GB" } },
				@{Name = "OS Memory State"; Expression = { $_."os_memory_state" } },
				"CTP",	"MAXDOP" | ConvertTo-Html -As Table -Fragment
			}

			if ($DebugInfo) {
				Write-Host " ->Converting connections info to HTML" -fore yellow
			}    
			$htmlTable3 = $ConnectionsInfoTbl | Select-Object  "Database", 
			@{Name = "Connections Count"; Expression = { $_."ConnectionsCount" } }, 
			@{Name = "Login Name"; Expression = { $_."LoginName" } }, 
			@{Name = "Client Hostname"; Expression = { $_."ClientHostName" } }, 
			@{Name = "Client IP"; Expression = { $_."ClientIP" } },
			@{Name = "Protocol"; Expression = { $_."ProtocolUsed" } },
			@{Name = "Oldest Connection Time"; Expression = { $_."OldestConnectionTime" } },
			@{Name = "Program"; Expression = { $_."Program" } }  | ConvertTo-Html -As Table -Fragment

			if ($DebugInfo) {
				Write-Host " ->Converting session level options info to HTML" -fore yellow
			}

			$htmlTable4 = $SessOptTbl | Select-Object "Option", "SessionSetting", "InstanceSetting", "Description", "URL" | ConvertTo-Html -As Table -Fragment
			$htmlTable4 = $htmlTable4 -replace $URLRegex, '<a href="$&" target="_blank">$&</a>'


			$HtmlTabName = "Instance Overview"
			$html = $HTMLPre + @"
    <title>$HtmlTabName</title>
    </head>
    <body>
<h1>$HtmlTabName</h1>
<h2 style="text-align: center;">Instance information</h2>
$htmlTable1
<br>
<h2 style="text-align: center;">Resource information</h2>
$htmlTable2
<br>
<h2 style="text-align: center;">Top 10 clients by connections</h2>
$htmlTable3
<br>
<h2 style="text-align: center;">Session level options</h2>
$htmlTable4
</body>
</html>
"@
			if ($DebugInfo) {
				Write-Host " ->Writing HTML file." -fore yellow
			} 			
			$html | Out-File -Encoding utf8 -FilePath "$HTMLOutDir\InstanceInfo.html"
		}
		else {
			###Populating the "Instance Info" sheet
			$ExcelSheet = $ExcelFile.Worksheets.Item("Instance Info")
			##Instance Info section
			#Specify at which row in the sheet to start adding the data
			$ExcelStartRow = 3
			#Specify with which column in the sheet to start
			$ExcelColNum = 1
			#Set counter used for row retrieval
			$RowNum = 0

			#List of columns that should be returned from the data set
			$DataSetCols = @("machine_name", "instance_name", "product_version", "product_level",
				"patch_level", "edition", "is_clustered", "always_on_enabled", "filestream_access_level",
				"mem_optimized_tempdb_metadata", "fulltext_installed", "instance_collation", "process_id",
				"instance_last_startup", "uptime_days", "client_connections", "net_latency","server_time")

			if ($DebugInfo) {
				Write-Host " ->Writing instance info to Excel" -fore yellow
			}
			#Loop through each Excel row
			foreach ($row in $InstanceInfoTbl) {
				<#
				Loop through each data set column of current row and fill the corresponding 
				Excel cell
				#>
				foreach ($col in $DataSetCols) {			
					#Fill Excel cell with value from the data set
					if ($col -eq "net_latency") {
						$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $ConnTest
					}elseif("server_time","instance_last_startup" -contains $col){
						$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $InstanceInfoTbl.Rows[$RowNum][$col].ToString("yyyy-MM-dd HH:mm:ss")
					}
					else {
						$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $InstanceInfoTbl.Rows[$RowNum][$col]
					}
					$ExcelColNum += 1
				}

				#move to the next row in the spreadsheet
				$ExcelStartRow += 1
				#move to the next row in the data set
				$RowNum += 1
				# reset Excel column number so that next row population begins with column 1
				$ExcelColNum = 1
			}

			##Resource Info section
			#Specify at which row in the sheet to start adding the data
			$ExcelStartRow = 8
			#Specify with which column in the sheet to start
			$ExcelColNum = 1
			#Set counter used for row retrieval
			$RowNum = 0

			#List of columns that should be returned from the data set
			$DataSetCols = @("logical_cpu_cores", "physical_cpu_cores", "physical_memory_GB", "max_server_memory_GB", "target_server_memory_GB",
				"total_memory_used_GB", "proc_physical_memory_low", "proc_virtual_memory_low", "available_physical_memory_GB", "os_memory_state" , "CTP", "MAXDOP")

			if ($DebugInfo) {
				Write-Host " ->Writing resource info to Excel" -fore yellow
			}
			#Loop through each Excel row
			foreach ($row in $ResourceInfoTbl) {
				<#
				Loop through each data set column of current row and fill the corresponding 
				Excel cell
				#>
				foreach ($col in $DataSetCols) {			
					#Fill Excel cell with value from the data set
					$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $ResourceInfoTbl.Rows[$RowNum][$col]
					$ExcelColNum += 1
				}

				#move to the next row in the spreadsheet
				$ExcelStartRow += 1
				#move to the next row in the data set
				$RowNum += 1
				# reset Excel column number so that next row population begins with column 1
				$ExcelColNum = 1
			}

			##Top 10 clients by connections section
			#Specify at which row in the sheet to start adding the data
			$ExcelStartRow = 14
			#Specify with which column in the sheet to start
			$ExcelColNum = 1
			#Set counter used for row retrieval
			$RowNum = 0

			#List of columns that should be returned from the data set
			$DataSetCols = @("Database", "ConnectionsCount", "LoginName", "ClientHostName", "ClientIP", "ProtocolUsed", 
				"OldestConnectionTime", "Program")

			if ($DebugInfo) {
				Write-Host " ->Writing Top 10 clients by connections to Excel" -fore yellow
			}
			#Loop through each Excel row
			foreach ($row in $ConnectionsInfoTbl) {
				<#
				Loop through each data set column of current row and fill the corresponding 
				Excel cell
				#>
				foreach ($col in $DataSetCols) {			
					#Fill Excel cell with value from the data set
					if ("OldestConnectionTime" -contains $col) {
						$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $ConnectionsInfoTbl.Rows[$RowNum][$col].ToString("yyyy-MM-dd HH:mm:ss")
					}
					else {
						$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $ConnectionsInfoTbl.Rows[$RowNum][$col]
					}
					$ExcelColNum += 1
				}

				#move to the next row in the spreadsheet
				$ExcelStartRow += 1
				#move to the next row in the data set
				$RowNum += 1
				# reset Excel column number so that next row population begins with column 1
				$ExcelColNum = 1
			}

			#Session level options
			$ExcelStartRow = 14
			$ExcelColNum = 10
			$RowNum = 0

			$DataSetCols = @("Option", "SessionSetting", "InstanceSetting", "Description", "URL")
			if ($DebugInfo) {
				Write-Host " ->Writing Session level options to Excel" -fore yellow
			}
			#Loop through each Excel row
			foreach ($row in $SessOptTbl) {
				<#
				Loop through each data set column of current row and fill the corresponding 
				Excel cell
				#>
				foreach ($col in $DataSetCols) {			
					#Fill Excel cell with value from the data set
					if ($col -eq "URL") {
						if ($SessOptTbl.Rows[$RowNum][$col] -like "http*") {
							$ExcelSheet.Hyperlinks.Add($ExcelSheet.Cells.Item($ExcelStartRow, 10),
								$SessOptTbl.Rows[$RowNum][$col], "", "Click for more info",
								$SessOptTbl.Rows[$RowNum]["Option"]) | Out-Null
						}
					}
					else { 
						$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $SessOptTbl.Rows[$RowNum][$col]
					}
					$ExcelColNum += 1
				}

				#move to the next row in the spreadsheet
				$ExcelStartRow += 1
				#move to the next row in the data set
				$RowNum += 1
				# reset Excel column number so that next row population begins with column 1
				$ExcelColNum = 10
			}

			##Saving file 
			$ExcelFile.Save()
		}
		##Cleaning up variables 
		Remove-Variable -Name ResourceInfoTbl
		Remove-Variable -Name InstanceInfoTbl
		Remove-Variable -Name ConnectionsInfoTbl
		Remove-Variable -Name SessOptTbl
		Remove-Variable -Name InstanceInfoSet
	}

	if ($JobStatus -ne "Running") {
		Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop N
		$BlitzWhoPass += 1
	}

	#####################################################################################
	#						TempDB usage info	 										#
	#####################################################################################
	Write-Host " Retrieving TempDB usage data... " -NoNewLine
	$CmdTimeout = 600
	[string]$Query = [System.IO.File]::ReadAllText("$ResourcesPath\GetTempDBUsageInfo.sql")
	[string]$Query = $Query -replace '..PSBlitzReplace..', "$DirDate"
	$TempDBSelect = new-object System.Data.SqlClient.SqlCommand
	$TempDBSelect.CommandText = $Query
	$TempDBSelect.Connection = $SqlConnection
	$TempDBSelect.CommandTimeout = $CmdTimeout
	$TempDBAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
	$TempDBAdapter.SelectCommand = $TempDBSelect
	$TempDBSet = new-object System.Data.DataSet
	try {
		$StepStart = get-date
		$TempDBAdapter.Fill($TempDBSet) | Out-Null -ErrorAction Stop
		$SqlConnection.Close()
		$StepEnd = get-date
		Write-Host @GreenCheck
		$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
		$RunTime = [Math]::Round($StepRunTime, 2)
		if ($DebugInfo) {
			Write-Host " - $RunTime seconds" -Fore Yellow
		}
		$StepOutcome = "Success"
		Add-LogRow "TempDB Info" $StepOutcome
	}
 Catch {
		$StepEnd = get-date
		Invoke-ErrMsg
		$StepOutcome = "Failure"
		Add-LogRow "TempDB Info" $StepOutcome
	}
		
	if ($StepOutcome -eq "Success") {
		$TempDBTbl = New-Object System.Data.DataTable
		$TempDBTbl = $TempDBSet.Tables[0]
		
		$TempTabTbl = New-Object System.Data.DataTable
		$TempTabTbl = $TempDBSet.Tables[1]

		$TempDBSessTbl = New-Object System.Data.DataTable
		$TempDBSessTbl = $TempDBSet.Tables[2]

		if ($ToHTML -eq "Y") {
			if ($DebugInfo) {
				Write-Host " ->Converting TempDB info to HTML" -fore yellow
			}
			$htmlTable1 = $TempDBTbl | Select-Object @{Name = "Data Files"; Expression = { $_."data_files" } },
			@{Name = "Total Size MB"; Expression = { $_."total_size_MB" } },
			@{Name = "Free Space MB"; Expression = { $_."free_space_MB" } },
			@{Name = "% Free"; Expression = { $_."percent_free" } },
			@{Name = "Internal Objects MB"; Expression = { $_."internal_objects_MB" } },
			@{Name = "User Objects MB"; Expression = { $_."user_objects_MB" } },
			@{Name = "Version Store MB"; Expression = { $_."version_store_MB" } } | ConvertTo-Html -As Table -Fragment

			if ($DebugInfo) {
				Write-Host " ->Converting TempDB table info to HTML" -fore yellow
			}
			$htmlTable2 = $TempTabTbl | Select-Object @{Name = "Table Name"; Expression = { $_."table_name" } }, 
			@{Name = "Rows"; Expression = { $_."rows" } },
			@{Name = "Used Space MB"; Expression = { $_."used_space_MB" } }, 
			@{Name = "Reserved Space MB"; Expression = { $_."reserved_space_MB" } } | ConvertTo-Html -As Table -Fragment
            
			if ($DebugInfo) {
				Write-Host " ->Converting TempDB session usage info to HTML" -fore yellow
			}
			#Add query name column
			#adding query name
			$TempDBSessTbl.Columns.Add("Query", [string]) | Out-Null
			$RowNum = 0
			$i = 0
		
			foreach ($row in $TempDBSessTbl) {
				if ($TempDBSessTbl.Rows[$RowNum]["query_text"] -ne [System.DBNull]::Value) {
					$i += 1
					$QueryName = "TempDB_" + $i + ".query"
				
				}
				else { $QueryName = "" }
				$TempDBSessTbl.Rows[$RowNum]["Query"] = $QueryName
				$RowNum += 1
			}
			$htmlTable3 = $TempDBSessTbl | Select-Object @{Name = "Session ID"; Expression = { $_."session_id" } },
			@{Name = "Request ID"; Expression = { $_."request_id" } },
			"Query",
			@{Name = "Database Name"; Expression = { $_."database" } },
			@{Name = "Total Allocation User Objects MB"; Expression = { $_."total_allocation_user_objects_MB" } },
			@{Name = "Net Allocation User Objects MB"; Expression = { $_."net_allocation_user_objects_MB" } },
			@{Name = "Total Allocation Internal Objects MB"; Expression = { $_."total_allocation_internal_objects_MB" } },
			@{Name = "Net Allocation Internal Objects MB"; Expression = { $_."net_allocation_internal_objects_MB" } },
			@{Name = "Total Allocation MB"; Expression = { $_."total_allocation_MB" } },
			@{Name = "Net Allocation MB"; Expression = { $_."net_allocation_MB" } },
			#@{Name = "Query Text"; Expression = { $_."query_text" } },
			@{Name = "Query Hash"; Expression = { Get-HexString -HexInput $_."query_hash" } },
			@{Name = "Query Plan Hash"; Expression = { Get-HexString -HexInput $_."query_plan_hash" } } | ConvertTo-Html -As Table -Fragment
			
			$QExt = '.query'
			$FileSOrder = "TempDB"
			$AnchorRegex = "$FileSOrder(_\d+)$QExt"
			$AnchorURL = '<a href="#$&">$&</a>'
			$htmlTable3 = $htmlTable3 -replace $AnchorRegex, $AnchorURL

			$htmlTable4 = $TempDBSessTbl | Select-Object "Query", 
			@{Name = "Query Text"; Expression = { $_."query_text" } } | Where-Object { $_."query_text" -ne [System.DBNull]::Value } | ConvertTo-Html -As Table -Fragment
			$AnchorRegex = "<td>$FileSOrder(_\d+)$QExt"
			$AnchorURL = '<td id=' + "$FileSOrder" + '$1' + "$QExt>" + "$FileSOrder" + '$1' + "$QExt"
			$htmlTable4 = $htmlTable4 -replace $AnchorRegex, $AnchorURL

			$HtmlTabName = "TempDB Info"

			$html = $HTMLPre + @"
<title>$HtmlTabName</title>
</head>
<body>
<h1>$HtmlTabName</h1>
<h2 style="text-align: center;">TempDB space usage</h2>
$htmlTable1
<br>
<h2 style="text-align: center;">Top 30 temp tables by reserved space</h2>
"@
			if ($TempTabTbl.Rows.Count -gt 0) {
				$html += @"
$htmlTable2
<br>
"@
			}
			else {
				$html += @"
				<p style="text-align: center;">No temp tables found.</p>
				<br>
"@
			}
			$html += @"
			<h2 style="text-align: center;">Top 30 sessions using TempDB by total allocation</h2>
"@
			if ($TempDBSessTbl.Rows.Count -gt 0 ) {
				$html += @"
				$htmlTable3
				<br>
				<h3 style="text-align: center;">Query text</h3>
				$htmlTable4

"@
			}
			else {
				$html += @"
				<p style="text-align: center;">No sessions were using tempdb at this time.</p>
				<br>
"@
			}
			$html += @"
			</body>
			</html>
"@

			if ($DebugInfo) {
				Write-Host " ->Writing HTML file." -fore yellow
			}
			$html | Out-File -Encoding utf8 -FilePath "$HTMLOutDir\TempDBInfo.html"

		}
		else {

			###Populating the "TempDB" sheet
			$ExcelSheet = $ExcelFile.Worksheets.Item("TempDB")
			##TempDB space usage section
			#Specify at which row in the sheet to start adding the data
			$ExcelStartRow = 3
			#Specify with which column in the sheet to start
			$ExcelColNum = 1
			#Set counter used for row retrieval
			$RowNum = 0

			#List of columns that should be returned from the data set
			$DataSetCols = @("data_files", "total_size_MB", "free_space_MB", "percent_free", "internal_objects_MB",
				"user_objects_MB", "version_store_MB")

			if ($DebugInfo) {
				Write-Host " ->Writing TempDB space usage results to Excel" -fore yellow
			}
			#Loop through each Excel row
			foreach ($row in $TempDBTbl) {
				<#
				Loop through each data set column of current row and fill the corresponding 
				Excel cell
				#>
				foreach ($col in $DataSetCols) {			
					#Fill Excel cell with value from the data set
					$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $TempDBTbl.Rows[$RowNum][$col]
					$ExcelColNum += 1
				}

				#move to the next row in the spreadsheet
				$ExcelStartRow += 1
				#move to the next row in the data set
				$RowNum += 1
				# reset Excel column number so that next row population begins with column 1
				$ExcelColNum = 1
			}

			##Temp tables section
			#Specify at which row in the sheet to start adding the data
			$ExcelStartRow = 8
			#Specify with which column in the sheet to start
			$ExcelColNum = 1
			#Set counter used for row retrieval
			$RowNum = 0

			#List of columns that should be returned from the data set
			$DataSetCols = @("table_name", "rows", "used_space_MB", "reserved_space_MB")

			if ($DebugInfo) {
				Write-Host " ->Writing temp table results to Excel" -fore yellow
			}
			#Loop through each Excel row
			foreach ($row in $TempTabTbl) {
				<#
				Loop through each data set column of current row and fill the corresponding 
				Excel cell
				#>
				foreach ($col in $DataSetCols) {
					#Fill Excel cell with value from the data set
					$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $TempTabTbl.Rows[$RowNum][$col]
					$ExcelColNum += 1
				}

				#move to the next row in the spreadsheet
				$ExcelStartRow += 1
				#move to the next row in the data set
				$RowNum += 1
				# reset Excel column number so that next row population begins with column 1
				$ExcelColNum = 1
			}

			##TempDB session usage section
			#Specify at which row in the sheet to start adding the data
			$ExcelStartRow = 8
			#Specify with which column in the sheet to start
			$ExcelColNum = 6
			#Set counter used for row retrieval
			$RowNum = 0

			#List of columns that should be returned from the data set
			$DataSetCols = @("session_id", "request_id", "database", "total_allocation_user_objects_MB",
				"net_allocation_user_objects_MB", "total_allocation_internal_objects_MB", "net_allocation_internal_objects_MB",
				"total_allocation_MB", "net_allocation_MB", "query_text", "query_hash", "query_plan_hash")

			if ($DebugInfo) {
				Write-Host " ->Writing sessions using TempDB results to Excel" -fore yellow
			}
			#Loop through each Excel row
			foreach ($row in $TempDBSessTbl) {
				<#
				Loop through each data set column of current row and fill the corresponding 
				Excel cell
				#>
				foreach ($col in $DataSetCols) {			
					#Fill Excel cell with value from the data set
					#Properly handling Query Hash and Plan Hash hex values 
					if ("query_hash", "query_plan_hash" -Contains $col) {
						$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = Get-HexString -HexInput $TempDBSessTbl.Rows[$RowNum][$col]
						#move to the next column
						$ExcelColNum += 1
						#move to the top of the loop
						Continue
					}
					$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $TempDBSessTbl.Rows[$RowNum][$col]
					$ExcelColNum += 1
				}

				#move to the next row in the spreadsheet
				$ExcelStartRow += 1
				#move to the next row in the data set
				$RowNum += 1
				# reset Excel column number so that next row population begins with column 1
				$ExcelColNum = 6
			}
			##Saving file 
			$ExcelFile.Save()
		}
		##Cleaning up variables
		Remove-Variable -Name TempDBSessTbl
		Remove-Variable -Name TempTabTbl
		Remove-Variable -Name TempDBTbl
		Remove-Variable -Name TempDBSet		
	}

	if ($JobStatus -ne "Running") {
		Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop N
		$BlitzWhoPass += 1
	}

	#####################################################################################
	#						Open transaction info										#
	#####################################################################################
	Write-Host " Getting open transaction info" -NoNewline
	[string]$Query = [System.IO.File]::ReadAllText("$ResourcesPath\GetOpenTransactions.sql")
	if (!([string]::IsNullOrEmpty($CheckDB))) {
		[string]$Query = $Query -replace "SET @DatabaseName = N'';", "SET @DatabaseName = N'$CheckDB';"
		Write-Host " for $CheckDB" -NoNewline
	}
	elseif ($IsAzureSQLDB) {
		Write-Host " for $ASDBName" -NoNewline
	}
	Write-Host "... " -NoNewline
	$CmdTimeout = 600
	$AcTranQuery = new-object System.Data.SqlClient.SqlCommand
	$AcTranQuery.CommandText = $Query
	$AcTranQuery.Connection = $SqlConnection
	$AcTranQuery.CommandTimeout = $CmdTimeout
	$AcTranAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
	$AcTranAdapter.SelectCommand = $AcTranQuery
	$AcTranSet = new-object System.Data.DataSet
	Try {
		$StepStart = get-date
		$AcTranAdapter.Fill($AcTranSet) | Out-Null -ErrorAction Stop
		$SqlConnection.Close()
		$StepEnd = get-date
		Write-Host @GreenCheck
		$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
		$RunTime = [Math]::Round($StepRunTime, 2)
		if ($DebugInfo) {
			Write-Host " - $RunTime seconds" -Fore Yellow
		}
		$StepOutcome = "Success"
		Add-LogRow "Open Transacion Info" $StepOutcome
	}
 Catch {
		$StepEnd = get-date
		Invoke-ErrMsg
		$StepOutcome = "Failure"
		Add-LogRow "Open Transacion Info" $StepOutcome
	}
	if ($StepOutcome -eq "Success") {
		$AcTranTbl = New-Object System.Data.DataTable
		$AcTranTbl = $AcTranSet.Tables[0]
		[int]$RowsReturned = $AcTranTbl.Rows.Count
		if ($RowsReturned -le 0) {
			Write-Host " ->No open transactions found."
			$StepOutcome = "No open transactions found"
			Add-LogRow "->Open Transacion Info" $StepOutcome
		}
		else {
			##Exporting execution plans to file
			#Set counter used for row retrieval
			[int]$RowNum = 0
			$i = 0
			#loop through each row
			if ($DebugInfo) {
				Write-Host " ->Exporting execution plans" -fore yellow
			}
			foreach ($row in $AcTranTbl) {
				$i += 1
				if ($AcTranTbl.Rows[$RowNum]["current_plan"] -ne [System.DBNull]::Value) {
					[string]$SQLPlanFile = $AcTranTbl.Rows[$RowNum]["current_plan_file"]
					$AcTranTbl.Rows[$RowNum]["current_plan"] | Format-XML | Set-Content -Path $PlanOutDir\$($SQLPlanFile) -Force
				}
				if ($AcTranTbl.Rows[$RowNum]["most_recent_plan"] -ne [System.DBNull]::Value) {
					[string]$SQLPlanFile = $AcTranTbl.Rows[$RowNum]["most_recent_plan_file"]
					$AcTranTbl.Rows[$RowNum]["most_recent_plan"] | Format-XML | Set-Content -Path $PlanOutDir\$($SQLPlanFile) -Force
				}
				$RowNum += 1
			}
			if ($ToHTML -eq "Y") {

				$tableName = "Open transaction info"
				if (!([string]::IsNullOrEmpty($CheckDB))) {
					$tableName += " for $CheckDB" 
				}
				elseif ($IsAzureSQLDB) {
					$tableName += " for $ASDBName"
				}
				if ($DebugInfo) {
					Write-Host " ->Converting active transaction info to HTML" -fore yellow
				}

				
				$htmlTable1 = $AcTranTbl | Select-Object @{Name = "time_of_check"; Expression = { ($_."time_of_check").ToString("yyyy-MM-dd HH:mm:ss") } },
				"database_name", "session_id", "blocking_session_id",
				"current_query", "current_plan_file", "most_recent_query", "most_recent_plan_file", "wait_type",
				"wait_time_seconds", "wait_resource", "command",
				"session_status", "current_reuqest_status", "transaction_name",
			 "open_transaction_count",
				@{Name = "transaction_begin_time"; Expression = { ($_."transaction_begin_time").ToString("yyyy-MM-dd HH:mm:ss") } },
			 "transaction_type", "transaction_state",
			 @{Name = "request_start_time"; Expression = { ($_."request_start_time").ToString("yyyy-MM-dd HH:mm:ss") } },
			 @{Name = "request_end_time"; Expression = { ($_."request_end_time").ToString("yyyy-MM-dd HH:mm:ss") } },
			 "active_request_elapsed_seconds",
			 "host_name", "login_name", "program_name", "client_interface_name" | ConvertTo-Html -As Table -Fragment
				$QExt = '.query'
				$FileSOrder = "Current"
				$AnchorRegex = "$FileSOrder(_\d+)$QExt"
				$AnchorURL = '<a href="#$&">$&</a>'
				$htmlTable1 = $htmlTable1 -replace $AnchorRegex, $AnchorURL
				$htmlTable2 = $AcTranTbl | Select-Object @{Name = "Query"; Expression = { $_."current_query" } }, 
				@{Name = "Query text"; Expression = { $_."current_sql" } } | Where-Object { $_."current_sql" -ne [System.DBNull]::Value } | ConvertTo-Html -As Table -Fragment
				$AnchorRegex = "<td>$FileSOrder(_\d+)$QExt"
				$AnchorURL = '<td id=' + "$FileSOrder" + '$1' + "$QExt>" + "$FileSOrder" + '$1' + "$QExt"
				$htmlTable2 = $htmlTable2 -replace $AnchorRegex, $AnchorURL

				$FileSOrder = "MostRecent"
				$AnchorRegex = "$FileSOrder(_\d+)$QExt"
				$AnchorURL = '<a href="#$&">$&</a>'
				$htmlTable1 = $htmlTable1 -replace $AnchorRegex, $AnchorURL
				#@{Name = "Wait Category"; Expression = { $_."wait_category" } },

				$htmlTable3 = $AcTranTbl | Select-Object @{Name = "Query"; Expression = { $_."most_recent_query" } }, 
				@{Name = "Query text"; Expression = { $_."most_recent_sql" } } | Where-Object { $_."most_recent_sql" -ne [System.DBNull]::Value } | ConvertTo-Html -As Table -Fragment
				$AnchorRegex = "<td>$FileSOrder(_\d+)$QExt"
				$AnchorURL = '<td id=' + "$FileSOrder" + '$1' + "$QExt>" + "$FileSOrder" + '$1' + "$QExt"
				$htmlTable3 = $htmlTable3 -replace $AnchorRegex, $AnchorURL			

				$html = $HTMLPre + @"
<title>$tableName</title>
</head>
<body>
<h1 id="top">$tableName</h1>
$htmlTable1
<br>
<h2 style="text-align: center;">Current Query text</h2>
$htmlTable2
<br>
<h2 style="text-align: center;">Most Recent Query Text</h2>
$htmlTable3
<p style="text-align: center;"><a href="#top">Jump to top</a></p>
</body>
</html>
"@

				if ($DebugInfo) {
					Write-Host " ->Writing HTML file." -fore yellow
				} 
				$html | Out-File -Encoding utf8 -FilePath "$HTMLOutDir\OpenTransactions.html"

			}
			else {
				##Populating the "Open Transactions" sheet
				$ExcelSheet = $ExcelFile.Worksheets.Item("Open Transactions")
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = $DefaultStartRow
				#Specify with which column in the sheet to start
				$ExcelColNum = 1
				#Set counter used for row retrieval
				$RowNum = 0
				$SQLPlanNum = 1

				#List of columns that should be returned from the data set
				$DataSetCols = @("time_of_check", "database_name", "session_id", "blocking_session_id"
					, "current_sql", "current_plan_file", "most_recent_sql", "most_recent_plan_file", "wait_type"
					, "wait_time_seconds", "command", "session_status", "current_reuqest_status", "transaction_name"
					, "open_transaction_count", "transaction_begin_time", "transaction_type", "transaction_state"
					, "request_start_time", "request_end_time", "active_request_elapsed_seconds"
					, "host_name", "login_name", "program_name", "client_interface_name")
				if ($DebugInfo) {
					Write-Host " ->Writing open transaction results to Excel" -fore yellow
				}
				#Loop through each Excel row
				foreach ($row in $AcTranTbl) {
					<#
				Loop through each data set column of current row and fill the corresponding 
				Excel cell
				#>
					
					foreach ($col in $DataSetCols) {
						if ("time_of_check", "transaction_begin_time" -contains $col) {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $AcTranTbl.Rows[$RowNum][$col].ToString("yyyy-MM-dd HH:mm:ss")
						}
						else {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $AcTranTbl.Rows[$RowNum][$col]
						}
					
						#move to the next column
						$ExcelColNum += 1
					}

					#move to the next row in the spreadsheet
					$ExcelStartRow += 1
					$SQLPlanNum += 1
					#move to the next row in the data set
					$RowNum += 1
					# reset Excel column number so that next row population begins with column 1
					$ExcelColNum = 1
				}

				##Saving file 
				$ExcelFile.Save()
			}
					
		}
		##Cleaning up variables 
		Remove-Variable -Name AcTranTbl
		Remove-Variable -Name AcTranSet
	}

	if ($JobStatus -ne "Running") {
		Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop N
		$BlitzWhoPass += 1
	}


	#####################################################################################
	#						Database info												#
	#####################################################################################
	if ($IsAzureSQLDB) {
		#$StepStart = get-date
		#$StepEnd = get-date
		#Write-Host " Azure SQL DB - skipping database info."
		#Add-LogRow "Database Info" "Skipped" "Azure SQL DB"
		[string]$Query = [System.IO.File]::ReadAllText("$ResourcesPath\GetAzureSQLDBInfo.sql")
		Write-Host " Getting database info for $ASDBName... " -NoNewLine 
		$CmdTimeout = 600
		$DBInfoQuery = new-object System.Data.SqlClient.SqlCommand
		$DBInfoQuery.CommandText = $Query
		$DBInfoQuery.Connection = $SqlConnection
		$DBInfoQuery.CommandTimeout = $CmdTimeout
		$DBInfoAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
		$DBInfoAdapter.SelectCommand = $DBInfoQuery
		$DBInfoSet = new-object System.Data.DataSet
		Try {
			$StepStart = get-date
			$DBInfoAdapter.Fill($DBInfoSet) | Out-Null -ErrorAction Stop
			$SqlConnection.Close()
			$StepEnd = get-date
			Write-Host @GreenCheck
			$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
			$RunTime = [Math]::Round($StepRunTime, 2)
			if ($DebugInfo) {
				Write-Host " - $RunTime seconds" -Fore Yellow
			}
			$StepOutcome = "Success"
			Add-LogRow "Azure SQL DB Info" $StepOutcome
		}
		Catch {
			$StepEnd = get-date
			Invoke-ErrMsg
			$StepOutcome = "Failure"
			Add-LogRow "Azure SQL DB Info" $StepOutcome
		}
		if ($StepOutcome -eq "Success") {
			$RsrcGovTbl = New-Object System.Data.DataTable
			$RsrcGovTbl = $DBInfoSet.Tables[0]
			$DBInfoTbl = New-Object System.Data.DataTable
			$DBInfoTbl = $DBInfoSet.Tables[1]
			$RsrcUsageTbl = New-Object System.Data.DataTable
			$RsrcUsageTbl = $DBInfoSet.Tables[2]
			$Top10WaitsTbl = New-Object System.Data.DataTable
			$Top10WaitsTbl = $DBInfoSet.Tables[3]
			$DBFileInfoTbl = New-Object System.Data.DataTable
			$DBFileInfoTbl = $DBInfoSet.Tables[4]
			$ObjImpUpgrTbl = New-Object System.Data.DataTable
			$ObjImpUpgrTbl = $DBInfoSet.Tables[5]
			$DBConfigTbl = New-Object System.Data.DataTable
			$DBConfigTbl = $DBInfoSet.Tables[6]

			if ($ToHTML -eq "Y") {
				$tableName = "Azure SQL Database Info"
				if ($DebugInfo) {
					Write-Host " ->Converting Azure SQL Database Info results to HTML" -fore yellow
				}

				$htmlTable = $RsrcGovTbl | Select-Object "Database", "Service level objective", 
				"DTU limit(empty for vCore)", "vCore limit(empty for DTU databases)", "Min CPU%", "Max CPU%", 
				"Cap CPU%", "Max DOP", "Min Memory%", "Max Memory%", "Max allowed sessions", "Req Max Memory Grant%", 
				"Min Max DataFile Size(MB)", "Max Max DataFile Size(MB)", "Default Max DataFile Size(MB)", 
				"Default DataFile Growth Increment(MB)", "Default Size New DataFile(MB)", "Default Size New LogFile(MB)", 
				"Instnace Max Log Rate MB/s", "Instance Max Worker Threads", "Replica Type", "Max TLog Space/Transaction(KB)", 
				@{Name = "Settings Last Changed"; Expression = { ($_."Settings Last Changed").ToString("yyyy-MM-dd HH:mm:ss") } }, 
				"User Workload Max Worker Threads", "User Workload Min Log Rate MB/s", 
				"User Workload Max Log Rate MB/s", "User Workload Min IOPS", "User Workload Max IOPS", "User Workload Min CPU%", 
				"User Workload Max CPU%", "User Workload Max Worker Threads2", "User Workload Pool Max IOPS ", 
				"Max Local Storage(MB)", "Used Local Storage(MB)", "Max Pool Log Rate MB/s", 
				"primary_group_max_outbound_connection_workers", "primary_pool_max_outbound_connection_workers", 
				"Replica Role"	| ConvertTo-Html -As Table -Fragment

				$htmlTable1 = $DBInfoTbl | Select-Object "Database", "Service Objective", 
				@{Name = "Created"; Expression = { ($_."Created").ToString("yyyy-MM-dd HH:mm:ss") } }, "Database State", 
				"Data Files", "Data Files Size GB", "Log Files", "LogFilesSizeGB", "VirtualLogFiles", "FILESTREAM Containers", 
				"FS Containers Size GB", "Database Size GB", "Database MaxSize GB", "Current Log Reuse Wait", 
				"Compatibility Level", "Page Verify Option", "Containment", "Collation", "Snapshot Isolation State", 
				"Read Committed Snapshot On", "Recovery Model", "AutoClose On", "AutoShrink On", "QueryStore On", 
				"Trustworthy On" | ConvertTo-Html -As Table -Fragment

				$htmlTable2 = $RsrcUsageTbl | Select-Object @{Name = "Sample Start"; Expression = { ($_."Sample Start").ToString("yyyy-MM-dd HH:mm:ss") } }, 
				@{Name = "Sample End"; Expression = { ($_."Sample End").ToString("yyyy-MM-dd HH:mm:ss") } }, 
				"Sample(Minutes)", "Avg CPU Usage %", "Max CPU Usage %", "Avg Data IO %", "Max Data IO %", "Avg Log Write Usage %",
				"Max Log Write Usage %", "Avg Memory Usage %", "Max Memory Usage %" | ConvertTo-Html -As Table -Fragment

				$htmlTable3 = $Top10WaitsTbl | Select-Object @{Name = "Sample Start"; Expression = { ($_."Sample Start").ToString("yyyy-MM-dd HH:mm:ss") } }, 
				@{Name = "Sample End"; Expression = { ($_."Sample End").ToString("yyyy-MM-dd HH:mm:ss") } },
				"Sample(Hours)", "Wait Type", "Wait Count", "Wait %",
				"Total Wait Time(Sec)", "Avg Wait Time(Sec)", "Total Resource Time(Sec)", "Avg Resource Time(Sec)",
				"Total Signal Time(Sec)", "Avg Signal Time(Sec)", "URL" | ConvertTo-Html -As Table -Fragment
				$htmlTable3 = $htmlTable3 -replace $URLRegex, '<a href="$&" target="_blank">$&</a>'

				$htmlTable4 = $DBFileInfoTbl | Select-Object "Database", "FileID", "File Logical Name", "File Physical Name",
				"File Type", "State", "SizeGB", "Available SpaceGB", "Max File SizeGB", "Growth Increment" | ConvertTo-Html -As Table -Fragment

				if ($ObjImpUpgrTbl.Rows.Count -gt 0) {
					$htmlTable5 = $ObjImpUpgrTbl | Select-Objects "Object Type", "Object Name", "Index Name", "Dependency" | ConvertTo-Html -As Table -Fragment
				}
				else {
					$htmlTable5 = '<p style="text-align: center;">No matching objects found.</p>'
				}			

				$htmlTable6 = $DBConfigTbl | Select-Object "Config Name", "Value", "IsDefault" | ConvertTo-Html -As Table -Fragment

				$html = $HTMLPre + @"
<title>$tableName</title>
</head>
<body>
<h1 id="top" style="text-align: center;">$tableName</h1>
<h2 style="text-align: center;">Azure SQL DB Resource Governance</h1>
$htmlTable
<p style="text-align: center;"><a href="#top">Jump to top</a></p>
<br>
<h2 style="text-align: center;">Database Overview</h2>
$htmlTable1
<p style="text-align: center;"><a href="#top">Jump to top</a></p>
<br>
<h2 style="text-align: center;">Resource Usage</h2>
$htmlTable2
<p style="text-align: center;"><a href="#top">Jump to top</a></p>
<br>
<h2 style="text-align: center;">Top 10 Waits Since Last Startup</h2>
$htmlTable3
<p style="text-align: center;"><a href="#top">Jump to top</a></p>
<br>
<h2 style="text-align: center;">Database Files Info</h2>
$htmlTable4
<p style="text-align: center;"><a href="#top">Jump to top</a></p>
<br>
<h2 style="text-align: center;">Objects Impacted by a Major Release Upgrade of Azure SQL DB</h2>
$htmlTable5
<p style="text-align: center;"><a href="#top">Jump to top</a></p>
<br>
<h2 style="text-align: center;">Database Scoped Configuration</h2>
$htmlTable6
<p style="text-align: center;"><a href="#top">Jump to top</a></p>
</body>
</html>
"@
				if ($DebugInfo) {
					Write-Host " ->Writing HTML file." -fore yellow
				} 
				$html | Out-File -Encoding utf8 -FilePath "$HTMLOutDir\AzureSQLDBInfo.html"



			}
			else {
				#Populate the Azure SQL DB Resource Governance section
				$ExcelSheet = $ExcelFile.Worksheets.Item("Azure SQL DB Info")
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = 3
				#Specify with which column in the sheet to start
				$ExcelColNum = 1
				#Set counter used for row retrieval
				$RowNum = 0

				#List of columns that should be returned from the data set
				$DataSetCols = @("Database", "Service level objective", 
					"DTU limit(empty for vCore)", "vCore limit(empty for DTU databases)", "Min CPU%", "Max CPU%", 
					"Cap CPU%", "Max DOP", "Min Memory%", "Max Memory%", "Max allowed sessions", "Req Max Memory Grant%", 
					"Min Max DataFile Size(MB)", "Max Max DataFile Size(MB)", "Default Max DataFile Size(MB)", 
					"Default DataFile Growth Increment(MB)", "Default Size New DataFile(MB)", "Default Size New LogFile(MB)", 
					"Instnace Max Log Rate MB/s", "Instance Max Worker Threads", "Replica Type", "Max TLog Space/Transaction(KB)", 
					"Settings Last Changed", 
					"User Workload Max Worker Threads", "User Workload Min Log Rate MB/s", 
					"User Workload Max Log Rate MB/s", "User Workload Min IOPS", "User Workload Max IOPS", "User Workload Min CPU%", 
					"User Workload Max CPU%", "User Workload Max Worker Threads2", "User Workload Pool Max IOPS ", 
					"Max Local Storage(MB)", "Used Local Storage(MB)", "Max Pool Log Rate MB/s", 
					"primary_group_max_outbound_connection_workers", "primary_pool_max_outbound_connection_workers", 
					"Replica Role")
				if ($DebugInfo) {
					Write-Host " ->Writing Azure SQL DB Resource Governance results to Excel" -fore yellow
				}
				#Loop through each Excel row
				foreach ($row in $RsrcGovTbl) {
					<#
				Loop through each data set column of current row and fill the corresponding 
				Excel cell
				#>
					foreach ($col in $DataSetCols) {
						#Fill Excel cell with value from the data set
						if ($col -eq "Settings Last Changed") {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $RsrcGovTbl.Rows[$RowNum][$col].ToString("yyyy-MM-dd HH:mm:ss")
						}
						else {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $RsrcGovTbl.Rows[$RowNum][$col]
						}
					
						#move to the next column
						$ExcelColNum += 1
					}
					#move to the next row in the spreadsheet
					$ExcelStartRow += 1
					#move to the next row in the data set
					$RowNum += 1
					# reset Excel column number so that next row population begins with column 1
					$ExcelColNum = 1
				}

				##Saving file 
				$ExcelFile.Save()

				##Populating the "Database Overview" section
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = 8
				#Specify with which column in the sheet to start
				$ExcelColNum = 1
				#Set counter used for row retrieval
				$RowNum = 0

				#List of columns that should be returned from the data set
				$DataSetCols = @("Database", "Service Objective", "Created", "Database State", 
					"Data Files", "Data Files Size GB", "Log Files", "LogFilesSizeGB", "VirtualLogFiles", "FILESTREAM Containers", 
					"FS Containers Size GB", "Database Size GB", "Database MaxSize GB", "Current Log Reuse Wait", 
					"Compatibility Level", "Page Verify Option", "Containment", "Collation", "Snapshot Isolation State", 
					"Read Committed Snapshot On", "Recovery Model", "AutoClose On", "AutoShrink On", "QueryStore On", 
					"Trustworthy On")
				if ($DebugInfo) {
					Write-Host " ->Writing Database Overview results to Excel" -fore yellow
				}
				#Loop through each Excel row
				foreach ($row in $DBInfoTbl) {
					<#
				Loop through each data set column of current row and fill the corresponding 
				Excel cell
				#>
					foreach ($col in $DataSetCols) {
						#Fill Excel cell with value from the data set
						if ($col -eq "Created") {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $DBInfoTbl.Rows[$RowNum][$col].ToString("yyyy-MM-dd HH:mm:ss")
						}
						else {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $DBInfoTbl.Rows[$RowNum][$col]
						}
					
						#move to the next column
						$ExcelColNum += 1
					}
					#move to the next row in the spreadsheet
					$ExcelStartRow += 1
					#move to the next row in the data set
					$RowNum += 1
					# reset Excel column number so that next row population begins with column 1
					$ExcelColNum = 1
				}

				##Saving file 
				$ExcelFile.Save()

				##Populating the "Resource Usage" section
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = 13
				#Specify with which column in the sheet to start
				$ExcelColNum = 1
				#Set counter used for row retrieval
				$RowNum = 0

				#List of columns that should be returned from the data set
				$DataSetCols = @("Sample Start", "Sample End", "Sample(Minutes)", "Avg CPU Usage %", 
					"Max CPU Usage %", "Avg Data IO %", "Max Data IO %", "Avg Log Write Usage %",
					"Max Log Write Usage %", "Avg Memory Usage %", "Max Memory Usage %")
				if ($DebugInfo) {
					Write-Host " ->Writing Resource Usage results to Excel" -fore yellow
				}
				#Loop through each Excel row
				foreach ($row in $RsrcUsageTbl) {
					<#
				Loop through each data set column of current row and fill the corresponding 
				Excel cell
				#>
					foreach ($col in $DataSetCols) {
						#Fill Excel cell with value from the data set
						if ("Sample Start", "Sample End" -contains $col) {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $RsrcUsageTbl.Rows[$RowNum][$col].ToString("yyyy-MM-dd HH:mm:ss")
						}
						else {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $RsrcUsageTbl.Rows[$RowNum][$col]
						}
					
						#move to the next column
						$ExcelColNum += 1
					}
					#move to the next row in the spreadsheet
					$ExcelStartRow += 1
					#move to the next row in the data set
					$RowNum += 1
					# reset Excel column number so that next row population begins with column 1
					$ExcelColNum = 1
				}

				##Saving file 
				$ExcelFile.Save()

				##Populating the "Top 10 Waits" section
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = 22
				#Specify with which column in the sheet to start
				$ExcelColNum = 1
				#Set counter used for row retrieval
				$RowNum = 0

				#List of columns that should be returned from the data set
				$DataSetCols = @("Sample Start", "Sample End", "Sample(Hours)", "Wait Type", "Wait Count", "Wait %",
					"Total Wait Time(Sec)", "Avg Wait Time(Sec)", "Total Resource Time(Sec)", "Avg Resource Time(Sec)",
					"Total Signal Time(Sec)", "Avg Signal Time(Sec)", "URL")
				if ($DebugInfo) {
					Write-Host " ->Writing Top 10 Waits results to Excel" -fore yellow
				}
				#Loop through each Excel row
				foreach ($row in $Top10WaitsTbl) {
					<#
				Loop through each data set column of current row and fill the corresponding 
				Excel cell
				#>
					foreach ($col in $DataSetCols) {
						#Fill Excel cell with value from the data set
						if ("Sample Start", "Sample End" -contains $col) {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $Top10WaitsTbl.Rows[$RowNum][$col].ToString("yyyy-MM-dd HH:mm:ss")
						}
						elseif ($col -eq "URL") {
							#Make URLs clickable
							if ( $Top10WaitsTbl.Rows[$RowNum][$col] -like "http*") {
								$ExcelSheet.Hyperlinks.Add($ExcelSheet.Cells.Item($ExcelStartRow, 4),
									$Top10WaitsTbl.Rows[$RowNum][$col], "", "Click for more info",
									$Top10WaitsTbl.Rows[$RowNum]["Wait Type"]) | Out-Null
							}
						}
						else {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $Top10WaitsTbl.Rows[$RowNum][$col]
						}
					
						#move to the next column
						$ExcelColNum += 1
					}
					#move to the next row in the spreadsheet
					$ExcelStartRow += 1
					#move to the next row in the data set
					$RowNum += 1
					# reset Excel column number so that next row population begins with column 1
					$ExcelColNum = 1
				}

				##Saving file 
				$ExcelFile.Save()

				##Populating the "Database Files Info" section
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = 36
				#Specify with which column in the sheet to start
				$ExcelColNum = 1
				#Set counter used for row retrieval
				$RowNum = 0

				#List of columns that should be returned from the data set
				$DataSetCols = @("Database", "FileID", "File Logical Name", "File Physical Name",
					"File Type", "State", "SizeGB", "Available SpaceGB", "Max File SizeGB", "Growth Increment")
				if ($DebugInfo) {
					Write-Host " ->Writing Database Files Info results to Excel" -fore yellow
				}
				#Loop through each Excel row
				foreach ($row in $DBFileInfoTbl) {
					<#
				Loop through each data set column of current row and fill the corresponding 
				Excel cell
				#>
					foreach ($col in $DataSetCols) {
						#Fill Excel cell with value from the data set
						$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $DBFileInfoTbl.Rows[$RowNum][$col]
											
						#move to the next column
						$ExcelColNum += 1
					}
					#move to the next row in the spreadsheet
					$ExcelStartRow += 1
					#move to the next row in the data set
					$RowNum += 1
					# reset Excel column number so that next row population begins with column 1
					$ExcelColNum = 1
				}

				##Saving file 
				$ExcelFile.Save()

				##Populating the "Objects Impacted by a Major Release Upgrade of Azure SQL DB" section
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = 36
				#Specify with which column in the sheet to start
				$ExcelColNum = 12
				#Set counter used for row retrieval
				$RowNum = 0

				#List of columns that should be returned from the data set
				$DataSetCols = @("Object Type", "Object Name", "Index Name", "Dependency")
				if ($DebugInfo) {
					Write-Host " ->Writing Objects Impacted by a Major Release Upgrade of Azure SQL DB results to Excel" -fore yellow
				}
				#Loop through each Excel row
				foreach ($row in $ObjImpUpgrTbl) {
					<#
				Loop through each data set column of current row and fill the corresponding 
				Excel cell
				#>
					foreach ($col in $DataSetCols) {
						#Fill Excel cell with value from the data set
						$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $ObjImpUpgrTbl.Rows[$RowNum][$col]
											
						#move to the next column
						$ExcelColNum += 1
					}
					#move to the next row in the spreadsheet
					$ExcelStartRow += 1
					#move to the next row in the data set
					$RowNum += 1
					# reset Excel column number so that next row population begins with column 12
					$ExcelColNum = 12
				}

				##Saving file 
				$ExcelFile.Save()

				##Populating the "Objects Impacted by a Major Release Upgrade of Azure SQL DB" section
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = 36
				#Specify with which column in the sheet to start
				$ExcelColNum = 12
				#Set counter used for row retrieval
				$RowNum = 0

				#List of columns that should be returned from the data set
				$DataSetCols = @("Object Type", "Object Name", "Index Name", "Dependency")
				if ($DebugInfo) {
					Write-Host " ->Writing Objects Impacted by a Major Release Upgrade of Azure SQL DB results to Excel" -fore yellow
				}
				#Loop through each Excel row
				foreach ($row in $ObjImpUpgrTbl) {
					<#
				Loop through each data set column of current row and fill the corresponding 
				Excel cell
				#>
					foreach ($col in $DataSetCols) {
						#Fill Excel cell with value from the data set
						$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $ObjImpUpgrTbl.Rows[$RowNum][$col]
											
						#move to the next column
						$ExcelColNum += 1
					}
					#move to the next row in the spreadsheet
					$ExcelStartRow += 1
					#move to the next row in the data set
					$RowNum += 1
					# reset Excel column number so that next row population begins with column 12
					$ExcelColNum = 12
				}

				##Saving file 
				$ExcelFile.Save()


				##Populating the "Database Scoped Configuration" section
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = 36
				#Specify with which column in the sheet to start
				$ExcelColNum = 17
				#Set counter used for row retrieval
				$RowNum = 0

				#List of columns that should be returned from the data set
				$DataSetCols = @("Config Name", "Value", "IsDefault")
				if ($DebugInfo) {
					Write-Host " ->Writing Database Scoped Configuration results to Excel" -fore yellow
				}
				#Loop through each Excel row
				foreach ($row in $DBConfigTbl) {
					<#
				Loop through each data set column of current row and fill the corresponding 
				Excel cell
				#>
					foreach ($col in $DataSetCols) {
						#Fill Excel cell with value from the data set
						$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $DBConfigTbl.Rows[$RowNum][$col]
											
						#move to the next column
						$ExcelColNum += 1
					}
					#move to the next row in the spreadsheet
					$ExcelStartRow += 1
					#move to the next row in the data set
					$RowNum += 1
					# reset Excel column number so that next row population begins with column 17
					$ExcelColNum = 17
				}

				##Saving file 
				$ExcelFile.Save()
			}
			Remove-Variable -Name DBInfoTbl
			Remove-Variable -Name DBFileInfoTbl
			Remove-Variable -Name RsrcGovTbl
			Remove-Variable -Name RsrcUsageTbl
			Remove-Variable -Name ObjImpUpgrTbl
			Remove-Variable -Name DBConfigTbl
			Remove-Variable -Name DBInfoSet
		}

	}
 else {
		[string]$Query = [System.IO.File]::ReadAllText("$ResourcesPath\GetDbInfo.sql")	
		if (!([string]::IsNullOrEmpty($CheckDB))) {
			Write-Host " Getting database info for $CheckDB... " -NoNewLine
			[string]$Query = $Query -replace "SET @DatabaseName = N'';", "SET @DatabaseName = N'$CheckDB';"
		}
		else {
			Write-Host " Getting database info... " -NoNewLine
		}
		$CmdTimeout = 600
		$DBInfoQuery = new-object System.Data.SqlClient.SqlCommand
		$DBInfoQuery.CommandText = $Query
		$DBInfoQuery.Connection = $SqlConnection
		$DBInfoQuery.CommandTimeout = $CmdTimeout
		$DBInfoAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
		$DBInfoAdapter.SelectCommand = $DBInfoQuery
		$DBInfoSet = new-object System.Data.DataSet
		Try {
			$StepStart = get-date
			$DBInfoAdapter.Fill($DBInfoSet) | Out-Null -ErrorAction Stop
			$SqlConnection.Close()
			$StepEnd = get-date
			Write-Host @GreenCheck
			$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
			$RunTime = [Math]::Round($StepRunTime, 2)
			if ($DebugInfo) {
				Write-Host " - $RunTime seconds" -Fore Yellow
			}
			$StepOutcome = "Success"
			Add-LogRow "Database Info" $StepOutcome
		}
		Catch {
			$StepEnd = get-date
			Invoke-ErrMsg
			$StepOutcome = "Failure"
			Add-LogRow "Database Info" $StepOutcome
		}
		if ($StepOutcome -eq "Success") {
			$DBInfoTbl = New-Object System.Data.DataTable
			$DBInfoTbl = $DBInfoSet.Tables[0]
			$DBFileInfoTbl = New-Object System.Data.DataTable
			$DBFileInfoTbl = $DBInfoSet.Tables[1]
			if (($MajorVers -ge 13) -and (!([string]::IsNullOrEmpty($CheckDB)))) {
				#the 3rd result set exists only for SQL Server 2016 and above
				$DBConfigTbl = New-Object System.Data.DataTable
				$DBConfigTbl = $DBInfoSet.Tables[2]
			}
			elseif (($MajorVers -lt 13) -and (!([string]::IsNullOrEmpty($CheckDB)))) {
				Add-LogRow "->Database Scoped Config" "Skipped" "Major Version is $MajorVers"
			}

			if ($ToHTML -eq "Y") {
				$tableName = "Database Info"
				if ($DebugInfo) {
					Write-Host " ->Converting Database Info results to HTML" -fore yellow
				}
				$htmlTable = $DBInfoTbl | Select-Object "Database", @{Name = "Created"; Expression = { ($_."Created").ToString("yyyy-MM-dd HH:mm:ss") } }, 
				"DatabaseState", "UserAccess", "DataFiles", "DataFilesSizeGB", "LogFiles",
				"LogFilesSizeGB", "VirtualLogFiles", "FILESTREAMContainers", "FSContainersSizeGB",
				"DatabaseSizeGB", "CurrentLogReuseWait", "CompatibilityLevel", "PageVerifyOption", "Containment", "Collation", 
				"SnapshotIsolationState", "ReadCommittedSnapshotOn", "RecoveryModel", "AutoCloseOn",
				"AutoShrinkOn", "QueryStoreOn", "TrustworthyOn" | ConvertTo-Html -As Table -Fragment

				$htmlTable1 = $DBFileInfoTbl | Select-Object  "Database", "FileID", "FileLogicalName", "FilePhysicalName", "FileType", "State", "SizeGB",
				"AvailableSpaceGB", "MaxFileSizeGB", "GrowthIncrement" | ConvertTo-Html -As Table -Fragment

				if (($MajorVers -ge 13) -and (!([string]::IsNullOrEmpty($CheckDB)))) {
					$htmlTable2 = $DBConfigTbl | Select-Object "Database", "Config Name", "Value", "IsDefault" | ConvertTo-Html -As Table -Fragment
					$htmlBlock = "`n<br>`n" + '<h2 style="text-align: center;">Database Scoped Configuration</h2>'
					$htmlBlock += '<p style="text-align: center;"><a href="https://learn.microsoft.com/en-us/sql/t-sql/statements/alter-database-scoped-configuration-transact-sql?view=sql-server-ver16" target="_blank">More Info</a></p>'
					$htmlBlock += "`n $htmlTable2 `n"
					$htmlBlock += '<p style="text-align: center;"><a href="#top">Jump to top</a></p>'
				}
				else {
					$htmlBlock = ""
				}

				$html = $HTMLPre + @"
<title>$tableName</title>
</head>
<body>
<h1 id="top" style="text-align: center;">$tableName</h1>
$htmlTable
<p style="text-align: center;"><a href="#top">Jump to top</a></p>
<br>
<h2 style="text-align: center;">Database Files Info</h2>
$htmlTable1
<p style="text-align: center;"><a href="#top">Jump to top</a></p>
$htmlBlock
</body>
</html>
"@
				if ($DebugInfo) {
					Write-Host " ->Writing HTML file." -fore yellow
				} 
				$html | Out-File -Encoding utf8 -FilePath "$HTMLOutDir\DatabaseInfo.html"
			}
			else {
				##Populating the "Database Info" sheet with the database files data first because 
				#it's narrower and leaves room to fit some of the database info
				$ExcelSheet = $ExcelFile.Worksheets.Item("Database Info")
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = 3
				#Specify with which column in the sheet to start
				$ExcelColNum = 1
				#Set counter used for row retrieval
				$RowNum = 0

				#List of columns that should be returned from the data set
				$DataSetCols = @("Database", "FileID", "FileLogicalName", "FilePhysicalName", "FileType", "State", "SizeGB", "AvailableSpaceGB",
					"MaxFileSizeGB", "GrowthIncrement")
				if ($DebugInfo) {
					Write-Host " ->Writing Database Files Info results to Excel" -fore yellow
				}
				#Loop through each Excel row
				foreach ($row in $DBFileInfoTbl) {
					<#
				Loop through each data set column of current row and fill the corresponding 
				Excel cell
				#>
					foreach ($col in $DataSetCols) {
						#Fill Excel cell with value from the data set
						$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $DBFileInfoTbl.Rows[$RowNum][$col]
					
						#move to the next column
						$ExcelColNum += 1
					}
					#move to the next row in the spreadsheet
					$ExcelStartRow += 1
					#move to the next row in the data set
					$RowNum += 1
					# reset Excel column number so that next row population begins with column 1
					$ExcelColNum = 1
				}

				##Populating the "Database Info" sheet with the database data
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = 3
				#Specify with which column in the sheet to start
				$ExcelColNum = 12
				#Set counter used for row retrieval
				$RowNum = 0

				#List of columns that should be returned from the data set
				$DataSetCols = @("Database", "Created", "DatabaseState", "UserAccess", "DataFiles", "DataFilesSizeGB", "LogFiles",
					"LogFilesSizeGB", "VirtualLogFiles", "FILESTREAMContainers", "FSContainersSizeGB",
					"DatabaseSizeGB", "CurrentLogReuseWait", "CompatibilityLevel", "PageVerifyOption", "Containment", "Collation", "SnapshotIsolationState", 
					"ReadCommittedSnapshotOn", "RecoveryModel", "AutoCloseOn",
					"AutoShrinkOn", "QueryStoreOn", "TrustworthyOn")
				if ($DebugInfo) {
					Write-Host " ->Writing Database Info results to Excel" -fore yellow
				}
				#Loop through each Excel row
				foreach ($row in $DBInfoTbl) {
					<#
				Loop through each data set column of current row and fill the corresponding 
				Excel cell
				#>
					foreach ($col in $DataSetCols) {
						#Fill Excel cell with value from the data set
						if ($col -eq "Created") {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $DBInfoTbl.Rows[$RowNum][$col].ToString("yyyy-MM-dd HH:mm:ss")
						}
						else {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $DBInfoTbl.Rows[$RowNum][$col]
						}
					
						#move to the next column
						$ExcelColNum += 1
					}
					#move to the next row in the spreadsheet
					$ExcelStartRow += 1
					#move to the next row in the data set
					$RowNum += 1
					# reset Excel column number so that next row population begins with column 12
					$ExcelColNum = 12
				}

				if (($MajorVers -ge 13) -and (!([string]::IsNullOrEmpty($CheckDB)))) {
					##Populating the DB Scoped Config sheet
					$ExcelSheet = $ExcelFile.Worksheets.Item("DB Scoped Config")
					#Specify at which row in the sheet to start adding the data
					$ExcelStartRow = 2
					#Specify with which column in the sheet to start
					$ExcelColNum = 2
					#Set counter used for row retrieval
					$RowNum = 0

					#List of columns that should be returned from the data set
					$DataSetCols = @("Database", "Config Name", "Value", "IsDefault")
					if ($DebugInfo) {
						Write-Host " ->Writing Database Scoped Configuration results to Excel" -fore yellow
					}
					#Loop through each Excel row
					foreach ($row in $DBConfigTbl) {
						<#
				Loop through each data set column of current row and fill the corresponding 
				Excel cell
				#>
						foreach ($col in $DataSetCols) {
							#Fill Excel cell with value from the data set
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $DBConfigTbl.Rows[$RowNum][$col]
					
							#move to the next column
							$ExcelColNum += 1
						}
						#move to the next row in the spreadsheet
						$ExcelStartRow += 1
						#move to the next row in the data set
						$RowNum += 1
						# reset Excel column number so that next row population begins with column 1
						$ExcelColNum = 2
					}
				}

				##Saving file 
				$ExcelFile.Save()
			}
			Remove-Variable -Name DBInfoTbl
			Remove-Variable -Name DBFileInfoTbl
			Remove-Variable -Name DBInfoSet
		}
	}

	if ($JobStatus -ne "Running") {
		Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop N
		$BlitzWhoPass += 1
	}
	#####################################################################################
	#						sp_Blitz 													#
	#####################################################################################
	if ($IsAzureSQLDB) {
		$StepStart = get-date
		$StepEnd = get-date
		Write-Host " Azure SQL DB - skipping sp_Blitz."
		Add-LogRow "sp_Blitz" "Skipped" "Azure SQL DB"
	}
 else {
		Write-Host " Running sp_Blitz... " -NoNewLine
		[string]$Query = [System.IO.File]::ReadAllText("$ResourcesPath\spBlitz_NonSPLatest.sql")
		if (($IsIndepth -eq "Y") -and ([string]::IsNullOrEmpty($CheckDB))) {
			[string]$Query = $Query -replace ";SET @CheckUserDatabaseObjects = 0;", ";SET @CheckUserDatabaseObjects = 1;"
		}
		$CmdTimeout = 600
		$BlitzQuery = new-object System.Data.SqlClient.SqlCommand
		$BlitzQuery.CommandText = $Query
		$BlitzQuery.Connection = $SqlConnection
		$BlitzQuery.CommandTimeout = $CmdTimeout
		$BlitzAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
		$BlitzAdapter.SelectCommand = $BlitzQuery
		$BlitzSet = new-object System.Data.DataSet
		Try {
			$StepStart = get-date
			$BlitzAdapter.Fill($BlitzSet) | Out-Null -ErrorAction Stop
			$SqlConnection.Close()
			$StepEnd = get-date
			Write-Host @GreenCheck
			$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
			$RunTime = [Math]::Round($StepRunTime, 2)
			if ($DebugInfo) {
				Write-Host " - $RunTime seconds" -Fore Yellow
			}
			$StepOutcome = "Success"
			Add-LogRow "sp_Blitz" $StepOutcome
		}
		Catch {
			$StepEnd = get-date
			Invoke-ErrMsg
			$StepOutcome = "Failure"
			Add-LogRow "sp_Blitz" $StepOutcome
		}
		
		if ($StepOutcome -eq "Success") {
			$BlitzTbl = New-Object System.Data.DataTable
			$BlitzTbl = $BlitzSet.Tables[0]

			if ($ToHTML -eq "Y") {
				$tableName = "Instance Health"
				if ($DebugInfo) {
					Write-Host " ->Converting sp_Blitz output to HTML" -fore yellow
				}
				$htmlTable = $BlitzTbl | Select-Object "Priority", "FindingsGroup", "Finding", "DatabaseName", "Details", "URL" | Where-Object -FilterScript { ($_."Finding" -ne "SQL Server First Responder Kit" ) -and ("Rundate", "Thanks!" -notcontains $_."FindingsGroup") } | ConvertTo-Html -As Table -Fragment
				$htmlTable = $htmlTable -replace $URLRegex, '<a href="$&" target="_blank">$&</a>'
				$html = $HTMLPre + @"
<title>$tableName</title>
</head>
<body>
<h1 id="top" style="text-align: center;">$tableName</h1>
$htmlTable
<p style="text-align: center;"><a href="#top">Jump to top</a></p>
</body>
</html>
"@

				if ($DebugInfo) {
					Write-Host " ->Writing HTML file." -fore yellow
				} 
				$html | Out-File -Encoding utf8 -FilePath "$HTMLOutDir\spBlitz.html"

			}
			else {
				##Populating the "sp_Blitz" sheet
				$ExcelSheet = $ExcelFile.Worksheets.Item("Instance Health")
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = $DefaultStartRow
				#Specify with which column in the sheet to start
				$ExcelColNum = 1
				#Set counter used for row retrieval
				$RowNum = 0

				#List of columns that should be returned from the data set
				$DataSetCols = @("Priority", "FindingsGroup", "Finding" , "DatabaseName",
					"Details", "URL")
				if ($DebugInfo) {
					Write-Host " ->Writing sp_Blitz results to Excel" -fore yellow
				}
				#Loop through each Excel row
				foreach ($row in $BlitzTbl) {
					<#
				Loop through each data set column of current row and fill the corresponding 
				Excel cell
				#>
					foreach ($col in $DataSetCols) {
						#Fill Excel cell with value from the data set
						if ($col -eq "URL") {
							#Make URLs clickable
							if ($BlitzTbl.Rows[$RowNum][$col] -like "http*") {
								$ExcelSheet.Hyperlinks.Add($ExcelSheet.Cells.Item($ExcelStartRow, 3),
									$BlitzTbl.Rows[$RowNum][$col], "", "Click for more info",
									$BlitzTbl.Rows[$RowNum]["Finding"]) | Out-Null
							}
						}
						else {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $BlitzTbl.Rows[$RowNum][$col]
						}
						#move to the next column
						$ExcelColNum += 1
					}

					#move to the next row in the spreadsheet
					$ExcelStartRow += 1
					#move to the next row in the data set
					$RowNum += 1
					# reset Excel column number so that next row population begins with column 1
					$ExcelColNum = 1
				}

				##Saving file 
				$ExcelFile.Save()
			}
			##Cleaning up variables 
			Remove-Variable -Name BlitzTbl
			Remove-Variable -Name BlitzSet		
		}
	}

	if ($JobStatus -ne "Running") {
		Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop N
		$BlitzWhoPass += 1
	}


	#####################################################################################
	#						sp_BlitzFirst 30 seconds									#
	#####################################################################################
	Write-Host " Running sp_BlitzFirst @Seconds = 30... " -NoNewLine
	$CmdTimeout = 600
	[string]$Query = [System.IO.File]::ReadAllText("$ResourcesPath\spBlitzFirst_NonSPLatest.sql")
	$BlitzFirstQuery = new-object System.Data.SqlClient.SqlCommand
	$BlitzFirstQuery.CommandText = $Query
	$BlitzFirstQuery.Connection = $SqlConnection
	$BlitzFirstQuery.CommandTimeout = $CmdTimeout
	$BlitzFirstAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
	$BlitzFirstAdapter.SelectCommand = $BlitzFirstQuery
	$BlitzFirstSet = new-object System.Data.DataSet
	Try {
		$StepStart = get-date
		$BlitzFirstAdapter.Fill($BlitzFirstSet) | Out-Null -ErrorAction Stop
		$SqlConnection.Close()
		$StepEnd = get-date
		Write-Host @GreenCheck
		$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
		$RunTime = [Math]::Round($StepRunTime, 2)
		if ($DebugInfo) {
			Write-Host " - $RunTime seconds" -Fore Yellow
		}
		$StepOutcome = "Success"
		Add-LogRow "sp_BlitzFirst 30 seconds" $StepOutcome
	}
 Catch {
		$StepEnd = get-date
		Invoke-ErrMsg
		$StepOutcome = "Failure"
		Add-LogRow "sp_BlitzFirst 30 seconds" $StepOutcome
	}
		
	if ($StepOutcome -eq "Success") {
		$BlitzFirstTbl = New-Object System.Data.DataTable
		$BlitzFirstTbl = $BlitzFirstSet.Tables[0]

		if ($ToHTML -eq "Y") {
			if ($DebugInfo) {
				Write-Host " ->Converting sp_BlitzFirst output to HTML" -fore yellow
			}
			$htmlTable = $BlitzFirstTbl | Select-Object "Priority", "FindingsGroup", "Finding", 
			@{Name = "Details"; Expression = { $_."Details".Replace('ClickToSeeDetails', '') } }, "URL" | Where-Object -FilterScript { ( "0", "255" -NotContains $_."Priority" ) } | ConvertTo-Html -As Table -Fragment
			$htmlTable = $htmlTable -replace $URLRegex, '<a href="$&" target="_blank">$&</a>'
			$HtmlTabName = "What's happening on the instance now?"
			$html = $HTMLPre + @"
<title>$HtmlTabName</title>
</head>
<body>
<h1>$HtmlTabName</h1>
<h2>30 seconds time-frame</h2>
$htmlTable
</body>
</html>
"@

			if ($DebugInfo) {
				Write-Host " ->Writing HTML file." -fore yellow
			} 
			$html | Out-File -Encoding utf8 -FilePath "$HTMLOutDir\BlitzFirst30s.html"
		}
		else {

			##Populating the "sp_BlitzFirst 30s" sheet
			$ExcelSheet = $ExcelFile.Worksheets.Item("Happening Now")
			#Specify at which row in the sheet to start adding the data
			$ExcelStartRow = $DefaultStartRow
			#Specify with which column in the sheet to start
			$ExcelColNum = 1
			#Set counter used for row retrieval
			$RowNum = 0

			$DataSetCols = @("Priority", "FindingsGroup", "Finding", "Details", "URL")

			if ($DebugInfo) {
				Write-Host " ->Writing sp_BlitzFirst results to Excel" -fore yellow
			}
			#Loop through each Excel row
			foreach ($row in $BlitzFirstTbl) {
				#Loop through each data set column of current row and fill the corresponding 
				# Excel cell
				foreach ($col in $DataSetCols) {
					#Fill Excel cell with value from the data set
					if ($col -eq "URL") {
						if ($BlitzFirstTbl.Rows[$RowNum][$col] -like "http*") {
							$ExcelSheet.Hyperlinks.Add($ExcelSheet.Cells.Item($ExcelStartRow, 3),
								$BlitzFirstTbl.Rows[$RowNum][$col], "", "Click for more info",
								$BlitzFirstTbl.Rows[$RowNum]["Finding"]) | Out-Null
						}
					}
					else {
						$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $BlitzFirstTbl.Rows[$RowNum][$col]
					}
					#move to the next column
					$ExcelColNum += 1
				}

				#move to the next row in the spreadsheet
				$ExcelStartRow += 1
				#move to the next row in the data set
				$RowNum += 1
				# reset Excel column number so that next row population begins with column 1
				$ExcelColNum = 1
			}
			##Saving file 
			$ExcelFile.Save()
		}
		Remove-Variable -Name BlitzFirstTbl
		Remove-Variable -Name BlitzFirstSet
	}
	if ($JobStatus -ne "Running") {
		Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop N
		$BlitzWhoPass += 1
	}

	#####################################################################################
	#						sp_BlitzFirst since startup									#
	#####################################################################################
	if ($IsIndepth -eq "Y") {
		Write-Host " Running sp_BlitzFirst @SinceStartup = 1... " -NoNewLine
		$CmdTimeout = 600
		[string]$Query = [System.IO.File]::ReadAllText("$ResourcesPath\spBlitzFirst_NonSPLatest.sql")
		[string]$Query = $Query -replace ";SET @SinceStartup = 0;", ";SET @SinceStartup = 1;"
		$BlitzFirstQuery = new-object System.Data.SqlClient.SqlCommand
		$BlitzFirstQuery.CommandText = $Query
		$BlitzFirstQuery.Connection = $SqlConnection
		$BlitzFirstQuery.CommandTimeout = $CmdTimeout 
		$BlitzFirstAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
		$BlitzFirstAdapter.SelectCommand = $BlitzFirstQuery
		$BlitzFirstSet = new-object System.Data.DataSet
		Try {
			$StepStart = get-date
			$BlitzFirstAdapter.Fill($BlitzFirstSet) | Out-Null -ErrorAction Stop
			$SqlConnection.Close()
			$StepEnd = get-date
			Write-Host @GreenCheck
			$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
			$RunTime = [Math]::Round($StepRunTime, 2)
			if ($DebugInfo) {
				Write-Host " - $RunTime seconds" -Fore Yellow
			}
			$StepOutcome = "Success"
			Add-LogRow "sp_BlitzFirst since startup" $StepOutcome
		}
	 Catch {
			$StepEnd = get-date
			Invoke-ErrMsg
			$StepOutcome = "Failure"
			Add-LogRow "sp_BlitzFirst since startup" $StepOutcome
		}
			
		if ($StepOutcome -eq "Success") {
			$WaitsTbl = New-Object System.Data.DataTable
			$WaitsTbl = $BlitzFirstSet.Tables[0]

			$StorageTbl = New-Object System.Data.DataTable
			$StorageTbl = $BlitzFirstSet.Tables[1]

			$PerfmonTbl = New-Object System.Data.DataTable
			$PerfmonTbl = $BlitzFirstSet.Tables[2]


			if ($ToHTML -eq "Y") {
				#Waits
				if ($DebugInfo) {
					Write-Host " ->Converting wait stats info to HTML" -fore yellow
				}
				$HtmlTabName = "Wait Stats Since Last Startup"

				$htmlTable = $WaitsTbl | Select-Object "Pattern", 
				@{Name = "Sample Ended"; Expression = { ($_."Sample Ended").ToString("yyyy-MM-dd HH:mm:ss") } },
				"Hours Sample", "Thread Time (Hours)",
				@{Name = "Wait Type"; Expression = { $_."wait_type" } }, 
				@{Name = "Wait Category"; Expression = { $_."wait_category" } }, 
				"Wait Time (Hours)", "Per Core Per Hour", 
				"Signal Wait Time (Hours)", "Percent Signal Waits", "Number of Waits",
				"Avg ms Per Wait", "URL" | ConvertTo-Html -As Table -Fragment
				$htmlTable = $htmlTable -replace $URLRegex, '<a href="$&" target="_blank">$&</a>'
			 
				$html = $HTMLPre + @"
<title>$HtmlTabName</title>
</head>
<body>
<h1>$HtmlTabName</h1>
<br>
$htmlTable
</body>
</html>
"@
				if ($DebugInfo) {
					Write-Host " ->Writing HTML file." -fore yellow
				} 
				$html | Out-File -Encoding utf8 -FilePath "$HTMLOutDir\BlitzFirst_Waits.html"
			 
				#Storage
				if ($DebugInfo) {
					Write-Host " ->Converting storage info to HTML" -fore yellow
				}
				$HtmlTabName = "Storage Throughput Since Instance Startup"
				$htmlTable = $StorageTbl | Select-Object "Pattern", 
				@{Name = "Sample Time"; Expression = { ($_."Sample Time").ToString("yyyy-MM-dd HH:mm:ss") } }, 
				"Sample (seconds)", 
				"File Name",
				"Drive", "# Reads/Writes", "MB Read/Written", "Avg Stall (ms)", 
				@{Name = "Physical File Name"; Expression = { $_."file physical name" } },
				@{Name = "Database Name"; Expression = { $_."DatabaseName" } } | ConvertTo-Html -As Table -Fragment
			 
				$html = $HTMLPre + @"
<title>$HtmlTabName</title>
</head>
<body>
<h1>$HtmlTabName</h1>
<br>
$htmlTable
</body>
</html>
"@
				if ($DebugInfo) {
					Write-Host " ->Writing HTML file." -fore yellow
				} 
				$html | Out-File -Encoding utf8 -FilePath "$HTMLOutDIr\BlitzFirst_Storage.html"
			 
				#Perfmon
				if ($DebugInfo) {
					Write-Host " ->Converting perfmon stats to HTML" -fore yellow
				}
				$HtmlTabName = "Perfmon Stats Since Instance Startup"
				$htmlTable = $PerfmonTbl | Select-Object "Pattern", 
				@{Name = "ObjectName"; Expression = { $_."object_name" } }, 
				@{Name = "CounterName"; Expression = { $_."counter_name" } }, 
				@{Name = "InstanceName"; Expression = { $_."instance_name" } }, 
				@{Name = "FirstSampleTime"; Expression = { ($_."FirstSampleTime").ToString("yyyy-MM-dd HH:mm:ss") } }, 
				"FirstSampleValue", 
				@{Name = "LastSampleTime"; Expression = { ($_."LastSampleTime").ToString("yyyy-MM-dd HH:mm:ss") } }, 
				"LastSampleValue", "ValueDelta", "ValuePerSecond" | ConvertTo-Html -As Table -Fragment
			 
				$html = $HTMLPre + @"
<title>$HtmlTabName</title>
</head>
<body>
<h1>$HtmlTabName</h1>
<br>
$htmlTable
</body>
</html>
"@

				if ($DebugInfo) {
					Write-Host " ->Writing HTML file." -fore yellow
				} 
				$html | Out-File -Encoding utf8 -FilePath "$HTMLOutDIr\BlitzFirst_Perfmon.html"
			}
			else {
				##Populating the "Wait Stats" sheet
				$ExcelSheet = $ExcelFile.Worksheets.Item("Wait Stats")
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = $DefaultStartRow
				#Specify with which column in the sheet to start
				$ExcelColNum = 1
				#Set counter used for row retrieval
				$RowNum = 0

				$DataSetCols = @("Pattern", "Sample Ended", "Hours Sample", "Thread Time (Hours)",
					"wait_type", "wait_category", "Wait Time (Hours)", "Per Core Per Hour", 
					"Signal Wait Time (Hours)", "Percent Signal Waits", "Number of Waits",
					"Avg ms Per Wait", "URL")

				if ($DebugInfo) {
					Write-Host " ->Writing sp_BlitzFirst results to sheet Wait Stats" -fore yellow
				}
				#Loop through each Excel row
				foreach ($row in $WaitsTbl) {
					#Loop through each data set column of current row and fill the corresponding 
					# Excel cell
					foreach ($col in $DataSetCols) {
						if ($col -eq "Sample Ended") {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $WaitsTbl.Rows[$RowNum][$col].ToString("yyyy-MM-dd HH:mm:ss")
						}
						elseif ($col -eq "URL") {
							#Make URLs clickable
							if ($WaitsTbl.Rows[$RowNum][$col] -like "http*") {
								$ExcelSheet.Hyperlinks.Add($ExcelSheet.Cells.Item($ExcelStartRow, 5),
									$WaitsTbl.Rows[$RowNum][$col], "", "Click for more info",
									$WaitsTbl.Rows[$RowNum]["wait_type"]) | Out-Null
							}
						}
						else {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $WaitsTbl.Rows[$RowNum][$col]
						}
						#move to the next column
						$ExcelColNum += 1
					}

					#move to the next row in the spreadsheet
					$ExcelStartRow += 1
					#move to the next row in the data set
					$RowNum += 1
					# reset Excel column number so that next row population begins with column 1
					$ExcelColNum = 1
				}

				##Saving file 
				$ExcelFile.Save()
				## populating the "Storage" sheet
				$ExcelSheet = $ExcelFile.Worksheets.Item("Storage Stats")
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = $DefaultStartRow
				#Specify with which column in the sheet to start
				$ExcelColNum = 1
				#Set counter used for row retrieval
				$RowNum = 0

				$DataSetCols = @("Pattern", "Sample Time", "Sample (seconds)", "File Name",
					"Drive", "# Reads/Writes", "MB Read/Written", "Avg Stall (ms)", "file physical name",
					"DatabaseName")
				if ($DebugInfo) {
					Write-Host " ->Writing sp_BlitzFirst results to sheet Storage Stats" -fore yellow
				}
				#Loop through each Excel row
				foreach ($row in $StorageTbl) {
					#Loop through each data set column of current row and fill the corresponding 
					# Excel cell
					foreach ($col in $DataSetCols) {
						#Fill Excel cell with value from the data set
						if ($col -eq "Sample Time") {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $StorageTbl.Rows[$RowNum][$col].ToString("yyyy-MM-dd HH:mm:ss")
						}
						else {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $StorageTbl.Rows[$RowNum][$col]
						}
						#move to the next column
						$ExcelColNum += 1
					}

					#move to the next row in the spreadsheet
					$ExcelStartRow += 1
					#move to the next row in the data set
					$RowNum += 1
					# reset Excel column number so that next row population begins with column 1
					$ExcelColNum = 1
				}

				##Saving file 
				$ExcelFile.Save()
				## populating the "Perfmon" sheet
				$ExcelSheet = $ExcelFile.Worksheets.Item("Perfmon Stats")
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = $DefaultStartRow
				#Specify with which column in the sheet to start
				$ExcelColNum = 1
				#Set counter used for row retrieval
				$RowNum = 0

				$DataSetCols = @("Pattern", "object_name", "counter_name", "instance_name", 
					"FirstSampleTime", "FirstSampleValue", "LastSampleTime", "LastSampleValue",
					"ValueDelta", "ValuePerSecond")

				if ($DebugInfo) {
					Write-Host " ->Writing sp_BlitzFirst results to sheet Perfmon Stats" -fore yellow
				}
				#Loop through each Excel row
				foreach ($row in $PerfmonTbl) {
					#Loop through each data set column of current row and fill the corresponding 
					# Excel cell
					foreach ($col in $DataSetCols) {
						#Fill Excel cell with value from the data set
						if ("FirstSampleTime", "LastSampleTime" -Contains $col) {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $PerfmonTbl.Rows[$RowNum][$col].ToString("yyyy-MM-dd HH:mm:ss")
						}
						else {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $PerfmonTbl.Rows[$RowNum][$col]
						}
						#move to the next column
						$ExcelColNum += 1
					}

					#move to the next row in the spreadsheet
					$ExcelStartRow += 1
					#move to the next row in the data set
					$RowNum += 1
					# reset Excel column number so that next row population begins with column 1
					$ExcelColNum = 1
				}
		
				##Saving file 
				$ExcelFile.Save()
			}

			##Cleaning up variables
			Remove-Variable -Name WaitsTbl
			Remove-Variable -Name StorageTbl
			Remove-Variable -Name PerfmonTbl
			Remove-Variable -Name BlitzFirstSet
		}
		if ($JobStatus -ne "Running") {
			Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop N
			$BlitzWhoPass += 1
		}
	}
		

	#####################################################################################
	#						sp_BlitzCache												#
	#####################################################################################
	#Building a list of values for @SortOrder 
	<#
	Ony run through the other sort orders if $IsIndepth = "Y"
	otherwise just do duration and avg duration
	#>
	if ($IsIndepth -eq "Y") {
		$SortOrders = @("'CPU'", "'Average CPU'", "'Reads'", "'Average Reads'",
			"'Duration'", "'Average Duration'", "'Executions'", "'Executions per Minute'",
			"'Writes'", "'Average Writes'", "'Spills'", "'Average Spills'",
			"'Memory Grant'", "'Recent Compilations'")
	}
 else {
		$SortOrders = @("'CPU'", "'Average CPU'", "'Duration'",
			"'Average Duration'")
	}
	#Set initial SortOrder value
	$OldSortOrder = "'CPU'"
	[string]$Query = [System.IO.File]::ReadAllText("$ResourcesPath\spBlitzCache_NonSPLatest.sql")
	$CmdTimeout = $MaxTimeout
	#Set specific database to check if a name was provided
	if (!([string]::IsNullOrEmpty($CheckDB))) {
		[string]$Query = $Query -replace $OldCheckDBStr, $NewCheckDBStr
		Write-Host " Running sp_BlitzCache for $CheckDB"
	}
 elseif ($IsAzureSQLDB) {
		Write-Host " Running sp_BlitzCache for $ASDBName"
	}
 else {
		Write-Host " Running sp_BlitzCache for all user databases"
		#Create array to store database names
		$DBArray = New-Object System.Collections.ArrayList
		[int]$BlitzCacheRecs = 0
	}
	#Loop through sort orders
	foreach ($SortOrder in $SortOrders) {
		#Filename sort order portion
		$FileSOrder = $SortOrder.Replace('Average', 'Avg')
		$FileSOrder = $SortOrder.Replace('Executions per Minute', 'ExPM')
		$FileSOrder = $SortOrder.Replace(' ', '_')
		$FileSOrder = $FileSOrder.Replace("'", '')

		#Replace old sort order with new one
		$OldSortString = ";SELECT @SortOrder = " + $OldSortOrder
		$NewSortString = ";SELECT @SortOrder = " + $SortOrder
		#Replace number of records returned if sorting by recent compilations
		if ($SortOrder -eq "'recent compilations'") {
			$OldSortString = $OldSortString + ", @Top = $CacheTop;"
			$NewSortString = $NewSortString + ", @Top = 50;"
		}
		elseif (($CacheTop -ne 10) -and ($SortOrder -eq "'CPU'")) {
			#Since we're only reading the script once and then using it from memory, 
			#we only have to change @Top once if it's not the default
			$OldSortString = $OldSortString + ", @Top = 10;"
			$NewSortString = $NewSortString + ", @Top = $CacheTop;"
		}
		if ($DebugInfo) {
			Write-Host " ->Replacing $OldSortString with $NewSortString" -fore yellow
		}		

		[string]$Query = $Query -replace $OldSortString, $NewSortString
		Write-Host " ->Running sp_BlitzCache with @SortOrder = $SortOrder... " -NoNewLine
		$BlitzCacheQuery = new-object System.Data.SqlClient.SqlCommand
		$BlitzCacheQuery.CommandText = $Query
		$BlitzCacheQuery.CommandTimeout = $CmdTimeout
		$BlitzCacheQuery.Connection = $SqlConnection
		$BlitzCacheAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
		$BlitzCacheAdapter.SelectCommand = $BlitzCacheQuery
		$BlitzCacheSet = new-object System.Data.DataSet
		Try {
			$StepStart = get-date
			$BlitzCacheAdapter.Fill($BlitzCacheSet) | Out-Null -ErrorAction Stop
			$SqlConnection.Close()
			$StepEnd = get-date
			Write-Host @GreenCheck
			$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
			$RunTime = [Math]::Round($StepRunTime, 2)
			if ($DebugInfo) {
				Write-Host " - $RunTime seconds" -Fore Yellow
			}
			$PreviousOutcome = $StepOutcome
			$StepOutcome = "Success"
			$RecordsReturned = $BlitzCacheSet.Tables[0].Rows.Count
			Add-LogRow "sp_BlitzCache $SortOrder" $StepOutcome "$RecordsReturned records returned"
		}
	 Catch {
			$StepEnd = get-date
			Invoke-ErrMsg
			$StepOutcome = "Failure"
			Add-LogRow "sp_BlitzCache $SortOrder" $StepOutcome
		}
			
		if ($StepOutcome -eq "Success") {
			$BlitzCacheTbl = New-Object System.Data.DataTable
			$BlitzCacheTbl = $BlitzCacheSet.Tables[0]
			$BlitzCacheWarnTbl = New-Object System.Data.DataTable
			$BlitzCacheWarnTbl = $BlitzCacheSet.Tables[1]

			##Exporting execution plans to file
			if ($DebugInfo) {
				Write-Host " ->Exporting execution plans for $SortOrder" -fore yellow
			}
			#Set counter used for row retrieval
			$RowNum = 0
			#Setting $i to 0
			$i = 0

			$BlitzCacheTbl.Columns.Add("SQLPlan File", [string]) | Out-Null

			foreach ($row in $BlitzCacheTbl) {
				#Increment file name counter	
				$i += 1
				$SQLPlanFile = "-- N/A --" 
				#Get only the column storing the execution plan data that's not NULL and write it to a file
				if ($BlitzCacheTbl.Rows[$RowNum]["Query Plan"] -ne [System.DBNull]::Value) {
					$SQLPlanFile = $FileSOrder + "_" + $i + ".sqlplan"
					$BlitzCacheTbl.Rows[$RowNum]["Query Plan"] | Format-XML | Set-Content -Path "$PlanOutDir\$SQLPlanFile" -Force
				}
				$BlitzCacheTbl.Rows[$RowNum]["SQLPlan File"] = $SQLPlanFile		
				#Increment row retrieval counter
				$RowNum += 1
			}

			##Add database names to array
			if (([string]::IsNullOrEmpty($CheckDB)) -and ($IsAzureSQLDB -eq $false)) {
				foreach ($row in $BlitzCacheTbl."Database") {
					if ($row -ne [System.DBNull]::Value) {
						$DBArray.Add($row) | Out-Null
						$BlitzCacheRecs += 1
					}
				}
			}

			<#
			 Set Excel sheet names based on $SortOrder
			Since we're already checking for sort order, I'll also add the column number for CSS
			#>
			$SheetName = "Top Queries - "
			if ($SortOrder -like '*CPU*') {
				$SheetName = $SheetName + "CPU"
				$HighlightCol = 16
			}
			elseif ($SortOrder -like '*Reads*') {
				$SheetName = $SheetName + "Reads"
				$HighlightCol = 24
			}
			elseif ($SortOrder -like '*Duration*') {
				$SheetName = $SheetName + "Duration"
				$HighlightCol = 20
			}
			elseif ($SortOrder -like '*Executions*') {
				$SheetName = $SheetName + "Executions"
				$HighlightCol = 10
			}
			elseif ($SortOrder -like '*Writes*') {
				$SheetName = $SheetName + "Writes"
				$HighlightCol = 28
			}
			elseif ($SortOrder -like '*Spills*') {
				$SheetName = $SheetName + "Spills"
				$HighlightCol = 58
			}
			elseif ($SortOrder -like '*Memory*') {
				$SheetName = $SheetName + "Mem & Recent Comp"
				$HighlightCol = 52
			}
			elseif ($SortOrder -eq "'Recent compilations'") {
				$SheetName = $SheetName + "Mem & Recent Comp"
				$HighlightCol = 38
			}

			if ($ToHTML -eq "Y") {
				$SheetName = $SheetName -replace "Top Queries - ", ""
				
				$RowNum = 0
				$i = 0
			
				#adding query name
				$BlitzCacheTbl.Columns.Add("Query", [string]) | Out-Null
				$RowNum = 0
				$i = 0
			
				foreach ($row in $BlitzCacheTbl) {
					if ($BlitzCacheTbl.Rows[$RowNum]["Query Text"] -ne [System.DBNull]::Value) {
						$i += 1
						$QueryName = $FileSOrder + "_" + $i + ".query"
					
					}
					else { $QueryName = "" }
					$BlitzCacheTbl.Rows[$RowNum]["Query"] = $QueryName
					$RowNum += 1
				}
				if ($DebugInfo) {
					Write-Host " ->Converting sp_BlitzCache output to HTML" -fore yellow
				}
				
				$htmlTable1 = $BlitzCacheTbl | Select-Object "Database", "Cost", 
				"Query",
				"SQLPlan File", 
				"Query Type", "Warnings", 
				@{Name = "Missing Indexes"; Expression = { $_."Missing Indexes".Replace('ClickMe', '').Replace('<?NoNeedTo -- N/A --?>', '') } },	
				@{Name = "Implicit Conversion Info"; Expression = { $_."Implicit Conversion Info".Replace('ClickMe', '').Replace('<?NoNeedTo -- N/A --?>', '') } },
				@{Name = "Cached Execution Parameters"; Expression = { $_."Cached Execution Parameters".Replace('ClickMe', '').Replace('<?NoNeedTo -- N/A --?>', '') } },
				"# Executions", "Executions / Minute", "Execution Weight",
				"% Executions (Type)", "Serial Desired Memory",
				"Serial Required Memory", "Total CPU (ms)", "Avg CPU (ms)", "CPU Weight", "% CPU (Type)",
				"Total Duration (ms)", "Avg Duration (ms)", "Duration Weight", "% Duration (Type)",
				"Total Reads", "Average Reads", "Read Weight", "% Reads (Type)", "Total Writes",
				"Average Writes", "Write Weight", "% Writes (Type)", "Total Rows", "Avg Rows", "Min Rows",
				"Max Rows", "# Plans", "# Distinct Plans", 
				@{Name = "Created At"; Expression = { ($_."Created At").ToString("yyyy-MM-dd HH:mm:ss") } }, 
				@{Name = "Last Execution"; Expression = { ($_."Last Execution").ToString("yyyy-MM-dd HH:mm:ss") } },
				"StatementStartOffset", "StatementEndOffset", 
				@{Name = "Query Hash"; Expression = { Get-HexString -HexInput $_."Query Hash" } }, 
				@{Name = "Query Plan Hash"; Expression = { Get-HexString -HexInput $_."Query Plan Hash" } },
				"SET Options", "Cached Plan Size (KB)", "Compile Time (ms)", "Compile CPU (ms)",
				"Compile memory (KB)", 
				@{Name = "Plan Handle"; Expression = { Get-HexString -HexInput $_."Plan Handle" } }, 
				@{Name = "SQL Handle"; Expression = { Get-HexString -HexInput $_."SQL Handle" } }, 
				"Minimum Memory Grant KB",
				"Maximum Memory Grant KB", "Minimum Used Grant KB", "Maximum Used Grant KB",
				"Average Max Memory Grant", "Min Spills", "Max Spills", "Total Spills", "Avg Spills" | ConvertTo-Html -As Table -Fragment
				
				#Handling URLs
				$QExt = '.query'
				$AnchorRegex = "$FileSOrder(_\d+)$QExt"
				$AnchorURL = '<a href="#$&">$&</a>'
				$htmlTable1 = $htmlTable1 -replace $AnchorRegex, $AnchorURL
		
				$htmlTable2 = $BlitzCacheWarnTbl | Select-Object "Priority", "FindingsGroup", "Finding", "Details", "URL" | ConvertTo-Html -As Table -Fragment
				$htmlTable2 = $htmlTable2 -replace $URLRegex, '<a href="$&" target="_blank">$&</a>'

				$htmlTable3 = $BlitzCacheTbl | Select-Object "Query", 
				"Query Text" | ConvertTo-Html -As Table -Fragment
				$AnchorRegex = "<td>$FileSOrder(_\d+)$QExt"
				$AnchorURL = '<td id=' + "$FileSOrder" + '$1' + "$QExt>" + "$FileSOrder" + '$1' + "$QExt"
				$htmlTable3 = $htmlTable3 -replace $AnchorRegex, $AnchorURL

		
				#pairing up related tables in the same HTML file
				if ("'CPU'", "'Reads'", "'Duration'", "'Executions'", "'Writes'",
					"'Spills'", "'Memory Grant'" -contains $SortOrder) {
					#Handling CSS
					$CacheHTMLPre = $HTMLPre
					$CacheHTMLPre = $CacheHTMLPre -replace 'CacheTab1High', $HighlightCol
					$htmlTable1 = $htmlTable1 -replace '<table>', '<table class="CacheTable1">'
					
					if ($SheetName -eq "Mem & Recent Comp") {
						$HtmlTabName = "Queries by Memory Grants & Recent Compilations"
					}
					else {
						$HtmlTabName = "Queries by $SheetName"
					}
					if (!([string]::IsNullOrEmpty($CheckDB))) {
						$HtmlTabName += " for $CheckDB" 
					}
					elseif ($IsAzureSQLDB) {
						$HtmlTabName += " for $ASDBName"
					}
					
					$HtmlFileName = $SheetName -replace " & ", "_"
					$HtmlFileName = $HtmlFileName -replace " ", "_"
					$HtmlFileName = "BlitzCache_$HtmlFileName.html"
					$HtmlTabName2 = $SortOrder -replace "'", ""
					
					$html = @"
					<title>$HtmlTabName</title>
					</head>
					<body>
					<h1 id="top" style="text-align: center;">$HtmlTabName</h1>
					<br>
					<h2 style="text-align: center;">Top $CacheTop Queries by $HtmlTabName2</h2>
					<p style="text-align: center;"><a href="#Queries1">Jump to query text</a></p>
					$htmlTable1
					<br>
					<h2 style="text-align: center;">Warnings Explained</h2>
					$htmlTable2
					<p style="text-align: center;"><a href="#top">Jump to top</a></p>
					<br>

"@

					$html2 = @"
					<h2 id="Queries1" style="text-align: center;">Query text for $HtmlTabName2</h2>
					$htmlTable3
					<p style="text-align: center;"><a href="#top">Jump to top</a></p>
					<br>

"@
					$FirstHalf = "Done"
					$SecondHalf = "NotDone"

				}
		
				#adding the second half of each html page and writing to file
				if (($SortOrder -like '*Average*') -or ($SortOrder -eq "'Executions per Minute'") -or ($SortOrder -eq "'Recent Compilations'")) {
					$HtmlTabName2 = $SortOrder -replace "'", ""
					#Handling CSS
					$htmlTable1 = $htmlTable1 -replace '<table>', '<table class="CacheTable2">'
					
					#Add heading if first half of the table failed
					if ($PreviousOutcome -eq "Failure") {
						$CacheHTMLPre = $HTMLPre
						#$html = $CacheHTMLPre
						$html2 = @"
						<br>
"@
					} 					
					if ($SortOrder -eq "'Recent Compilations'") {
						$TopCount = "50"						
					}
					else {
						$TopCount = "$CacheTop"
						$HighlightCol += 1
					}
					$CacheHTMLPre = $CacheHTMLPre -replace 'CacheTab2High', $HighlightCol
					$html += @"
				<h2 style="text-align: center;">Top $TopCount Queries by $HtmlTabName2</h2>
				<p style="text-align: center;"><a href="#Queries2">Jump to query text</a></p>
				$htmlTable1
				<br>
				<h2 style="text-align: center;">Warnings Explained</h2>
				$htmlTable2
				<p style="text-align: center;"><a href="#top">Jump to top</a></p>

"@

					$html2 += @"
					<h2 id="Queries2" style="text-align: center;">Query text for $HtmlTabName2</h2>					
					$htmlTable3
					<p style="text-align: center;"><a href="#top">Jump to top</a></p>
"@
					#putting it all together
					$html3 = $CacheHTMLPre + $html + $html2 + @"
					<br>
					</body>
					</html>
"@
					$SecondHalf = "Done"
					$html3 | Out-File -Encoding utf8 -FilePath "$HTMLOutDir\$HtmlFileName"
				}
				if ($DebugInfo) {
					Write-Host " ->Writing HTML file." -fore yellow
				}
				#Only writing the file here if this is the first half
				if (($FirstHalf -eq "Done") -and ($SecondHalf -eq "NotDone")) {
					$html3 = $CacheHTMLPre + $html + $html2 + @"
					<br>
					</body>
					</html>
"@
					$html3 | Out-File -Encoding utf8 -FilePath "$HTMLOutDir\$HtmlFileName"
				}

			}
			else {
				#Specify worksheet
				$ExcelSheet = $ExcelFile.Worksheets.Item($SheetName)

				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = 3
				#$SortOrder containing avg or xpm will export data starting with row 16
				if (($SortOrder -like '*Average*') -or ($SortOrder -eq "'Executions per Minute'") -or ($SortOrder -eq "'Recent Compilations'")) {
					$ExcelStartRow = 17
				}
				#Set counter used for row retrieval
				$RowNum = 0
				#Set counter for sqlplan file names
				$SQLPlanNum = 1

				$ExcelColNum = 1

				#define column list to only get the sp_BlitzCache columns that are relevant in this case
				$DataSetCols = @("Database", "Cost", "Query Text", "SQLPlan File", "Query Type", "Warnings", "Missing Indexes",	"Implicit Conversion Info", "Cached Execution Parameters",
					"# Executions", "Executions / Minute", "Execution Weight",
					"% Executions (Type)", "Serial Desired Memory",
					"Serial Required Memory", "Total CPU (ms)", "Avg CPU (ms)", "CPU Weight", "% CPU (Type)",
					"Total Duration (ms)", "Avg Duration (ms)", "Duration Weight", "% Duration (Type)",
					"Total Reads", "Average Reads", "Read Weight", "% Reads (Type)", "Total Writes",
					"Average Writes", "Write Weight", "% Writes (Type)", "Total Rows", "Avg Rows", "Min Rows",
					"Max Rows", "# Plans", "# Distinct Plans", "Created At", "Last Execution",
					"StatementStartOffset", "StatementEndOffset", "Query Hash", "Query Plan Hash",
					"SET Options", "Cached Plan Size (KB)", "Compile Time (ms)", "Compile CPU (ms)",
					"Compile memory (KB)", "Plan Handle", "SQL Handle", "Minimum Memory Grant KB",
					"Maximum Memory Grant KB", "Minimum Used Grant KB", "Maximum Used Grant KB",
					"Average Max Memory Grant", "Min Spills", "Max Spills", "Total Spills", "Avg Spills")
				if ($DebugInfo) {
					Write-Host " ->Writing sp_BlitzCache results to sheet $SheetName" -fore yellow
				}
				foreach ($row in $BlitzCacheTbl) {
					#Loop through each column from $DataSetCols for curent row and retrieve data from 
					foreach ($col in $DataSetCols) {

						#Properly handling Query Hash, Plan Hash, Plan, and SQL Handle hex values 
						if ("Query Hash", "Query Plan Hash", "Plan Handle", "SQL Handle" -Contains $col) {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = Get-HexString -HexInput $BlitzCacheTbl.Rows[$RowNum][$col]
							#move to the next column
							$ExcelColNum += 1
							#move to the top of the loop
							Continue
						}
						if ($BlitzCacheTbl.Rows[$RowNum][$col] -eq "<?NoNeedToClickMe -- N/A --?>") {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = "   -- N/A --   "
							#move to the next column
							$ExcelColNum += 1
							#move to the top of the loop
							Continue
						}			
						$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $BlitzCacheTbl.Rows[$RowNum][$col]
						#move to the next column
						$ExcelColNum += 1			
						
					}

					#move to the next row in the spreadsheet
					$ExcelStartRow += 1
					#move to the next row in the data set
					$RowNum += 1
					# reset Excel column number so that next row population begins with column 1
					$ExcelColNum = 1
				}

				####Plan Cache warning
				$SheetName = "Plan Cache Warnings"

				#Specify worksheet
				$ExcelSheet = $ExcelFile.Worksheets.Item($SheetName)

				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = 3
				#$SortOrder containing avg or xpm will export data starting with row 16
				if (($SortOrder -like '*Average*') -or ($SortOrder -eq "'Executions per Minute'") -or ($SortOrder -eq "'Recent Compilations'")) {
					$ExcelStartRow = 36
				}
				#Set counter used for row retrieval
				$RowNum = 0
				#Set counter for sqlplan file names
				$SQLPlanNum = 1


				if ($SortOrder -like '*CPU*') {
					$ExcelWarnInitCol = 1
				}
				elseif ($SortOrder -like '*Duration*') {
					$ExcelWarnInitCol = 6
				}
				elseif ($SortOrder -like '*Reads*') {
					$ExcelWarnInitCol = 11
				}
				elseif ($SortOrder -like '*Writes*') {
					$ExcelWarnInitCol = 16
				}
				elseif ($SortOrder -eq "'Executions'") {
					$ExcelWarnInitCol = 21
				}
				elseif ($SortOrder -eq "'Executions per Minute'") {
					$ExcelWarnInitCol = 21
				}
				elseif ($SortOrder -like '*Spills*') {
					$ExcelWarnInitCol = 26
				}
				elseif ($SortOrder -like '*Memory*') {
					$ExcelWarnInitCol = 31
				}
				elseif ($SortOrder -eq "'Recent Compilations'") {
					$ExcelWarnInitCol = 31
				}

				$ExcelURLCol = $ExcelWarnInitCol + 2
				$ExcelColNum = $ExcelWarnInitCol

				#define column list to only get the sp_BlitzCache columns that are relevant in this case
				$DataSetCols = @("Priority", "FindingsGroup", "Finding", "Details", "URL")
				if ($DebugInfo) {
					Write-Host " ->Writing sp_BlitzCache results to sheet $SheetName" -fore yellow
				}
				foreach ($row in $BlitzCacheWarnTbl) {
					#Loop through each column from $DataSetCols for curent row and retrieve data from 
					foreach ($col in $DataSetCols) {
						if ($col -eq "URL") {
							if ($BlitzCacheWarnTbl.Rows[$RowNum][$col] -like "http*") {
								$ExcelSheet.Hyperlinks.Add($ExcelSheet.Cells.Item($ExcelStartRow, $ExcelURLCol),
									$BlitzCacheWarnTbl.Rows[$RowNum][$col], "", "Click for more info",
									$BlitzCacheWarnTbl.Rows[$RowNum]["Finding"]) | Out-Null
							}
						}
						else {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $BlitzCacheWarnTbl.Rows[$RowNum][$col] 
						} 
						#move to the next column
						$ExcelColNum += 1			
					}

					#move to the next row in the spreadsheet
					$ExcelStartRow += 1
					#move to the next row in the data set
					$RowNum += 1
					# reset Excel column number so that next row population begins with column 1
					$ExcelColNum = $ExcelWarnInitCol
					if ($RowNum -eq 31) {
						Continue
					}
				}
				##Saving file 
				$ExcelFile.Save()
			}	
			##Cleaning up variables 
			Remove-Variable -Name BlitzCacheWarnTbl
			Remove-Variable -Name BlitzCacheTbl
			Remove-Variable -Name BlitzCacheSet

		}

		$OldSortOrder = $SortOrder
		if ($DebugInfo) {
			Write-Host " ->old sort order is now $OldSortOrder" -fore yellow
		}

		if ($JobStatus -ne "Running") {
			Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop Y
			$BlitzWhoPass += 1
		}

	}
	
	#####################################################################################
	#						sp_BlitzQueryStore											#
	#####################################################################################

	<#
		if no specific database name has been provided, check BlitzCache results for any database that
		might account for 2/3 of all the records returned by BlitzCache
	#>
	if (([string]::IsNullOrEmpty($CheckDB)) -and ($IsAzureSQLDB -eq $false)) {
		[int]$TwoThirdsBlitzCache = [Math]::Floor([decimal]($BlitzCacheRecs / 1.5))
		[string]$DBName = $DBArray | Group-Object -NoElement | Sort-Object Count | ForEach-Object Name | Select-Object -Last 1
		[int]$DBCount = $DBArray | Group-Object -NoElement | Sort-Object Count | ForEach-Object Count | Select-Object -Last 1
		if (($DBCount -ge $TwoThirdsBlitzCache) -and ($DBName -ne "-- N/A --") -and (!([string]::IsNullOrEmpty($DBName)))) {
			Write-Host " $DBName accounts for at least 2/3 of the records returned by sp_BlitzCache"
			Write-Host " ->" -NoNewLine
			$StepStart = get-date
			[string]$CheckDB = $DBName
			$DBSwitched = "Y"
			$StepEnd = get-date
			Add-LogRow "CheckDB value" "Switched" "$DBName accounts for at least 2/3 of the records returned by sp_BlitzCache"
		}
		
	}

	##Check if DB is eligible for sp_BlitzQueryStore first
	if ((!([string]::IsNullOrEmpty($CheckDB))) -or ($IsAzureSQLDB)) {
		if ($DBSwitched -ne "Y") {
			Write-Host " " -NoNewLine
		}
		$CheckDBQuery = new-object System.Data.SqlClient.SqlCommand
		if (!([string]::IsNullOrEmpty($CheckDB))) {
			Write-Host "Checking if $CheckDB is eligible for sp_BlitzQueryStore..."
			$DBQuery = @" 
		IF ( (SELECT PARSENAME(CONVERT(NVARCHAR(128), SERVERPROPERTY ('PRODUCTVERSION')), 4)) < 13 )
  BEGIN
      SELECT 'No' AS [EligibleForBlitzQueryStore]
  END
ELSE IF ( (SELECT PARSENAME(CONVERT(NVARCHAR(128), SERVERPROPERTY ('PRODUCTVERSION')), 4)) >= 13 )
  BEGIN
      IF(SELECT COUNT(*)
         FROM   sys.databases AS d
         WHERE  d.is_query_store_on = 1
                AND d.user_access_desc = 'MULTI_USER'
                AND d.state_desc = 'ONLINE'
                AND d.name = @DBName
                AND d.is_distributor = 0) > 0
        BEGIN
            SELECT 'Yes' AS [EligibleForBlitzQueryStore]
        END
      ELSE
        BEGIN
            SELECT 'No' AS [EligibleForBlitzQueryStore]
        END
  END;
"@
			$CheckDBQuery.CommandText = $DBQuery
			$CheckDBQuery.Parameters.Add("@DBName", [Data.SQLDBType]::NVarChar, 256) | Out-Null
			$CheckDBQuery.Parameters["@DBName"].Value = $CheckDB
		}
		elseif ($IsAzureSQLDB) {
			Write-Host "Checking if $ASDBName is eligible for sp_BlitzQueryStore..."
			$DBQuery = @"
			IF ( (SELECT CAST(SERVERPROPERTY('Edition') AS NVARCHAR(128))) = N'SQL Azure' )
			BEGIN
				IF ( (SELECT SERVERPROPERTY ('EngineEdition')) NOT IN (5,8)
					  OR (SELECT [compatibility_level]
						  FROM   sys.[databases]
						  WHERE  [name] = DB_NAME()) < 130 )
				  BEGIN
					  SELECT 'No' AS [EligibleForBlitzQueryStore];
				  END;
				ELSE
				  BEGIN
					  SELECT 'Yes' AS [EligibleForBlitzQueryStore];
				  END;
			END;
		  ELSE
			BEGIN
				SELECT 'Dunno what this is' AS [EligibleForBlitzQueryStore];
			END;
"@
			$CheckDBQuery.CommandText = $DBQuery
		}
		
		$CheckDBQuery.Connection = $SqlConnection
		$CheckDBQuery.CommandTimeout = 100
		$CheckDBAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
		$CheckDBAdapter.SelectCommand = $CheckDBQuery
		$CheckDBSet = new-object System.Data.DataSet
		Try {
			$StepStart = get-date
			$CheckDBAdapter.Fill($CheckDBSet) | Out-Null -ErrorAction Stop
			$SqlConnection.Close()
			if ($CheckDBSet.Tables[0].Rows[0]["EligibleForBlitzQueryStore"] -eq "Yes") {
				if ($IsAzureSQLDB) {
					Write-Host " ->$ASDBName - " -NoNewLine -ErrorAction Stop
				}
				else {
					Write-Host " ->$CheckDB - " -NoNewLine -ErrorAction Stop
				}
				Write-Host "is eligible for sp_BlitzQueryStore" -ErrorAction Stop
				$CheckQueryStore = 'Y'
			}
			elseif ($CheckDBSet.Tables[0].Rows[0]["EligibleForBlitzQueryStore"] -eq "No") {
				$StepEnd = Get-Date
				if ($IsAzureSQLDB) {
					Write-Host " ->$ASDBName - is not eligible for sp_BlitzQueryStore" -NoNewLine -ErrorAction Stop
				}
				else {
					Write-Host " ->$CheckDB - is not eligible for sp_BlitzQueryStore"
				}
				Add-LogRow "sp_BlitzQueryStore" "Skipped" "$CheckDB is not eligible"
			}
			else {
				$StepEnd = Get-Date
				$QSCheckResult = $CheckDBSet.Tables[0].Rows[0]["EligibleForBlitzQueryStore"] 
				Write-Host " ->$ASDBName - is not eligible for sp_BlitzQueryStore" -NoNewLine -ErrorAction Stop
				Add-LogRow "sp_BlitzQueryStore" "Skipped" $QSCheckResult

			}
		}
		Catch {
			$CheckQueryStore = 'N'
			Invoke-ErrMsg
			$StepEnd = Get-Date
			Add-LogRow "sp_BlitzQueryStore precheck" "Failure"

		}
		if ($CheckQueryStore -eq 'Y') {
			[string]$Query = [System.IO.File]::ReadAllText("$ResourcesPath\spBlitzQueryStore_NonSPLatest.sql")

			if ($IsAzureSQLDB) {
				Write-Host " Running sp_BlitzQueryStore for $ASDBName..." -NoNewline
			}
			else {
				if ($DBSwitched -eq "Y") {
					$OldCheckDBStr = ";SET @DatabaseName = NULL;"
					$NewCheckDBStr = ";SET @DatabaseName = '" + $CheckDB + "';"
				}
				Write-Host " Running sp_BlitzQueryStore for $CheckDB..." -NoNewline
				[string]$Query = $Query -replace $OldCheckDBStr, $NewCheckDBStr
			}
			
			$CmdTimeout = $MaxTimeout
			$BlitzQSQuery = new-object System.Data.SqlClient.SqlCommand
			$BlitzQSQuery.CommandText = $Query
			$BlitzQSQuery.CommandTimeout = $CmdTimeout
			$BlitzQSQuery.Connection = $SqlConnection
			$BlitzQSAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
			$BlitzQSAdapter.SelectCommand = $BlitzQSQuery
			$BlitzQSSet = new-object System.Data.DataSet
			Try {
				$StepStart = get-date
				$BlitzQSAdapter.Fill($BlitzQSSet) | Out-Null -ErrorAction Stop
				$SqlConnection.Close()
				$StepEnd = get-date
				Write-Host @GreenCheck
				$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
				$RunTime = [Math]::Round($StepRunTime, 2)
				if ($DebugInfo) {
					Write-Host " - $RunTime seconds" -Fore Yellow
				}
				$StepOutcome = "Success"
				$RecordsReturned = $BlitzQSSet.Tables[0].Rows.Count
				if ($IsAzureSQLDB) {
					Add-LogRow "sp_BlitzQueryStore for $ASDBName" $StepOutcome "$RecordsReturned records returned"
				}
				else {
					Add-LogRow "sp_BlitzQueryStore for $CheckDB" $StepOutcome "$RecordsReturned records returned"
				}
			}
			Catch {
				$StepEnd = get-date
				Invoke-ErrMsg
				$StepOutcome = "Failure"
				if ($IsAzureSQLDB) {
					Add-LogRow "sp_BlitzQueryStore for $ASDBName" $StepOutcome
				}
				else {
					Add-LogRow "sp_BlitzQueryStore for $CheckDB" $StepOutcome
				}
			}

			if ($StepOutcome -eq "Success") {
			
				$BlitzQSTbl = New-Object System.Data.DataTable
				$BlitzQSTbl = $BlitzQSSet.Tables[0]
				$BlitzQSSumTbl = New-Object System.Data.DataTable
				$BlitzQSSumTbl = $BlitzQSSet.Tables[1]
				##Exporting execution plans to file
				if ($DebugInfo) {
					Write-Host " ->Exporting execution plans" -fore yellow
				}
				#Add column to table 
				$BlitzQSTbl.Columns.Add("SQLPlan File", [string]) | Out-Null
				#Set counter used for row retrieval
				$RowNum = 0
				#Setting $i to 0
				$i = 0
				
				foreach ($row in $BlitzQSTbl) {
					#Increment file name counter	
					$i += 1
					$SQLPlanFile = "-- N/A --"
					#Get only the column storing the execution plan data that's not NULL and write it to a file
					if ($BlitzQSTbl.Rows[$RowNum]["query_plan_xml"] -ne [System.DBNull]::Value) {
						$SQLPlanFile = "QueryStore_" + $i + ".sqlplan"
						$BlitzQSTbl.Rows[$RowNum]["query_plan_xml"] | Format-XML | Set-Content -Path "$PlanOutDir\$SQLPlanFile" -Force
					}
					$BlitzQSTbl.Rows[$RowNum]["SQLPlan File"] = $SQLPlanFile		
					#Increment row retrieval counter
					$RowNum += 1
				}
				
				if ($ToHTML -eq "Y") {
					
					#adding query name
					$BlitzQSTbl.Columns.Add("Query", [string]) | Out-Null
					$RowNum = 0
					$i = 0
			
					foreach ($row in $BlitzQSTbl) {
						if ($BlitzQSTbl.Rows[$RowNum]["query_sql_text"] -ne [System.DBNull]::Value) {
							$i += 1
							$QueryName = "QueryStore_" + $i + ".query"
						}
						else { $QueryName = "" }
						$BlitzQSTbl.Rows[$RowNum]["Query"] = $QueryName
						$RowNum += 1
					}
					if ($DebugInfo) {
						Write-Host " ->Converting sp_BlitzQueryStore output to HTML" -fore yellow
					}
					$htmlTable1 = $BlitzQSTbl | Select-Object @{Name = "Database"; Expression = { ($_."database_name") } },
					@{Name = "Query Cost"; Expression = { ($_."query_cost") } },
					@{Name = "PlanID"; Expression = { ($_."plan_id") } },
					@{Name = "QueryID"; Expression = { ($_."query_id") } },
					@{Name = "QueryID all PlanIDs"; Expression = { ($_."query_id_all_plan_ids") } },
					"Query",
					@{Name = "Proc or Function"; Expression = { ($_."proc_or_function_name") } },
					"SQLPlan File",
					@{Name = "Warnings"; Expression = { ($_."warnings") } },
					@{Name = "Pattern"; Expression = { ($_."pattern") } },
					@{Name = "Parameter Sniffing Symptoms"; Expression = { ($_."parameter_sniffing_symptoms") } },
					@{Name = "Top Three Waits"; Expression = { ($_."top_three_waits") } },
					@{Name = "Missing Indexes"; Expression = { ($_."missing_indexes").Replace('ClickMe', '').Replace('<?NoNeedTo -- N/A --?>', '') } },
					@{Name = "Implicit Conversion Info"; Expression = { ($_."implicit_conversion_info").Replace('ClickMe', '').Replace('<?NoNeedTo -- N/A --?>', '') } },
					@{Name = "Cached Exec Parameters"; Expression = { ($_."cached_execution_parameters").Replace('ClickMe', '').Replace('<?NoNeedTo -- N/A --?>', '') } },
					@{Name = "Executions"; Expression = { ($_."count_executions") } },
					@{Name = "Compiles"; Expression = { ($_."count_compiles") } },
					@{Name = "Total CPU Time(ms)"; Expression = { ($_."total_cpu_time") } },
					@{Name = "Avg CPU Time(ms)"; Expression = { ($_."avg_cpu_time") } },
					@{Name = "Total Duration(ms)"; Expression = { ($_."total_duration") } },
					@{Name = "Avg Duration(ms)"; Expression = { ($_."avg_duration") } },
					@{Name = "Total Logical IO Reads MB"; Expression = { ($_."total_logical_io_reads") } },
					@{Name = "Avg Logical IO Reads MB"; Expression = { ($_."avg_logical_io_reads") } },
					@{Name = "Total Physical IO Reads MB"; Expression = { ($_."total_physical_io_reads") } },
					@{Name = "Avg Physical IO Reads MB"; Expression = { ($_."avg_physical_io_reads") } },
					@{Name = "Total Logical IO Writes MB"; Expression = { ($_."total_logical_io_writes") } },
					@{Name = "Avg Logical IO Writes MB"; Expression = { ($_."avg_logical_io_writes") } },
					@{Name = "Total Rows"; Expression = { ($_."total_rowcount") } },
					@{Name = "Avg Rows"; Expression = { ($_."avg_rowcount") } },
					@{Name = "Total Query Max Used Memory MB"; Expression = { ($_."total_query_max_used_memory") } },
					@{Name = "Avg Query Max Used Memory MB"; Expression = { ($_."avg_query_max_used_memory") } },
					@{Name = "Total TempDB Used MB"; Expression = { ($_."total_tempdb_space_used") } },
					@{Name = "Avg TempDB Used MB"; Expression = { ($_."avg_tempdb_space_used") } },
					@{Name = "Total log bytes used"; Expression = { ($_."total_log_bytes_used") } },
					@{Name = "Avg log bytes used"; Expression = { ($_."avg_log_bytes_used") } },
					@{Name = "Total Num Physical IO Reads"; Expression = { ($_."total_num_physical_io_reads") } },
					@{Name = "Avg Num Physical IO Reads"; Expression = { ($_."avg_num_physical_io_reads") } },
					@{Name = "First Exec Time"; Expression = { ($_."first_execution_time").ToString("yyyy-MM-dd HH:mm:ss") } },
					@{Name = "Last Exec Time"; Expression = { ($_."last_execution_time").ToString("yyyy-MM-dd HH:mm:ss") } },
					@{Name = "Last Force Failure Reasson"; Expression = { ($_."last_force_failure_reason_desc") } },
					@{Name = "Context Settings"; Expression = { ($_."context_settings") } } | ConvertTo-Html -As Table -Fragment


					$htmlTable1 = $htmlTable1 -replace '<table>', '<table class="QueryStoreTab">'
					$QExt = '.query'
					$FileSOrder = "QueryStore"
					$AnchorRegex = "$FileSOrder(_\d+)$QExt"
					$AnchorURL = '<a href="#$&">$&</a>'
					$htmlTable1 = $htmlTable1 -replace $AnchorRegex, $AnchorURL

					$htmlTable2 = $BlitzQSSumTbl | Select-Object "Priority", "FindingsGroup", "Finding", "Details", "URL" | ConvertTo-Html -As Table -Fragment
					$htmlTable2 = $htmlTable2 -replace $URLRegex, '<a href="$&" target="_blank">$&</a>'

					$htmlTable3 = $BlitzQSTbl | Select-Object "Query", 
					@{Name = "Query Text"; Expression = { ($_."query_sql_text") } } | ConvertTo-Html -As Table -Fragment
					$AnchorRegex = "<td>$FileSOrder(_\d+)$QExt"
					$AnchorURL = '<td id=' + "$FileSOrder" + '$1' + "$QExt>" + "$FileSOrder" + '$1' + "$QExt"
					$htmlTable3 = $htmlTable3 -replace $AnchorRegex, $AnchorURL

					if ($IsAzureSQLDB) {
						$HtmlTabName = "sp_BlitzQueryStore results for $ASDBName"
					}
					else {
						$HtmlTabName = "sp_BlitzQueryStore results for $CheckDB"
					}
					$html = $HTMLPre + @"
				<title>$HtmlTabName</title>
					</head>
					<body>
					<h1 id="top">$HtmlTabName</h1>
					<br>
					<h2 style="text-align: center;">Query Store results from past 7 days</h2>
					<p style="text-align: center;"><a href="#Queries">Jump to query text</a></p>
					$htmlTable1
					<br>
					<h2 style="text-align: center;">Summary</h2>
					$htmlTable2
					<p style="text-align: center;"><a href="#top">Jump to top</a></p>
					<br>
					<h2 id="Queries" style="text-align: center;">Query text</h2>
					$htmlTable3
					<p style="text-align: center;"><a href="#top">Jump to top</a></p>
					<<br>
					</body>
					</html>
"@
					$html | Out-File -Encoding utf8 -FilePath "$HTMLOutDir\BlitzQueryStore.html"

				}
				else {
					##export to excel
					$ExcelSheet = $ExcelFile.Worksheets.Item("Query Store Info")
					#Specify at which row in the sheet to start adding the data
					$ExcelStartRow = $DefaultStartRow
					#Specify with which column in the sheet to start
					$ExcelColNum = 1
					#Set counter used for row retrieval
					$RowNum = 0

					$DataSetCols = @("Priority", "FindingsGroup", "Finding", "Details", "URL")

					if ($DebugInfo) {
						Write-Host " ->Writing sp_BlitzQueryStore summary to Excel" -fore yellow
					}
					#Loop through each Excel row
					foreach ($row in $BlitzQSSumTbl) {
						foreach ($col in $DataSetCols) {
							if ($col -eq "URL") {
								#Make URLs clickable
								if ($BlitzQSSumTbl.Rows[$RowNum][$col] -like "http*") {
									$ExcelSheet.Hyperlinks.Add($ExcelSheet.Cells.Item($ExcelStartRow, 3),
										$BlitzQSSumTbl.Rows[$RowNum][$col], "", "Click for more info",
										$BlitzQSSumTbl.Rows[$RowNum]["Finding"]) | Out-Null
								}
							}
							else {
								$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $BlitzQSSumTbl.Rows[$RowNum][$col]
							}
							#move to the next column
							$ExcelColNum += 1
						}
				
						#move to the next row in the spreadsheet
						$ExcelStartRow += 1
						#move to the next row in the data set
						$RowNum += 1
						# reset Excel column number so that next row population begins with column 1
						$ExcelColNum = 1
					}
				
					##Saving file 
					$ExcelFile.Save()

					if ($DebugInfo) {
						Write-Host " ->Writing sp_BlitzQueryStore info to Excel" -fore yellow
					}


					$DataSetCols = @("database_name", "query_cost", "plan_id", "query_id", "query_id_all_plan_ids", "query_sql_text",
						"proc_or_function_name", "SQLPlan File", "warnings", "pattern", "parameter_sniffing_symptoms",
						"top_three_waits", "missing_indexes", "implicit_conversion_info", "cached_execution_parameters",
						"count_executions", "count_compiles", "total_cpu_time", "avg_cpu_time", "total_duration", "avg_duration",
						"total_logical_io_reads", "avg_logical_io_reads", "total_physical_io_reads", "avg_physical_io_reads",
						"total_logical_io_writes", "avg_logical_io_writes", "total_rowcount", "avg_rowcount", "total_query_max_used_memory",
						"avg_query_max_used_memory", "total_tempdb_space_used", "avg_tempdb_space_used", "total_log_bytes_used", "avg_log_bytes_used",
						"total_num_physical_io_reads", "avg_num_physical_io_reads", "first_execution_time", "last_execution_time",
						"last_force_failure_reason_desc", "context_settings")
						
					## QS info
					#Specify at which row in the sheet to start adding the data
					$ExcelStartRow = $DefaultStartRow
					#Specify with which column in the sheet to start
					$ExcelColNum = 7
					#Set counter used for row retrieval
					$RowNum = 0
					foreach ($row in $BlitzQSTbl) {
						foreach ($col in $DataSetCols) {
							if ($BlitzQSTbl.Rows[$RowNum][$col] -eq "<?NoNeedToClickMe -- N/A --?>") {
								$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = "   -- N/A --   "
								#move to the next column
								$ExcelColNum += 1
								#move to the top of the loop
								Continue
							}
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $BlitzQSTbl.Rows[$RowNum][$col]
							#move to the next column
							$ExcelColNum += 1
						}

						#move to the next row in the spreadsheet
						$ExcelStartRow += 1
						#move to the next row in the data set
						$RowNum += 1
						#Move to the next sqlplan file
						$SQLPlanNum += 1
						# reset Excel column number so that next row population begins with column 1
						$ExcelColNum = 7
					}
					
				}
				
				Remove-Variable -Name BlitzQSTbl
				Remove-Variable -Name BlitzQSSumTbl
				Remove-Variable -Name BlitzQSSet


			}

		}
		if ($DBSwitched -eq "Y") {
			$StepStart = get-date
			$CheckDB = ""
			$StepEnd = Get-Date
			Add-LogRow "CheckDB value" "Switched" "Switched back to empty from $DBName"
		}
	}
	if ($JobStatus -ne "Running") {
		Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop N
		$BlitzWhoPass += 1
	}

	#####################################################################################
	#						sp_BlitzIndex												#
	#####################################################################################
	#Building a list of values for $Modes
	if ($IsIndepth -eq "Y") {
		$Modes = @("1", "2", "4")
	}
 else {
		$Modes = @("0")
	}
	# Set OldMode variable 
	$OldMode = ";SET @Mode = 0;"
	[string]$Query = [System.IO.File]::ReadAllText("$ResourcesPath\spBlitzIndex_NonSPLatest.sql")
	$CmdTimeout = $MaxTimeout
	#Set specific database to check if a name was provided
	if (!([string]::IsNullOrEmpty($CheckDB))) {
		[string]$Query = $Query -replace $OldCheckDBStr, $NewCheckDBStr
		[string]$Query = $Query -replace ";SET @GetAllDatabases = 1;", ";SET @GetAllDatabases = 0;"
		Write-Host " Running sp_BlitzIndex for $CheckDB"
	}
	elseif ($IsAzureSQLDB) {
		[string]$Query = $Query -replace ";SET @GetAllDatabases = 1;", ";SET @GetAllDatabases = 0;"
		Write-Host " Running sp_BlitzIndex for $ASDBName"
	}
 else {
		Write-Host " Running sp_BlitzIndex for all user databases"
	}
	#Loop through $Modes
	foreach ($Mode in $Modes) {
		Write-Host " ->Running sp_BlitzIndex with @Mode = $Mode... " -NoNewLine
		$NewMode = ";SET @Mode = " + $Mode + ";"
		[string]$Query = $Query -replace $OldMode, $NewMode
		$BlitzIndexQuery = new-object System.Data.SqlClient.SqlCommand
		$BlitzIndexQuery.CommandText = $Query
		$BlitzIndexQuery.CommandTimeout = $CmdTimeout
		$BlitzIndexQuery.Connection = $SqlConnection
		$BlitzIndexAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
		$BlitzIndexAdapter.SelectCommand = $BlitzIndexQuery
		$BlitzIndexSet = new-object System.Data.DataSet
		Try {
			$StepStart = get-date
			$BlitzIndexAdapter.Fill($BlitzIndexSet) | Out-Null -ErrorAction Stop
			$SqlConnection.Close()
			$StepEnd = get-date
			Write-Host @GreenCheck
			$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
			$RunTime = [Math]::Round($StepRunTime, 2)
			if ($DebugInfo) {
				Write-Host " - $RunTime seconds" -Fore Yellow
			}
			$StepOutcome = "Success"
			$RecordsReturned = $BlitzIndexSet.Tables[0].Rows.Count
			Add-LogRow "sp_BlitzIndex mode $Mode" $StepOutcome "$RecordsReturned records returned"
		}
	 Catch {
			$StepEnd = get-date
			Invoke-ErrMsg
			$StepOutcome = "Failure"
			Add-LogRow "sp_BlitzIndex mode $Mode" $StepOutcome
		}
			
		if ($StepOutcome -eq "Success") {
			$BlitzIxTbl = New-Object System.Data.DataTable
			$BlitzIxTbl = $BlitzIndexSet.Tables[0]
			if ("0", "4" -Contains $Mode) {
				#Export sample execution plans for missing indexes (SQL Server 2019 only)
				#Since we're already looping through the result set here, might as well add and
				#populate the plan file name column here
				if ($DebugInfo) {
					Write-Host " ->Exporting missing index sample execution plans (if any)" -fore yellow
				}
				$BlitzIxTbl.Columns.Add("Sample Plan File", [string]) | Out-Null
				$RowNum = 0
				$i = 0
				foreach ($row in $BlitzIxTbl) {
					if ($BlitzIxTbl.Rows[$RowNum]["Finding"] -like "*Missing Index") {
						$SQLPlanFile = "--N/A--"
						$i += 1
						if ($BlitzIxTbl.Rows[$RowNum]["Sample Query Plan"] -ne [System.DBNull]::Value) {
							$SQLPlanFile = "MissingIndex_$i.sqlplan"
							$BlitzIxTbl.Rows[$RowNum]["Sample Query Plan"] | Format-XML | Set-Content -Path "$PlanOutDir\$SQLPlanFile" -Force
						}
						$BlitzIxTbl.Rows[$RowNum]["Sample Plan File"] = $SQLPlanFile
					}
					$RowNum += 1
				}
			}
			if ($ToHTML -eq "Y") {
				if ($DebugInfo) {
					Write-Host " ->Converting sp_BlitzIndex output to HTML" -fore yellow
				}
				if ($Mode -eq "0") {
					$HtmlTabName = "Index Diagnosis"
				}
				elseif ($Mode -eq "1") {
					$HtmlTabName = "Index Summary"
				}
				elseif ($Mode -eq "2") {
					$HtmlTabName = "Index Usage Details"
				}
				elseif ($Mode -eq "4") {
					$HtmlTabName = "Detailed Index Diagnosis"
				}
				if (!([string]::IsNullOrEmpty($CheckDB))) {
					$HtmlTabName += " for $CheckDB" 
				}
				elseif ($IsAzureSQLDB) {
					$HtmlTabName += " for $ASDBName"
				}
		
		
				if ("0", "4" -Contains $Mode) {					
					<#Renaming a column because apparently Select-Object and ConvertTo-HTML can't deal with curly braces or the long column name 
					or whatever regardless of how I try to escape them
					and it's 2AM and I'm done with trying to find elegant ways around this
					#>
					$BlitzIxTbl.Columns["Definition: [Property] ColumnName {datatype maxbytes}"].ColumnName = "Definition"
					$htmlTable = $BlitzIxTbl | Select-Object "Priority", "Finding", "Database Name", 
					"Details: schema.table.index(indexid)",   
					"Definition", 
					"Secret Columns", "Usage", "Size", "More Info", "Create TSQL", "Sample Plan File", "URL" | Where-Object "Finding" -NotLike "sp_BlitzIndex*" | ConvertTo-Html -As Table -Fragment
		
					$htmlTable = $htmlTable -replace $URLRegex, '<a href="$&" target="_blank">$&</a>'
				}
				elseif ($Mode -eq "1") {
					$htmlTable = $BlitzIxTbl | Select-Object "Database Name", "Number Objects", "All GB", 
					"LOB GB", "Row Overflow GB", "Clustered Tables", 
					"Clustered Tables GB", "NC Indexes", "NC Indexes GB", 
					"ratio table: NC Indexes", "Heaps", "Heaps GB", "Partitioned Tables", 
					"Partitioned NCs", "Partitioned GB", "Filtered Indexes", 
					"Indexed Views", "Max Row Count", "Max Table GB", "Max NC Index GB", 
					"Count Tables > 1GB", "Count Tables > 10GB", "Count Tables > 100GB", 
					"Count NCs > 1GB", "Count NCs > 10GB", "Count NCs > 100GB", 
					@{Name = "Oldest Create Date"; Expression = { ($_."Oldest Create Date").ToString("yyyy-MM-dd HH:mm:ss") } }, 
					@{Name = "Most Recent Create Date"; Expression = { ($_."Most Recent Create Date").ToString("yyyy-MM-dd HH:mm:ss") } }, 
					@{Name = "Most Recent Modify Date"; Expression = { ($_."Most Recent Modify Date").ToString("yyyy-MM-dd HH:mm:ss") } } | ConvertTo-Html -As Table -Fragment
				}
				elseif ($Mode -eq "2") {
					$BlitzIxTbl.Columns["Definition: [Property] ColumnName {datatype maxbytes}"].ColumnName = "Definition"
					$htmlTable = $BlitzIxTbl | Select-Object "Database Name", "Schema Name", "Object Name", 
					"Index Name", "Index ID", "Details: schema.table.index(indexid)", 
					"Object Type", "Definition", 
					"Key Column Names With Sort", "Count Key Columns", "Include Column Names", 
					"Count Included Columns", "Secret Column Names", "Count Secret Columns", 
					"Partition Key Column Name", "Filter Definition", "Is Indexed View", 
					"Is Primary Key", "Is XML", "Is Spatial", "Is NC Columnstore", 
					"Is CX Columnstore", "Is Disabled", "Is Hypothetical", "Is Padded", 
					"Fill Factor", "Is Reference by Foreign Key", 
					@{Name = "Last User Seek"; Expression = { ($_."Last User Seek").ToString("yyyy-MM-dd HH:mm:ss") } }, 
					@{Name = "Last User Scan"; Expression = { ($_."Last User Scan").ToString("yyyy-MM-dd HH:mm:ss") } }, 
					@{Name = "Last User Lookup"; Expression = { ($_."Last User Lookup").ToString("yyyy-MM-dd HH:mm:ss") } }, 
					@{Name = "Last User Update"; Expression = { ($_."Last User Update").ToString("yyyy-MM-dd HH:mm:ss") } }, 
					"Total Reads", 
					"User Updates", "Reads Per Write", "Index Usage", "Partition Count", 
					"Rows", "Reserved MB", "Reserved LOB MB", "Reserved Row Overflow MB", 
					"Index Size", "Row Lock Count", "Row Lock Wait Count", "Row Lock Wait ms", 
					"Avg Row Lock Wait ms", "Page Lock Count", "Page Lock Wait Count", 
					"Page Lock Wait ms", "Avg Page Lock Wait ms", "Lock Escalation Attempts", 
					"Lock Escalations", "Page Latch Wait Count", "Page Latch Wait ms", 
					"Page IO Latch Wait Count", "Page IO Latch Wait ms", "Data Compression", 
					@{Name = "Create Date"; Expression = { ($_."Create Date").ToString("yyyy-MM-dd HH:mm:ss") } }, 
					@{Name = "Modify Date"; Expression = { ($_."Modify Date").ToString("yyyy-MM-dd HH:mm:ss") } }, 
					"More Info" | ConvertTo-Html -As Table -Fragment
				}
		
				$html = $HTMLPre + @"
				<title>$HtmlTabName</title>
				</head>
				<body>
				<h1 id="top">$HtmlTabName</h1>
				<br>
				$htmlTable 
				<br>
"@
				if ($Mode -ne "1") {
					$html += @"
					<p><a href="#top">Jump to top</a></p>
"@
				}
				$html += @"
				</body>
				</html>
"@

				if ($DebugInfo) {
					Write-Host " ->Writing HTML file." -fore yellow
				} 
				$html | Out-File -Encoding utf8 -FilePath "$HTMLOutDIr\BlitzIndex_$Mode.html"        
			}
			else {
			
				if($Mode -eq "0"){
					$SheetName = "Index Diagnostics"
				} elseif($Mode -eq "1"){
					$SheetName = "Index Summary"
				} elseif($Mode -eq "2"){
					$SheetName = "Index Usage"
				} elseif($Mode -eq "4"){
					$SheetName = "Extended Index Diagnostics"
				}
			
				#Specify worksheet
				$ExcelSheet = $ExcelFile.Worksheets.Item($SheetName)
				if ("0", "4" -Contains $Mode) {
					$DataSetCols = @("Priority", "Finding", "Database Name", 
						"Details: schema.table.index(indexid)",   
						"Definition: [Property] ColumnName {datatype maxbytes}", 
						"Secret Columns", "Usage", "Size", "More Info", "Create TSQL", "Sample Plan File", "URL")
				}
				elseif ($Mode -eq "1") {
					$DataSetCols = @("Database Name", "Number Objects", "All GB", 
						"LOB GB", "Row Overflow GB", "Clustered Tables", 
						"Clustered Tables GB", "NC Indexes", "NC Indexes GB", 
						"ratio table: NC Indexes", "Heaps", "Heaps GB", "Partitioned Tables", 
						"Partitioned NCs", "Partitioned GB", "Filtered Indexes", 
						"Indexed Views", "Max Row Count", "Max Table GB", "Max NC Index GB", 
						"Count Tables > 1GB", "Count Tables > 10GB", "Count Tables > 100GB", 
						"Count NCs > 1GB", "Count NCs > 10GB", "Count NCs > 100GB", 
						"Oldest Create Date", "Most Recent Create Date", 
						"Most Recent Modify Date")
				}
				elseif ($Mode -eq "2") {
					$DataSetCols = @("Database Name", "Schema Name", "Object Name", 
						"Index Name", "Index ID", "Details: schema.table.index(indexid)", 
						"Object Type", "Definition: [Property] ColumnName {datatype maxbytes}", 
						"Key Column Names With Sort", "Count Key Columns", "Include Column Names", 
						"Count Included Columns", "Secret Column Names", "Count Secret Columns", 
						"Partition Key Column Name", "Filter Definition", "Is Indexed View", 
						"Is Primary Key", "Is XML", "Is Spatial", "Is NC Columnstore", 
						"Is CX Columnstore", "Is Disabled", "Is Hypothetical", "Is Padded", 
						"Fill Factor", "Is Reference by Foreign Key", "Last User Seek", 
						"Last User Scan", "Last User Lookup", "Last User Update", "Total Reads", 
						"User Updates", "Reads Per Write", "Index Usage", "Partition Count", 
						"Rows", "Reserved MB", "Reserved LOB MB", "Reserved Row Overflow MB", 
						"Index Size", "Row Lock Count", "Row Lock Wait Count", "Row Lock Wait ms", 
						"Avg Row Lock Wait ms", "Page Lock Count", "Page Lock Wait Count", 
						"Page Lock Wait ms", "Avg Page Lock Wait ms", "Lock Escalation Attempts", 
						"Lock Escalations", "Page Latch Wait Count", "Page Latch Wait ms", 
						"Page IO Latch Wait Count", "Page IO Latch Wait ms", "Data Compression", 
						"Create Date", "Modify Date", "More Info")
				}
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = $DefaultStartRow
				#Specify starting record from the data set
				$RowNum = 0
				#Specify at which column of the current $initRow of the sheet to start adding the data
				$ExcelColNum = 1

				#Loop through each Excel row
				if ($DebugInfo) {
					Write-Host " ->Writing sp_BlitzIndex results to sheet $SheetName" -fore yellow
				}
				foreach ($row in $BlitzIxTbl) {

					#Loop through each data set column of current row and fill the corresponding 
					# Excel cell
					foreach ($col in $DataSetCols) {
						if ($col -eq "URL") {
							if ($BlitzIxTbl.Rows[$RowNum][$col] -like "http*") {
								$ExcelSheet.Hyperlinks.Add($ExcelSheet.Cells.Item($ExcelStartRow, 2),
									$BlitzIxTbl.Rows[$RowNum][$col], "", "Click for more info",
									$BlitzIxTbl.Rows[$RowNum]["Finding"]) | Out-Null
							}
						}
						else {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $BlitzIxTbl.Rows[$RowNum][$col]
						}
						#move to the next column
						$ExcelColNum += 1
					}

					#move to the next row in the spreadsheet
					$ExcelStartRow += 1
					#move to the next row in the data set
					$RowNum += 1
					# reset Excel column number so that next row population begins with column 1
					$ExcelColNum = 1
					#Exit this loop if $RowNum > 10000
					if ($RowNum -eq 10001) {
						Continue
					}
				}
			
				##Saving file 
				$ExcelFile.Save()
			}
			Remove-Variable -Name BlitzIxTbl
		}
		#Update $OldMode
		$OldMode = $NewMode

		if ($JobStatus -ne "Running") {
			Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop Y
			$BlitzWhoPass += 1
		}
	}
	##Cleaning up variables
	Remove-Variable -Name BlitzIndexSet

	####################################################################
	#						sp_BlitzLock
	####################################################################
	$CurrTime = get-date
	$CurrRunTime = (New-TimeSpan -Start $StartDate -End $CurrTime).TotalMinutes
	if (!([string]::IsNullOrEmpty($CheckDB))) {
		Write-Host " Running sp_BlitzLock for $CheckDB... " -NoNewLine
	}
 elseif ($IsAzureSQLDB) {
		Write-Host " Running sp_BlitzLock for $ASDBName... " -NoNewLine
	}
 else {
		Write-Host " Running sp_BlitzLock for all user databases... " -NoNewLine
	}
	[string]$Query = [System.IO.File]::ReadAllText("$ResourcesPath\spBlitzLock_NonSPLatest.sql")
	$CmdTimeout = $MaxTimeout
	#Set specific database to check if a name was provided
	if (!([string]::IsNullOrEmpty($CheckDB))) {
		[string]$Query = $Query -replace $OldCheckDBStr, $NewCheckDBStr
	}
	#Change date range if execution time so far > 15min
	if ([Math]::Round($CurrRunTime) -gt 15) {
		$CurrMin = [Math]::Round($CurrRunTime)
		Write-Host ""
		Write-Host " ->Current execution time is $CurrMin minutes"
		Write-Host " ->Retrieving deadlock info for the last 7 days instead of 15... " -NoNewLine
		[string]$Query = $Query -replace "@StartDate = DATEADD(DAY,-15, GETDATE()),", "@StartDate = DATEADD(DAY,-7, GETDATE()),"
	}
	$BlitzLockQuery = new-object System.Data.SqlClient.SqlCommand
	$BlitzLockQuery.CommandText = $Query
	$BlitzLockQuery.Connection = $SqlConnection
	$BlitzLockQuery.CommandTimeout = $CmdTimeout
	$BlitzLockAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
	$BlitzLockAdapter.SelectCommand = $BlitzLockQuery
	$BlitzLockSet = new-object System.Data.DataSet
	Try {
		$StepStart = get-date
		$BlitzLockAdapter.Fill($BlitzLockSet) | Out-Null -ErrorAction Stop
		$SqlConnection.Close()
		$StepEnd = get-date
		Write-Host @GreenCheck
		$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
		$RunTime = [Math]::Round($StepRunTime, 2)
		if ($DebugInfo) {
			Write-Host " - $RunTime seconds" -Fore Yellow
		}
		$StepOutcome = "Success"
		Add-LogRow "sp_BlitzLock" $StepOutcome
	}
 Catch {
		$StepEnd = get-date
		Invoke-ErrMsg
		$StepOutcome = "Failure"
		Add-LogRow "sp_BlitzLock" $StepOutcome
	}
		
	if ($StepOutcome -eq "Success") {
		$TblLockDtl = New-Object System.Data.DataTable
		$TblLockPlans = New-Object System.Data.DataTable
		$TblLockOver = New-Object System.Data.DataTable

		$TblLockDtl = $BlitzLockSet.Tables[0]
		$TblLockPlans = $BlitzLockSet.Tables[1]
		$TblLockOver = $BlitzLockSet.Tables[2]
		[int]$RowsReturned = $TblLockDtl.Rows.Count
		if ($RowsReturned -le 0) {
			Write-Host " ->No deadlocks found."
			$StepOutcome = "No deadlocks found"
			Add-LogRow "->sp_BlitzLock" $StepOutcome
		}
		else {
			##Exporting deadlock graphs to file
			#Set counter used for row retrieval
			[int]$RowNum = 0
			#Setting $i to 0
			$i = 0
			if ($DebugInfo) {
				Write-Host " ->Exporting deadlock graphs (if any)" -fore yellow
			}
			$TblLockDtl.Columns.Add("DeadlockGraphFile", [string]) | Out-Null
			foreach ($row in $TblLockDtl) {
				#Increment file name counter
				$i += 1
				<#
			Get only the column storing the deadlock graph data that's not NULL, limit to one export per event by filtering for VICTIM, and write it to a file
			#>
				if (($TblLockDtl.Rows[$RowNum]["deadlock_graph"] -ne [System.DBNull]::Value) -and ($TblLockDtl.Rows[$RowNum]["deadlock_group"] -like "*VICTIM*")) {
					#format the event date to append to file name
					$DLDate = $TblLockDtl.Rows[$RowNum]["event_date"].ToString("yyyyMMdd_HHmmss")
					#write .xdl file
					$TblLockDtl.Rows[$RowNum]["deadlock_graph"] | Format-XML | Set-Content -Path $XDLOutDir\$($DLDate)_$($i).xdl -Force
				}
				#Increment row retrieval counter
				$RowNum += 1
			}

			##Exporting execution plans to file
			if ($DebugInfo) {
				Write-Host " ->Exporting execution plans related to deadlocks." -fore yellow
			}
			$TblLockPlans.Columns.Add("PlanID", [string]) | Out-Null
			$TblLockPlans.Columns.Add("Query", [string]) | Out-Null
			#Set counter used for row retrieval
			$RowNum = 0
			#Setting $i to 0
			$i = 0
			
			foreach ($row in $TblLockPlans) {
				#Increment file name counter	
				$i += 1
				$SQLPlanFile = "-- N/A --"
				$QueryName = "-- N/A --"
				#Get only the column storing the execution plan data that's not NULL and write it to a file
				if ($TblLockPlans.Rows[$RowNum]["query_plan"] -ne [System.DBNull]::Value) {
					$SQLPlanFile = "Deadlock_" + $i + ".sqlplan"
					$QueryName = "DeadlockPlan_" + $i + ".query"
					$TblLockPlans.Rows[$RowNum]["query_plan"] | Format-XML | Set-Content -Path "$PlanOutDir\$SQLPlanFile" -Force
				}
				$TblLockPlans.Rows[$RowNum]["PlanID"] = $SQLPlanFile
				$TblLockPlans.Rows[$RowNum]["Query"] = $QueryName		
				#Increment row retrieval counter
				$RowNum += 1
			}
		
			if ($ToHTML -eq "Y") {
				if ($DebugInfo) {
					Write-Host " ->Converting sp_BlitzLock output to HTML" -fore yellow
				}

				$HtmlTabName = "Deadlocks"
				if (!([string]::IsNullOrEmpty($CheckDB))) {
					$HtmlTabName += " for $CheckDB" 
				}
				elseif ($IsAzureSQLDB) {
					$HtmlTabName += " for $ASDBName"
				}
				$htmlTable1 = $TblLockOver | Select-Object @{Name = "Database"; Expression = { $_."database_name" } }, 
				@{Name = "Object"; Expression = { $_."object_name" } }, 
				@{Name = "Finding Group"; Expression = { $_."finding_group" } }, 
				@{Name = "Finding"; Expression = { $_."finding" } } | Where-Object "database_name" -NotLike "sp_BlitzLock*" | ConvertTo-Html -As Table -Fragment
			
				$htmlTable2 = $TblLockDtl | Select-Object @{Name = "Type"; Expression = { $_."deadlock_type" } }, 
				@{Name = "Event Date"; Expression = { ($_."event_date").ToString("yyyy-MM-dd HH:mm:ss") } },
				@{Name = "Database"; Expression = { $_."database_name" } }, 
				@{Name = "SPID"; Expression = { $_."spid" } },
				@{Name = "Deadlock Group"; Expression = { $_."deadlock_group" } },
				@{Name = "Query"; Expression = { $_."deadlock_group".Replace('Deadlock #', 'DL').Replace(', Query #', 'Q').Replace(' - VICTIM', 'V') + ".query" } },
				@{Name = "Object Names"; Expression = { $_."object_names" } }, 
				@{Name = "Isolation Level"; Expression = { $_."isolation_level" } },
				@{Name = "Owner Mode"; Expression = { $_."owner_mode" } }, 
				@{Name = "Waiter Mode"; Expression = { $_."waiter_mode" } }, 
				@{Name = "Tran Count"; Expression = { $_."transaction_count" } }, 
				@{Name = "Login"; Expression = { $_."login_name" } },
				@{Name = "Host Name"; Expression = { $_."host_name" } }, 
				@{Name = "Client App"; Expression = { $_."client_app" } }, 
				@{Name = "Wait Time"; Expression = { $_."wait_time" } }, 
				@{Name = "Wait Resource"; Expression = { $_."wait_resource" } }, 
				@{Name = "Priority"; Expression = { $_."priority" } }, 
				@{Name = "Log Used"; Expression = { $_."log_used" } }, 
				@{Name = "Last Tran Start"; Expression = { ($_."last_tran_started").ToString("yyyy-MM-dd HH:mm:ss") } }, 
				@{Name = "Last Batch Start"; Expression = { ($_."last_batch_started").ToString("yyyy-MM-dd HH:mm:ss") } },
				@{Name = "Last Batch Completed"; Expression = { ($_."last_batch_completed").ToString("yyyy-MM-dd HH:mm:ss") } },	
				@{Name = "Tran Name"; Expression = { $_."transaction_name" } } | ConvertTo-Html -As Table -Fragment

				$QExt = '.query'
				$AnchorRegex = "DL(\d+)Q(\d+)V{0,}$QExt"
				$AnchorURL = '<a href="#$&">$&</a>'
				$htmlTable2 = $htmlTable2 -replace $AnchorRegex, $AnchorURL

				$htmlTable3 = $TblLockDtl | 
				Select-Object @{Name = "Query"; Expression = { $_."deadlock_group".Replace('Deadlock #', 'DL').Replace(', Query #', 'Q').Replace(' - VICTIM', 'V') + ".query" } },
				@{Name = "Query Text"; Expression = { $_."query" } } | ConvertTo-Html -As Table -Fragment
				$AnchorRegex = "<td>DL(\d+)Q(\d+)(V{0,})$QExt"
				$AnchorURL = '<td id=' + "DL" + '$1' + "Q" + '$2' + '$3' + "$QExt>" + "DL" + '$1' + "Q" + '$2' + '$3' + "$QExt"
				$htmlTable3 = $htmlTable3 -replace $AnchorRegex, $AnchorURL

				$htmlTable4 = $TblLockPlans | Select-Object @{Name = "Database"; Expression = { $_."database_name" } },
				"Query", @{Name = "SQLPlan File"; Expression = { $_."PlanID" } },
				@{Name = "Created At"; Expression = { ($_."creation_time").ToString("yyyy-MM-dd HH:mm:ss") } },
				@{Name = "Last Execution"; Expression = { ($_."last_execution_time").ToString("yyyy-MM-dd HH:mm:ss") } },
				@{Name = "Executions"; Expression = { $_."execution_count" } },
				@{Name = "Executions / Second"; Expression = { $_."executions_per_second" } },
				@{Name = "Total Worker Time(ms)"; Expression = { $_."total_worker_time_ms" } },
				@{Name = "Avg Worker Time(ms)"; Expression = { $_."avg_worker_time_ms" } },
				@{Name = "Total Duration(ms)"; Expression = { $_."total_elapsed_time_ms" } },
				@{Name = "Avg Duration(ms)"; Expression = { $_."avg_elapsed_time_ms" } },
				@{Name = "Total Logical Reads(MB)"; Expression = { $_."total_logical_reads_mb" } },
				@{Name = "Total Physical Reads(MB)"; Expression = { $_."total_physical_reads_mb" } },
				@{Name = "Total Logical Writes(MB)"; Expression = { $_."total_logical_writes_mb" } },
				@{Name = "Min Grant(MB)"; Expression = { $_."min_grant_mb" } },
				@{Name = "Max Grant(MB)"; Expression = { $_."max_grant_mb" } },
				@{Name = "Min Used Grant(MB)"; Expression = { $_."min_used_grant_mb" } },
				@{Name = "Max Used Grant(MB)"; Expression = { $_."max_used_grant_mb" } },
				@{Name = "Min Reserved Threads"; Expression = { $_."min_reserved_threads" } },
				@{Name = "Max Reserved Threads"; Expression = { $_."max_reserved_threads" } },
				@{Name = "Min Used Threads"; Expression = { $_."min_used_threads" } },
				@{Name = "Max Used Threads"; Expression = { $_."max_used_threads" } },
				@{Name = "Total Rows"; Expression = { $_."total_rows" } } | ConvertTo-Html -As Table -Fragment
				$QExt = '.query'
				$FileSOrder = "DeadlockPlan"
				$AnchorRegex = "$FileSOrder(_\d+)$QExt"
				$AnchorURL = '<a href="#$&">$&</a>'
				$htmlTable4 = $htmlTable4 -replace $AnchorRegex, $AnchorURL

				$htmlTable5 = $TblLockPlans | Select-Object "Query",
				@{Name = "Query Text"; Expression = {$_."query_text".Replace('<?query ','').Replace('   ?>','')}} | ConvertTo-Html -As Table -Fragment
				$AnchorRegex = "<td>$FileSOrder(_\d+)$QExt"
				$AnchorURL = '<td id=' + "$FileSOrder" + '$1' + "$QExt>" + "$FileSOrder" + '$1' + "$QExt"
				$htmlTable5 = $htmlTable5 -replace $AnchorRegex, $AnchorURL
		
				$html = $HTMLPre + @"
		<title>$HtmlTabName</title>
		</head>
		<body>
		<h1 id="top">$HtmlTabName</h1>
		<h2 style="text-align: center;">Deadlock Overview</h2>
		<p style="text-align: center;"><a href="#Deadlocks1">Jump to deadlock details</a></p>
"@
				if ($TblLockPlans.Rows.Count -gt 0) {
					$html += @"
		<p style="text-align: center;"><a href="#Deadlocks2">Jump to execution plans</a></p>
"@
				}
				$html += @"
		$htmlTable1
		<p style="text-align: center;"><a href="#top">Jump to top</a></p>
		<br>
		<h2 id="Deadlocks1" style="text-align: center;">Deadlock Details</h2>
		$htmlTable2
		<p style="text-align: center;"><a href="#top">Jump to top</a></p>
		<br>
		<h2 style="text-align: center;">Query Text</h2>
		$htmlTable3
		<p style="text-align: center;"><a href="#top">Jump to top</a></p>
"@
				if ($TblLockPlans.Rows.Count -gt 0) {
					$html += @"
	    <br>
		<h2 id="Deadlocks2" style="text-align: center;">Execution Plans Involved in Deadlocks</h2>
		$htmlTable4
		<p style="text-align: center;"><a href="#top">Jump to top</a></p>
		<br>
		<h2 style="text-align: center;">Query Text For Execution Plans Involved in Deadlocks</h2>
		$htmlTable5
		<p style="text-align: center;"><a href="#top">Jump to top</a></p>
		<br>
		</body>
		</html>
"@
				}
				else {
					$html += @"
				<br>
				</body>
				</html>
"@
				}
				if ($DebugInfo) {
					Write-Host " - >Writing HTML file." -fore yellow
				}
				if ($TblLockDtl.Rows.Count -gt 0) {
					$html | Out-File -Encoding utf8 -FilePath "$HTMLOutDir\BlitzLock.html"
				}
			}
			else {
				## populating the "sp_BlitzLock Details" sheet
				$ExcelSheet = $ExcelFile.Worksheets.Item("Deadlock Details")
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = $DefaultStartRow
				#Specify with which column in the sheet to start
				$ExcelColNum = 1
				#Set counter used for row retrieval
				$RowNum = 0

				#List of columns that should be returned from the data set
				$DataSetCols = @("deadlock_type", "event_date", "database_name", "spid",
					"deadlock_group", "query", "object_names", "isolation_level",
					"owner_mode", "waiter_mode", "transaction_count", "login_name",
					"host_name", "client_app", "wait_time", "wait_resource", 
					"priority", "log_used", "last_tran_started", "last_batch_started",
					"last_batch_completed",	"transaction_name")
				if ($DebugInfo) {
					Write-Host " ->Writing sp_BlitzLock Details to Excel" -fore yellow
				}
				#Loop through each Excel row
				foreach ($row in $TblLockDtl) {
					<#
				Loop through each data set column of current row and fill the corresponding 
				 Excel cell
				 #>
					foreach ($col in $DataSetCols) {
						#Fill Excel cell with value from the data set
						$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $TblLockDtl.Rows[$RowNum][$col]
						#move to the next column
						$ExcelColNum += 1
					}

					#move to the next row in the spreadsheet
					$ExcelStartRow += 1
					#move to the next row in the data set
					$RowNum += 1
					# reset Excel column number so that next row population begins with column 1
					$ExcelColNum = 1
				}

				##Saving file 
				$ExcelFile.Save()

				## populating the "sp_BlitzLock Overview" sheet
				$ExcelSheet = $ExcelFile.Worksheets.Item("Deadlock Overview")
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = $DefaultStartRow
				#Specify with which column in the sheet to start
				$ExcelColNum = 1
				#Set counter used for row retrieval
				$RowNum = 0

				#List of columns that should be returned from the data set
				$DataSetCols = @("database_name", "object_name", "finding_group", "finding")

				if ($DebugInfo) {
					Write-Host " ->Writing sp_BlitzLock Overview to Excel" -fore yellow
				}
				#Loop through each Excel row
				foreach ($row in $TblLockOver) {
					<#
				Loop through each data set column of current row and fill the corresponding 
				 Excel cell
				 #>
					foreach ($col in $DataSetCols) {
						#Fill Excel cell with value from the data set
						
						$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $TblLockOver.Rows[$RowNum][$col]
						#move to the next column
						$ExcelColNum += 1
					}

					#move to the next row in the spreadsheet
					$ExcelStartRow += 1
					#move to the next row in the data set
					$RowNum += 1
					# reset Excel column number so that next row population begins with column 1
					$ExcelColNum = 1
				}

				##Saving file 
				$ExcelFile.Save()

				## populating the "sp_BlitzLock Plans" sheet
				$ExcelSheet = $ExcelFile.Worksheets.Item("Deadlock Plans")
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = $DefaultStartRow
				#Specify with which column in the sheet to start
				$ExcelColNum = 1
				#Set counter used for row retrieval
				$RowNum = 0
				#Set counter for sqlplan file names
				$SQLPlanNum = 1

				#List of columns that should be returned from the data set
				$DataSetCols = @("database_name", "query_text", "PlanID", "creation_time",
				 "last_execution_time", "execution_count",
					"executions_per_second", "total_worker_time_ms",
				 "avg_worker_time_ms", "total_elapsed_time_ms",
					"avg_elapsed_time", "total_logical_reads_mb", 
					"total_physical_reads_mb", "total_logical_writes_mb", 
					"min_grant_mb", "max_grant_mb", "min_used_grant_mb", "max_used_grant_mb", 
					"min_reserved_threads", "max_reserved_threads", "min_used_threads",
					"max_used_threads", "total_rows")
				if ($DebugInfo) {
					Write-Host " ->Writing sp_BlitzLock Plans to Excel" -fore yellow
				}
				#Loop through each Excel row
				foreach ($row in $TblLockPlans) {
					foreach ($col in $DataSetCols) {
						#Fill Excel cell with value from the data set
						if($col -eq "query_text"){
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $TblLockPlans.Rows[$RowNum][$col].Replace('<?query ','').Replace('   ?>','')
						} else {
						$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $TblLockPlans.Rows[$RowNum][$col]
						}
						#move to the next column
						$ExcelColNum += 1

					}

					#move to the next row in the spreadsheet
					$ExcelStartRow += 1
					#move to the next row in the data set
					$RowNum += 1
					# reset Excel column number so that next row population begins with column 1
					$ExcelColNum = 1
				}

				##Saving file 
				$ExcelFile.Save()
			}
			##Cleaning up variables
			Remove-Variable -Name TblLockOver
			Remove-Variable -Name TblLockDtl
			Remove-Variable -Name TblLockPlans
			Remove-Variable -Name BlitzLockSet
		}
	}

	if ($JobStatus -ne "Running") {
		Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop N
		$BlitzWhoPass += 1
	}


	#####################################################################################
	#						Stats & Index info											#
	#####################################################################################

	<#
		if db was switched for querystore we can switch it again without doing all the math again
	#>
	if ($DBSwitched -eq "Y") {
		Write-Host " $DBName accounts for at least 2/3 of the records returned by sp_BlitzCache"
		$StepStart = get-date
		Write-Host " ->" -NoNewline
		[string]$CheckDB = $DBName
		$DBSwitched = "Y"
		$StepEnd = get-date
		Add-LogRow "CheckDB value" "Switched" "$DBName accounts for at least 2/3 of the records returned by sp_BlitzCache"
	}
	
	#Only run the check if a specific database name has been provided
	if ((!([string]::IsNullOrEmpty($CheckDB))) -or ($IsAzureSQLDB)) {
		if ($DBSwitched -ne "Y") {
			Write-Host " " -NoNewLine
		}
		[string]$Query = [System.IO.File]::ReadAllText("$ResourcesPath\GetStatsInfoForWholeDB.sql")
		if ($IsAzureSQLDB) {
			Write-Host "Getting stats info for $ASDBName... " -NoNewLine
			#if it's Azure SQL DB, we can't switch databases
			[string]$Query = $Query.replace('USE [..PSBlitzReplace..];', '')
		}
		else {
			Write-Host "Getting stats info for $CheckDB... " -NoNewLine		
			[string]$Query = $Query -replace "..PSBlitzReplace.." , $CheckDB
		}
		$CmdTimeout = $MaxTimeout

		$StatsQuery = new-object System.Data.SqlClient.SqlCommand
		$StatsQuery.CommandText = $Query
		$StatsQuery.Connection = $SqlConnection
		$StatsQuery.CommandTimeout = $CmdTimeout
		$StatsAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
		$StatsAdapter.SelectCommand = $StatsQuery
		$StatsSet = new-object System.Data.DataSet
		Try {
			$StepStart = get-date
			$StatsAdapter.Fill($StatsSet) | Out-Null -ErrorAction Stop
			$SqlConnection.Close()
			$StepEnd = get-date
			Write-Host @GreenCheck
			$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
			$RunTime = [Math]::Round($StepRunTime, 2)
			if ($DebugInfo) {
				Write-Host " - $RunTime seconds" -Fore Yellow
			}
			$StepOutcome = "Success"
			$RecordsReturned = $StatsSet.Tables[0].Rows.Count
			Add-LogRow "Stats Info" $StepOutcome "$RecordsReturned records returned"
		}
	 Catch {
			$StepEnd = get-date
			Invoke-ErrMsg
			$StepOutcome = "Failure"
			Add-LogRow "Stats Info" $StepOutcome
		}
			
		if ($StepOutcome -eq "Success") {
			$StatsTbl = New-Object System.Data.DataTable
			$StatsTbl = $StatsSet.Tables[0]
			[int]$RowsReturned = $StatsTbl.Rows.Count
			if ($RowsReturned -le 0) {
				Write-Host " ->No rows returned."
				Add-LogRow "->Stats Info" "No rows returned"
			}
			else {


				if ($ToHTML -eq "Y") {
					if ($DebugInfo) {
						Write-Host " ->Converting stats info to HTML" -fore yellow
					}
					$htmlTable = $StatsTbl | Select-Object @{Name = "Database"; Expression = { $_."database" } },
					@{Name = "Object Name"; Expression = { $_."object_name" } },
					@{Name = "Object Type"; Expression = { $_."object_type" } },
					@{Name = "Stats Name"; Expression = { $_."stats_name" } },
					@{Name = "Origin"; Expression = { $_."origin" } },
					@{Name = "Filter Definition"; Expression = { $_."filter_definition" } },
					@{Name = "Last Updated"; Expression = { ($_."last_updated").ToString("yyyy-MM-dd HH:mm:ss") } },
					@{Name = "Rows"; Expression = { $_."rows" } },
					@{Name = "Unfiltered Rows"; Expression = { $_."unfiltered_rows" } },
					@{Name = "Rows Sampled"; Expression = { $_."rows_sampled" } },
					@{Name = "Sample %"; Expression = { $_."sample_percent" } },
					@{Name = "Modifications Count"; Expression = { $_."modification_counter" } },
					@{Name = "Modified %"; Expression = { $_."modified_percent" } },
					@{Name = "Steps"; Expression = { $_."steps" } },
					@{Name = "Incremental"; Expression = { $_."incremental" } },
					@{Name = "Temporary"; Expression = { $_."temporary" } },
					@{Name = "With NORECOMPUTE"; Expression = { $_."no_recompute" } },
					@{Name = "Persisted Sample"; Expression = { $_."persisted_sample" } },
					@{Name = "Persisted Sample %"; Expression = { $_."persisted_sample_percent" } },
					@{Name = "Partitioned"; Expression = { $_."partitioned" } },
					@{Name = "Partition No."; Expression = { $_."partition_number" } },
					@{Name = "Get Stats Details"; Expression = { $_."get_details" } },
					@{Name = "Update Table Stats"; Expression = { $_."update_table_stats" } },
					@{Name = "Update Individual Stats"; Expression = { $_."update_individual_stats" } },
					@{Name = "Update Partition Stats"; Expression = { $_."update_partition_stats" } } | ConvertTo-Html -As Table -Fragment
					if ($IsAzureSQLDB) {
						$HtmlTabName = "Statistics info for $ASDBName"
					}
					else {
						$HtmlTabName = "Statistics info for $CheckDB"
					}
					$html = $HTMLPre + @"
				<title>$HtmlTabName</title>
				</head>
				<body>
				<h1>$HtmlTabName</h1>
				$htmlTable
				</body>
				</html>
"@
					if ($DebugInfo) {
						Write-Host " - >Writing HTML file." -fore yellow
					}
					if ($IsAzureSQLDB) {
						$html | Out-File -Encoding utf8 -FilePath "$HTMLOutDir\StatsInfo_$ASDBName.html"
					}
					else {
						$html | Out-File -Encoding utf8 -FilePath "$HTMLOutDir\StatsInfo_$CheckDB.html"
					}
				
				
				}
				else {

					$ExcelSheet = $ExcelFile.Worksheets.Item("Statistics Info")
					$ExcelStartRow = $DefaultStartRow
					$ExcelColNum = 1
					$RowNum = 0
					$DataSetCols = @("database", "object_name", "object_type", "stats_name", "origin", 
						"filter_definition", "last_updated", "rows", "unfiltered_rows", 
						"rows_sampled", "sample_percent", "modification_counter", 
						"modified_percent", "incremental", "temporary", "no_recompute", "persisted_sample",
						"persisted_sample_percent", "steps", "partitioned", "partition_number",
						"get_details", "update_table_stats", "update_individual_stats", "update_partition_stats")

					if ($DebugInfo) {
						Write-Host " ->Writing Stats results to sheet Statistics Info" -fore yellow
					}

					foreach ($row in $StatsTbl) {
						foreach ($col in $DataSetCols) {
							if ($col -eq "last_updated") {
								$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $StatsTbl.Rows[$RowNum][$col].ToString("yyyy-MM-dd HH:mm:ss")
							}
							else {
								$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $StatsTbl.Rows[$RowNum][$col]
							}
							$ExcelColNum += 1
						}
						$ExcelStartRow += 1
						$RowNum += 1
						$ExcelColNum = 1
					}


					##Saving file
					$ExcelFile.Save()
				}
			}
			##Cleaning up variables
			Remove-Variable -Name StatsTbl
			Remove-Variable -Name StatsSet
		
		}

		if ($JobStatus -ne "Running") {
			Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop N
			$BlitzWhoPass += 1
		}
		### get index frag info
		[string]$Query = [System.IO.File]::ReadAllText("$ResourcesPath\GetIndexInfoForWholeDB.sql")
		if ($DBSwitched -ne "Y") {
			Write-Host " " -NoNewLine
		}
		elseif ($DBSwitched -eq "Y") {
			Write-Host " ->" -NoNewLine
		}
		if ($IsAzureSQLDB) { 
			Write-Host "Getting index fragmentation info for $ASDBName... " -NoNewLine
			#if it's Azure SQL DB, we can't switch databases
			[string]$Query = $Query.replace('USE [..PSBlitzReplace..];', '')
			[string]$Query = $Query -replace "AzureSQLDBReplace", "$DirDate"
		}
		else {
			Write-Host "Getting index fragmentation info for $CheckDB... " -NoNewLine
		
			[string]$Query = $Query -replace "..PSBlitzReplace.." , $CheckDB
		}
		$CmdTimeout = $MaxTimeout

		$IndexQuery = new-object System.Data.SqlClient.SqlCommand
		$IndexQuery.CommandText = $Query
		$IndexQuery.Connection = $SqlConnection
		$IndexQuery.CommandTimeout = $CmdTimeout
		$IndexAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
		$IndexAdapter.SelectCommand = $IndexQuery
		$IndexSet = new-object System.Data.DataSet
		Try {
			$StepStart = get-date
			$IndexAdapter.Fill($IndexSet) | Out-Null -ErrorAction Stop
			$SqlConnection.Close()
			$StepEnd = get-date
			Write-Host @GreenCheck
			$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
			$RunTime = [Math]::Round($StepRunTime, 2)
			if ($DebugInfo) {
				Write-Host " - $RunTime seconds" -Fore Yellow
			}
			$StepOutcome = "Success"
			$RecordsReturned = $IndexSet.Tables[0].Rows.Count
			Add-LogRow "Index Frag Info" $StepOutcome "$RecordsReturned records returned"
		}
	 Catch {
			$StepEnd = get-date
			Invoke-ErrMsg
			$StepOutcome = "Failure"
			Add-LogRow "Index Frag Info" $StepOutcome
		}
			
		if ($StepOutcome -eq "Success") {

			$IndexTbl = New-Object System.Data.DataTable
			$IndexTbl = $IndexSet.Tables[0]
			if ($IndexTbl.Columns[0].ColumnName -eq "xlocked") {
				$RowNum = 0
				Write-Host " ->Exclusive lock detected on table(s):"
				$LockedTabList = ""
				$LockedTabLogMsg = "Exclusive locks on table(s):"
				foreach ($row in $IndexTbl) {
					$LockedTab = $IndexTbl.Rows[$RowNum]["object_name"]
					Write-Host "  - $LockedTab"
					if ($RowNum -eq 0) { 
						$LockedTabList += "$LockedTab" 
					}
					else {
						$LockedTabList += ", $LockedTab"
					}
					$RowNum += 1
				}
				Write-Host " ->Index fragmentation check has been skipped."
				Add-LogRow "->Index Frag Info" "Skipped" "$LockedTabLogMsg $LockedTabList"
			}
			else {
				[int]$RowsReturned = $IndexTbl.Rows.Count
				if ($RowsReturned -le 0) {
					Write-Host " ->No rows returned."
					Add-LogRow "->Index Frag Info" "No rows returned."
				}
				else {

					if ($ToHTML -eq "Y") {
				
						if ($DebugInfo) {
							Write-Host " ->Converting index info to HTML" -fore yellow
						}
						$htmlTable = $IndexTbl | Select-Object @{Name = "Database"; Expression = { $_."database" } },
						@{Name = "Object Name"; Expression = { $_."object_name" } },
						@{Name = "Object Type"; Expression = { $_."object_type" } },
						@{Name = "Index Name"; Expression = { $_."index_name" } }, 
						@{Name = "Index Type"; Expression = { $_."index_type" } }, 
						@{Name = "Avg. Frag. %"; Expression = { $_."avg_frag_percent" } },
						@{Name = "Page Count"; Expression = { $_."page_count" } },
						@{Name = "Size in GB"; Expression = { $_."size_in_GB" } },
						@{Name = "Record Count"; Expression = { $_."record_count" } } | ConvertTo-Html -As Table -Fragment
						if ($IsAzureSQLDB) {
							$HtmlTabName = "Index fragmentation info for $ASDBName"
						}
						else {
							$HtmlTabName = "Index fragmentation info for $CheckDB"
						}
			
						$html = $HTMLPre + @"
				<title>$HtmlTabName</title>
				</head>
				<body>
				<h1>$HtmlTabName</h1>
				$htmlTable
				</body>
				</html>
"@
						if ($DebugInfo) {
							Write-Host " - >Writing HTML file." -fore yellow
						} 
						if ($IsAzureSQLDB) {
							$html | Out-File -Encoding utf8 -FilePath "$HTMLOutDir\IndexFragInfo_$ASDBName.html"
						}
						else {
							$html | Out-File -Encoding utf8 -FilePath "$HTMLOutDir\IndexFragInfo_$CheckDB.html"
						}
						
					}
					else {

				
						$ExcelSheet = $ExcelFile.Worksheets.Item("Index Fragmentation")
						$ExcelStartRow = $DefaultStartRow
						$ExcelColNum = 1
						$RowNum = 0
						$DataSetCols = @("database", "object_name", "object_type", "index_name", 
							"index_type", "avg_frag_percent", "page_count", "size_in_GB", "record_count")

						if ($DebugInfo) {
							Write-Host " ->Writing Stats results to sheet Index Fragmentation" -fore yellow
						}

						foreach ($row in $IndexTbl) {
							foreach ($col in $DataSetCols) {
								$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $IndexTbl.Rows[$RowNum][$col]
								$ExcelColNum += 1
							}
							$ExcelStartRow += 1
							$RowNum += 1
							$ExcelColNum = 1
						}

						##Saving file
						$ExcelFile.Save()
					}
					##Cleaning up variables
					Remove-Variable -Name IndexTbl
					Remove-Variable -Name IndexSet

				}
			}
		}
	

		if ($JobStatus -ne "Running") {
			Invoke-BlitzWho -BlitzWhoQuery $BlitzWhoRepl -IsInLoop N
			$BlitzWhoPass += 1
		}

		if ($DBSwitched -eq "Y") {
			$StepStart = get-date
			$CheckDB = ""
			$StepEnd = Get-Date
			Add-LogRow "CheckDB value" "Switched" "Switched back to empty from $DBName"
		}
	}

	$TryCompleted = "Y"
}

finally {
	if ($TryCompleted -eq "N") {
		Write-Host ""
		Write-Host " Script execution was interrupted." -Fore yellow
		Write-Host " ->Latest exception (if any):"
		Invoke-ErrMsg
		Add-LogRow "PSBlitz Execution" "Interrupted"
		Write-Host " Finishing up..." -Fore yellow
	}
	
	#####################################################################################
	#						sp_BlitzWho													#
	#####################################################################################
	###Create flag table to stop the job
	if ($JobStatus -eq "Running") {
		#Make sure the current state of the job is still Running
		$JobStatus = Get-Job -Name $JobName | Select-Object -ExpandProperty State
		if ($JobStatus -eq "Running") {
			if ($TryCompleted -eq "N") {
				Write-Host " Attempting to stop $JobName background process... " -NoNewline
			}
			else {
				Write-Host " Stopping $JobName background process... " -NoNewline
			}
			$CreatFlagTbl = "DECLARE @SQL NVARCHAR(400);`nSELECT @SQL = N'CREATE TABLE '+ CASE "
			$CreatFlagTbl += "`nWHEN CAST(SERVERPROPERTY('Edition') AS NVARCHAR(100)) = N'SQL Azure' "
			$CreatFlagTbl += "`nAND SERVERPROPERTY('EngineEdition') IN (5, 6) "
			$CreatFlagTbl += "`nTHEN N'[BlitzWhoOutFlag_$DirDate](ID INT);' "
			$CreatFlagTbl += "`nELSE N'[tempdb].[dbo].[BlitzWhoOutFlag_$DirDate](ID INT);' `nEND; `nEXEC(@SQL);"
			$CreatFlagTblCommand = new-object System.Data.SqlClient.SqlCommand
			$CreatFlagTblCommand.CommandText = $CreatFlagTbl
			$CreatFlagTblCommand.CommandTimeout = 30
			Try {
				$StepStart = Get-Date
				$SqlConnection.Open() | Out-Null -ErrorAction Stop
				$CreatFlagTblCommand.Connection = $SqlConnection
				$CreatFlagTblCommand.ExecuteNonQuery() | Out-Null -ErrorAction Stop
				$SqlConnection.Close()
				$FlagCreated = "Y"
				if ($DebugInfo) {
					Write-Host ""
					Write-Host " ->Flag Table created" -Fore Yellow
				}
				$StepOutcome = "Success"
				$StepEnd = Get-Date
				Add-LogRow "BlitzWho Flag table creation" $StepOutcome
			}
			Catch {
				$StepEnd = Get-Date
				$JobOutcome = Stop-Job $JobName
				Write-Host $JobOutcome 
				$JobOutcome | Out-File utf8 -FilePath "$OutDir\sp_BlitzWhoBackgroundJobLog.txt" -Append
				if ($DebugInfo) {
					Write-Host ""
					Write-Host " ->Failed to create " -NoNewline -Fore Yellow
					if ($IsAzureSQLDB) {
						Write-Host "[BlitzWhoOutFlag_$DirDate]" -Fore Yellow
					}
					else {
						Write-Host "[tempdb].[dbo].[BlitzWhoOutFlag_$DirDate]" -Fore Yellow
					}
					Write-Host " ->Forcing background process stop." -Fore Yellow
					
				}
				$StepOutcome = "Failure"
				Add-LogRow "BlitzWho Flag table creation" $StepOutcome
			}
			if ($FlagCreated -eq "Y") {
				$BlitzWhoDelay += 10
				Start-Sleep -Seconds $BlitzWhoDelay
				if ($DebugInfo) {
					Write-Host " ->Waiting for $BlitzWhoDelay seconds before getting job output." -Fore Yellow
				}
			}
			$JobStatus = Get-Job -Name $JobName | Select-Object -ExpandProperty State
			if ($JobStatus -ne "Running") {
				if ($DebugInfo) {
					Write-Host " ->$JobName process no longer running " -NoNewline -Fore Yellow
				}
				Write-Host @GreenCheck
				if ($DebugInfo) {
					Write-Host ""
				}
				$JobOutcome = Receive-Job -Name $JobName
				Write-Host $JobOutcome
				$JobOutcome | Out-File utf8 -FilePath "$OutDir\sp_BlitzWhoBackgroundJobLog.txt" -Append
				Add-LogRow "sp_BlitzWho background process" $JobStatus $JobOutcome
				#temp lines(2)
				#Write-Host $JobName.JobStateInfo.Reason.Message
				#Write-Host $JobName.Error
				Remove-Job -Name $JobName -Force
			}

		}
	}
	if ($TryCompleted -eq "N") {
		Write-Host	" Attempting to retrieve sp_BlitzWho data... " -NoNewLine
	}
	else {
		Write-Host " Retrieving sp_BlitzWho data... " -NoNewLine
	}
	[string]$Query = [System.IO.File]::ReadAllText("$ResourcesPath\GetBlitzWhoData.sql")
	[string]$Query = $Query -replace "BlitzWho_..BlitzWhoOut.." , "BlitzWho_$DirDate"
	[string]$Query = $Query -replace "BlitzWhoOutFlag_..BlitzWhoOut.." , "BlitzWhoOutFlag_$DirDate"
	if ($IsAzureSQLDB) {
		[string]$Query = $Query.replace('[tempdb].[dbo].', '')
		[string]$Query = $Query.replace('tempdb.dbo.', '')
	}
	$CmdTimeout = 800
	if (!([string]::IsNullOrEmpty($CheckDB))) {
		[string]$Query = $Query -replace "SET @DatabaseName = N''; " , "SET @DatabaseName = N'$CheckDB'; "
	}
	$BlitzWhoSelect = new-object System.Data.SqlClient.SqlCommand
	$BlitzWhoSelect.CommandText = $Query
	$BlitzWhoSelect.Connection = $SqlConnection
	$BlitzWhoSelect.CommandTimeout = $CmdTimeout 
	$BlitzWhoAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
	$BlitzWhoAdapter.SelectCommand = $BlitzWhoSelect
	$BlitzWhoSet = new-object System.Data.DataSet
	Try {
		$StepStart = get-date
		$BlitzWhoAdapter.Fill($BlitzWhoSet) | Out-Null -ErrorAction Stop
		$SqlConnection.Close()
		$StepEnd = get-date
		Write-Host @GreenCheck
		$StepRunTime = (New-TimeSpan -Start $StepStart -End $StepEnd).TotalSeconds
		$RunTime = [Math]::Round($StepRunTime, 2)
		if ($DebugInfo) {
			Write-Host " - $RunTime seconds" -Fore Yellow
		}
		$StepOutcome = "Success"
		Add-LogRow "Return sp_BlitzWho" $StepOutcome
	}
 Catch {
		$StepEnd = get-date
		Invoke-ErrMsg
		$StepOutcome = "Failure"
		Add-LogRow "Return sp_BlitzWho" $StepOutcome
	}
		
	if ($StepOutcome -eq "Success") {
		$BlitzWhoTbl = New-Object System.Data.DataTable
		$BlitzWhoTbl = $BlitzWhoSet.Tables[0]
		$BlitzWhoAggTbl = New-Object System.Data.DataTable
		$BlitzWhoAggTbl = $BlitzWhoSet.Tables[1]
		[int]$RowsReturned = $BlitzWhoTbl.Rows.Count
		if ($RowsReturned -le 0) {
			Write-Host " ->No active sessions found."
			$StepOutcome = "No active sessions"
			Add-LogRow "->Return sp_BlitzWho" $StepOutcome
		}
		else {

			##Add plan file column 
			$BlitzWhoAggTbl.Columns.Add("sqlplan_file", [string]) | Out-Null
			##Exporting execution plans to file and setting plan file names
			if ($DebugInfo) {
				Write-Host " ->Exporting execution plans" -fore yellow
			}
			$RowNum = 0
			$i = 0			
			foreach ($row in $BlitzWhoAggTbl) {
				$i += 1
				$SQLPlanFile = "-- N/A --"
				if ($BlitzWhoAggTbl.Rows[$RowNum]["query_plan"] -ne [System.DBNull]::Value) {
					
					$SQLPlanFile = "RunningNow_" + $i + ".sqlplan"
					$BlitzWhoAggTbl.Rows[$RowNum]["query_plan"] | Format-XML | Set-Content -Path "$PlanOutDir\$SQLPlanFile" -Force			
				}
				$BlitzWhoAggTbl.Rows[$RowNum]["sqlplan_file"] = $SQLPlanFile
				$RowNum += 1
			}

			#Get capture time-frame
			$BtilzWhoStartTime = $BlitzWhoTbl | Sort-Object -Property "CheckDate" | Select-Object -ExpandProperty "CheckDate" -First 1
			$BtilzWhoEndTime = $BlitzWhoTbl | Sort-Object -Property "CheckDate" -Descending | Select-Object -ExpandProperty "CheckDate" -First 1

			if ($ToHTML -eq "Y") {
				if ($DebugInfo) {
					Write-Host " ->Converting sp_BlitzWho output to HTML" -fore yellow
				}
				$HtmlTabName = "Session Activity"
				if (!([string]::IsNullOrEmpty($CheckDB))) {
					$HtmlTabName += " for $CheckDB" 
				}
				elseif ($IsAzureSQLDB) {
					$HtmlTabName += " for $ASDBName"
				}
				$htmlTable = $BlitzWhoTbl | Select-Object @{Name = "CheckDate"; Expression = { ($_."CheckDate").ToString("yyyy-MM-dd HH:mm:ss") } }, 
				@{Name = "start_time"; Expression = { ($_."start_time").ToString("yyyy-MM-dd HH:mm:ss") } },
				"elapsed_time", "database_name", "session_id", "blocking_session_id",
				#"query_text", 
				"query_cost", @{Name = "query_hash"; Expression = { Get-HexString -HexInput $_."query_hash" } }, "status", 
				"cached_parameter_info", "wait_info", "top_session_waits",
				 "open_transaction_count", "is_implicit_transaction",
				"nt_domain", "host_name", "login_name", "nt_user_name", "program_name",
				"fix_parameter_sniffing", "client_interface_name", 
				@{Name = "login_time"; Expression = { ($_."login_time").ToString("yyyy-MM-dd HH:mm:ss") } }, 
				@{Name = "request_time"; Expression = { ($_."request_time").ToString("yyyy-MM-dd HH:mm:ss") } }, 
				"request_cpu_time", "request_logical_reads", "request_writes",
				"request_physical_reads", "session_cpu", "session_logical_reads",
				"session_physical_reads", "session_writes", "tempdb_allocations_mb", 
				"memory_usage", "estimated_completion_time", "percent_complete", 
				"deadlock_priority", "transaction_isolation_level", "degree_of_parallelism",
				@{Name = "grant_time"; Expression = { ($_."grant_time").ToString("yyyy-MM-dd HH:mm:ss") } }, 
				"requested_memory_kb", "grant_memory_kb", "is_request_granted",
				"required_memory_kb", "query_memory_grant_used_memory_kb", "ideal_memory_kb",
				"is_small", "timeout_sec", "resource_semaphore_id", "wait_order", "wait_time_ms",
				"next_candidate_for_memory_grant", "target_memory_kb", "max_target_memory_kb",
				"total_memory_kb", "available_memory_kb", "granted_memory_kb",
				"query_resource_semaphore_used_memory_kb", "grantee_count", "waiter_count",
				"timeout_error_count", "forced_grant_count", "workload_group_name",
				"resource_pool_name" | ConvertTo-Html -As Table -Fragment
				$html = $HTMLPre + @"
				<title>$HtmlTabName</title>
				</head>
				<body>
				<h1>$HtmlTabName</h1>
				<br>
				$htmlTable 
				<br>
				</body>
				</html>
"@ 
				if ($DebugInfo) {
					Write-Host " - >Writing HTML file." -fore yellow
				} 

				$html | Out-File -Encoding utf8 -FilePath "$HTMLOutDir\BlitzWho.html"

				if ($DebugInfo) {
					Write-Host " ->Converting sp_BlitzWho aggregate output to HTML" -fore yellow
				}

				$BlitzWhoAggTbl.Columns.Add("Query", [string]) | Out-Null
				$RowNum = 0
				$i = 0
			
				foreach ($row in $BlitzWhoAggTbl) {
					$i += 1
					if ($BlitzWhoAggTbl.Rows[$RowNum]["query_text"] -ne [System.DBNull]::Value) {
						
						$QueryName = "RunningNow_" + $i + ".query"
					
					}
					else { $QueryName = "-- N/A --" }
					$BlitzWhoAggTbl.Rows[$RowNum]["Query"] = $QueryName
					$RowNum += 1
				}
				$HtmlTabName = "Aggregated Session Activity"
				if (!([string]::IsNullOrEmpty($CheckDB))) {
					$HtmlTabName += " for $CheckDB" 
				}
				elseif ($IsAzureSQLDB) {
					$HtmlTabName += " for $ASDBName"
				}
				#Aggregate session table
				$htmlTable = $BlitzWhoAggTbl | Select-Object @{Name = "start_time"; Expression = { ($_."start_time").ToString("yyyy-MM-dd HH:mm:ss") } }, 
				"elapsed_time", "database_name", "session_id", "blocking_session_id",  
				#"query_text", 
				"Query",
				"outer_command", "query_cost", "sqlplan_file", "status", 
				"cached_parameter_info", "wait_info", "top_session_waits",
				 "open_transaction_count", "is_implicit_transaction",
				"nt_domain", "host_name", "login_name", "nt_user_name", "program_name",
				"fix_parameter_sniffing", "client_interface_name", 
				@{Name = "login_time"; Expression = { ($_."login_time").ToString("yyyy-MM-dd HH:mm:ss") } }, 
				@{Name = "request_time"; Expression = { ($_."request_time").ToString("yyyy-MM-dd HH:mm:ss") } }, 
				"request_cpu_time", "request_logical_reads", "request_writes",
				"request_physical_reads", "session_cpu", "session_logical_reads",
				"session_physical_reads", "session_writes", "tempdb_allocations_mb", 
				"memory_usage", 
				"estimated_completion_time", 
				"percent_complete", 
				"deadlock_priority", "transaction_isolation_level", "degree_of_parallelism", 
				"grant_time",
				"requested_memory_kb", "grant_memory_kb", "is_request_granted",
				"required_memory_kb", "query_memory_grant_used_memory_kb", "ideal_memory_kb",
				"is_small", "timeout_sec", "resource_semaphore_id", "wait_order", "wait_time_ms",
				"next_candidate_for_memory_grant", "target_memory_kb", "max_target_memory_kb",
				"total_memory_kb", "available_memory_kb", "granted_memory_kb",
				"query_resource_semaphore_used_memory_kb", "grantee_count", "waiter_count",
				"timeout_error_count", "forced_grant_count", "workload_group_name",
				"resource_pool_name", 
				@{Name = "query_hash"; Expression = { Get-HexString -HexInput $_."query_hash" } },
				@{Name = "query_plan_hash"; Expression = { Get-HexString -HexInput $_."query_plan_hash" } } | ConvertTo-Html -As Table -Fragment
				$htmlTable = $htmlTable -replace '<table>', '<table class="ActiveSessionsTab">'
				$QExt = '.query'
				$FileSOrder = "RunningNow"
				$AnchorRegex = "$FileSOrder(_\d+)$QExt"
				$AnchorURL = '<a href="#$&">$&</a>'
				$htmlTable = $htmlTable -replace $AnchorRegex, $AnchorURL

				#Query table
				$htmlTable1 = $BlitzWhoAggTbl | Select-Object "Query", @{Name = "query_hash"; Expression = { Get-HexString -HexInput $_."query_hash" } },
				"query_text" | Where-Object { $_."query_text" -ne [System.DBNull]::Value } | ConvertTo-Html -As Table -Fragment
				$AnchorRegex = "<td>$FileSOrder(_\d+)$QExt"
				$AnchorURL = '<td id=' + "$FileSOrder" + '$1' + "$QExt>" + "$FileSOrder" + '$1' + "$QExt"
				$htmlTable1 = $htmlTable1 -replace $AnchorRegex, $AnchorURL

				$html = $HTMLPre + @"
				<title>$HtmlTabName</title>
				</head>
				<body>
				<h1 id="top">$HtmlTabName</h1>
				<h3 style="text-align: center;">Based on session activity captured between $($BtilzWhoStartTime.ToString("yyyy-MM-dd HH:mm:ss")) and $($BtilzWhoEndTime.ToString("yyyy-MM-dd HH:mm:ss")) server time.</h3>
				<p style="text-align: center;"><a href="#Queries">Jump to query text</a></p>
				<br>
				$htmlTable 
				<p style="text-align: center;"><a href="#top">Jump to top</a></p>
				<br>
				<h1 id="Queries">Query text</h1>
				<br>
				$htmlTable1
				<br>
				<p style="text-align: center;"><a href="#top">Jump to top</a></p>
				<br>
				</body>
				</html>
"@ 
				if ($DebugInfo) {
					Write-Host " - >Writing HTML file." -fore yellow
				}
				$html | Out-File -Encoding utf8 -FilePath "$HTMLOutDir\BlitzWho_Agg.html"

			}
			else {

				##Populating the "sp_BlitzWho" sheet
				$ExcelSheet = $ExcelFile.Worksheets.Item("Session Activity - Raw")
				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = $DefaultStartRow
				#Specify with which column in the sheet to start
				$ExcelColNum = 1
				#Set counter used for row retrieval
				$RowNum = 0

				#List of columns that should be returned from the data set
				$DataSetCols = @("CheckDate", "start_time", "elapsed_time", "database_name", "session_id",  
				"blocking_session_id", "query_text", "query_cost", "query_hash", "status", 
					"cached_parameter_info", "wait_info", "top_session_waits",
					 "open_transaction_count", "is_implicit_transaction",
					"nt_domain", "host_name", "login_name", "nt_user_name", "program_name",
					"fix_parameter_sniffing", "client_interface_name", "login_time",
					"request_time", "request_cpu_time", "request_logical_reads", "request_writes",
					"request_physical_reads", "session_cpu", "session_logical_reads",
					"session_physical_reads", "session_writes", "tempdb_allocations_mb", 
					"memory_usage", "estimated_completion_time", "percent_complete", 
					"deadlock_priority", "transaction_isolation_level", "degree_of_parallelism",
					"grant_time", "requested_memory_kb", "grant_memory_kb", "is_request_granted",
					"required_memory_kb", "query_memory_grant_used_memory_kb", "ideal_memory_kb",
					"is_small", "timeout_sec", "resource_semaphore_id", "wait_order", "wait_time_ms",
					"next_candidate_for_memory_grant", "target_memory_kb", "max_target_memory_kb",
					"total_memory_kb", "available_memory_kb", "granted_memory_kb",
					"query_resource_semaphore_used_memory_kb", "grantee_count", "waiter_count",
					"timeout_error_count", "forced_grant_count", "workload_group_name",
					"resource_pool_name")

				if ($DebugInfo) {
					Write-Host " ->Writing sp_BlitzWho results to Excel" -fore yellow
				}
				#Loop through each Excel row
				foreach ($row in $BlitzWhoTbl) {
					<#
			Loop through each data set column of current row and fill the corresponding 
			Excel cell
			#>
					foreach ($col in $DataSetCols) {
						#Fill Excel cell with value from the data set
						if ("CheckDate", "start_time", "login_time", "request_time" -contains $col) {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $BlitzWhoTbl.Rows[$RowNum][$col].ToString("yyyy-MM-dd HH:mm:ss")
						}
						elseif ("query_hash", "query_plan_hash" -Contains $col) {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = Get-HexString -HexInput $BlitzWhoTbl.Rows[$RowNum][$col]
						}
						else {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $BlitzWhoTbl.Rows[$RowNum][$col]
						}
						$ExcelColNum += 1
					}
					#move to the next row in the spreadsheet
					$ExcelStartRow += 1
					#move to the next row in the data set
					$RowNum += 1
					# reset Excel column number so that next row population begins with column 1
					$ExcelColNum = 1
				}
				##Saving file 
				$ExcelFile.Save()

				##Populating the "sp_BlitzWho Aggregate" sheet
				$ExcelSheet = $ExcelFile.Worksheets.Item("Session Activity - Aggregated")
				#Add session capture interval
				$ExcelSheet.Cells.Item(1, 6) =$BtilzWhoStartTime.ToString("yyyy-MM-dd HH:mm:ss")
				$ExcelSheet.Cells.Item(1, 8) =$BtilzWhoEndTime.ToString("yyyy-MM-dd HH:mm:ss")

				#Specify at which row in the sheet to start adding the data
				$ExcelStartRow = 3
				#Specify with which column in the sheet to start
				$ExcelColNum = 1
				#Set counter used for row retrieval
				$RowNum = 0

				#List of columns that should be returned from the data set
				$DataSetCols = @("start_time", "elapsed_time", "database_name", "session_id",
				"blocking_session_id",  
					"query_text", "outer_command", "query_cost", "sqlplan_file", "status", 
					"cached_parameter_info", "wait_info", "top_session_waits",
					 "open_transaction_count", "is_implicit_transaction",
					"nt_domain", "host_name", "login_name", "nt_user_name", "program_name",
					"fix_parameter_sniffing", "client_interface_name", "login_time", 
					"request_time", "request_cpu_time", "request_logical_reads", "request_writes",
					"request_physical_reads", "session_cpu", "session_logical_reads",
					"session_physical_reads", "session_writes", "tempdb_allocations_mb", 
					"memory_usage", "estimated_completion_time", "percent_complete", 
					"deadlock_priority", "transaction_isolation_level", "degree_of_parallelism",
					"grant_time", "requested_memory_kb", "grant_memory_kb", "is_request_granted",
					"required_memory_kb", "query_memory_grant_used_memory_kb", "ideal_memory_kb",
					"is_small", "timeout_sec", "resource_semaphore_id", "wait_order", "wait_time_ms",
					"next_candidate_for_memory_grant", "target_memory_kb", "max_target_memory_kb",
					"total_memory_kb", "available_memory_kb", "granted_memory_kb",
					"query_resource_semaphore_used_memory_kb", "grantee_count", "waiter_count",
					"timeout_error_count", "forced_grant_count", "workload_group_name",
					"resource_pool_name", "query_hash", "query_plan_hash")

				if ($DebugInfo) {
					Write-Host " ->Writing sp_BlitzWho aggregate results to Excel" -fore yellow
				}
				#Loop through each Excel row
				foreach ($row in $BlitzWhoAggTbl) {
					<#
			Loop through each data set column of current row and fill the corresponding 
			Excel cell
			#>
					foreach ($col in $DataSetCols) {
						#Fill Excel cell with value from the data set
						#Properly handling Query Hash and Plan Hash hex values 
						if ("query_hash", "query_plan_hash" -Contains $col) {
							$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = Get-HexString -HexInput $BlitzWhoAggTbl.Rows[$RowNum][$col]
							#move to the next column
							$ExcelColNum += 1
							#move to the top of the loop
							Continue
						}
						$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $BlitzWhoAggTbl.Rows[$RowNum][$col]
						$ExcelColNum += 1
					}
					#move to the next row in the spreadsheet
					$ExcelStartRow += 1
					#move to the next row in the data set
					$RowNum += 1
					# reset Excel column number so that next row population begins with column 1
					$ExcelColNum = 1
				}
				##Saving file 
				$ExcelFile.Save()
			}
		}
		##Cleaning up variables
		Remove-Variable -Name BlitzWhoTbl
		Remove-Variable -Name BlitzWhoAggTbl
		Remove-Variable -Name BlitzWhoSet
	}
	$SqlConnection.Close()
	$SqlConnection.Dispose()

	#####################################################################################
	#						Delete unused sheets 										#
	#####################################################################################
	$StepStart = get-date
	$StepEnd = Get-Date
	Add-LogRow "Check end" "Finished"

	if ($ToHTML -ne "Y") {
		if ($IsIndepth -ne "Y") {
			$DeleteSheets = @("Wait Stats", "Storage Stats", "Perfmon Stats", "Index Summary",
				"Index Usage", "Extended Index Diagnostics", 
				"Top Queries - Reads", "Top Queries - Executions", "Top Queries - Writes",
				"Top Queries - Spills", "Top Queries - Mem & Recent Comp", "Intro")
			foreach ($SheetName in $DeleteSheets) {
				$ExcelSheet = $ExcelFile.Worksheets.Item($SheetName)
				#$ExcelSheet.Visible = $false
				$ExcelSheet.Delete()
			}
			if ($IsAzureSQLDB) {
				#Delete the "Database Info" and sp_Blitz rows in the Intro sheet
				$ExcelSheetUpd = $ExcelFile.Worksheets.Item("Intro ")
				$ExcelSheetUpd.Cells.Item(13, 1).EntireRow.Delete() | Out-Null
				$ExcelSheetUpd.Cells.Item(12, 1).EntireRow.Delete() | Out-Null
				$ExcelSheetUpd.Cells.Item(11, 1).EntireRow.Delete() | Out-Null		
				
				$DeleteSheets = @("Database Info", "Instance Health", "DB Scoped Config")
				foreach ($SheetName in $DeleteSheets) {
					$ExcelSheet = $ExcelFile.Worksheets.Item($SheetName)
					$ExcelSheet.Delete()
				}
			}
			elseif ($IsAzureSQLDB -eq $false) {
				if (($MajorVers -lt 13) -or ([string]::IsNullOrEmpty($CheckDB))) {
					$ExcelSheetUpd = $ExcelFile.Worksheets.Item("Intro ")
					$ExcelSheetUpd.Cells.Item(12, 1).EntireRow.Delete() | Out-Null
					$ExcelSheet = $ExcelFile.Worksheets.Item("DB Scoped Config")
					$ExcelSheet.Delete()
				}
				#delete the Azure SQL DB Info row
				$ExcelSheetUpd = $ExcelFile.Worksheets.Item("Intro ")
				$ExcelSheetUpd.Cells.Item(10, 1).EntireRow.Delete() | Out-Null
				$ExcelSheet = $ExcelFile.Worksheets.Item("Azure SQL DB Info")
				$ExcelSheet.Delete()
			}
		}
		else {
			#Delete unused sheet (yes, this sheet has a space in its name)
			$DeleteSheets = @("Intro ", "Index Diagnostics")
			foreach ($SheetName in $DeleteSheets) {
				$ExcelSheet = $ExcelFile.Worksheets.Item($SheetName)
				$ExcelSheet.Delete()
			}

			if ($IsAzureSQLDB) {
				#Delete the "Database Info" and sp_Blitz rows in the Intro sheet
				$ExcelSheetUpd = $ExcelFile.Worksheets.Item("Intro")
				$ExcelSheetUpd.Cells.Item(13, 1).EntireRow.Delete() | Out-Null
				$ExcelSheetUpd.Cells.Item(12, 1).EntireRow.Delete() | Out-Null
				$ExcelSheetUpd.Cells.Item(11, 1).EntireRow.Delete() | Out-Null
				$DeleteSheets = @("Database Info", "Instance Health", "DB Scoped Config")
				foreach ($SheetName in $DeleteSheets) {
					$ExcelSheet = $ExcelFile.Worksheets.Item($SheetName)
					$ExcelSheet.Delete()
				}
			}
			elseif ($IsAzureSQLDB -eq $false) {
				if (($MajorVers -lt 13) -or ([string]::IsNullOrEmpty($CheckDB))) {
					$ExcelSheetUpd = $ExcelFile.Worksheets.Item("Intro")
					$ExcelSheetUpd.Cells.Item(12, 1).EntireRow.Delete() | Out-Null
					$ExcelSheet = $ExcelFile.Worksheets.Item("DB Scoped Config")
					$ExcelSheet.Delete()
				}
				#delete the Azure SQL DB Info row
				$ExcelSheetUpd = $ExcelFile.Worksheets.Item("Intro")
				$ExcelSheetUpd.Cells.Item(10, 1).EntireRow.Delete() | Out-Null
				$ExcelSheet = $ExcelFile.Worksheets.Item("Azure SQL DB Info")
				$ExcelSheet.Delete()
			}

		}

		if (([string]::IsNullOrEmpty($CheckDB)) -and ([string]::IsNullOrEmpty($DBName)) -and ($IsAzureSQLDB -eq $false)) {
			$DeleteSheets = @("Statistics Info", "Index Fragmentation")
			foreach ($SheetName in $DeleteSheets) {
				$ExcelSheet = $ExcelFile.Worksheets.Item($SheetName)
				$ExcelSheet.Delete()
			}
		}

		##Insert log data in Excel
		##Populating the "ExecutionLog" sheet
		$ExcelSheet = $ExcelFile.Worksheets.Item("ExecutionLog")
		#Specify at which row in the sheet to start adding the data
		$ExcelStartRow = $DefaultStartRow
		#Specify with which column in the sheet to start
		$ExcelColNum = 1
		#Set counter used for row retrieval
		$RowNum = 0
		$DataSetCols = @("Step", "StartDate", "EndDate", "Duration", "Outcome", "ErrorMsg")
		if ($DebugInfo) {
			Write-Host " ->Writing Execution Log to Excel" -fore yellow
		}
		#Loop through each Excel row
		foreach ($row in $LogTbl) {

			foreach ($col in $DataSetCols) {
				$ExcelSheet.Cells.Item($ExcelStartRow, $ExcelColNum) = $LogTbl.Rows[$RowNum][$col]
				$ExcelColNum += 1
			}
			#move to the next row in the spreadsheet
			$ExcelStartRow += 1
			#move to the next row in the data set
			$RowNum += 1
			# reset Excel column number so that next row population begins with column 1
			$ExcelColNum = 1
		}
		##Saving file 
		$ExcelFile.Save()
	}

	#####################################################################################
	#							Check end												#
	#####################################################################################
	###Record execution start and end times
	$EndDate = get-date
	if ($ToHTML -ne "Y") {
		if ($IsIndepth -eq "Y") {
			$ExcelSheet = $ExcelFile.Worksheets.Item("Intro")
		}
		else {
			$ExcelSheet = $ExcelFile.Worksheets.Item("Intro ")
		}
		$ExcelSheet.Cells.Item(5, 6) = $StartDate.ToString("yyyy-MM-dd HH:mm:ss")
		$ExcelSheet.Cells.Item(6, 6) = $EndDate.ToString("yyyy-MM-dd HH:mm:ss")
		$ExcelSheet.Cells.Item(6, 4) = $Vers

		###Save and close Excel file and app
		$ExcelFile.Save()
	}

	$ExecTime = (New-TimeSpan -Start $StartDate -End $EndDate).ToString()
	$ExecTime = $ExecTime.Substring(0, $ExecTime.IndexOf('.'))
	if ($ToHTML -eq "Y") {
		if ($DebugInfo) {
			Write-Host " ->Generating index and execution log pages." -fore yellow
		} 
		$HtmlTabName = "PSBlitz Execution Log"
		$htmlTable = $LogTbl | Select-Object "Step", "StartDate", "EndDate", 
		@{Name = "Duration (Seconds)"; Expression = { $_."Duration" } }, "Outcome", 
		@{Name = "Message"; Expression = { $_."ErrorMsg" } } | ConvertTo-Html -As Table -Fragment
		$html = $HTMLPre + @"
						<title>$HtmlTabName</title>
						</head>
						<body>
						<h1 id="top">$HtmlTabName</h1>
		<br>
						$htmlTable 
		<br>
						</body>
						</html>
"@ 
		$html | Out-File -Encoding utf8 -FilePath "$HTMLOutDir\ExecutionLog.html"
		$AzureEnv = ""
		if ($IsAzureSQLMI) {
			$AzureEnv = "- Azure SQL MI"
		}
		elseif ($IsAzureSQLDB) {
			$AzureEnv = "- Azure SQL DB"
			$DbPortion = "- $ASDBName"
		}
		if (!([string]::IsNullOrEmpty($CheckDB))) {
			$DbPortion = "- database-specific check: $CheckDB"
		}
		else {
			$DbPortion = "- instance-wide check"
		}
		$IndexContent = @"
				<!DOCTYPE html>
				<html>
				<head>
				<style>
				body { 
					background-color:#FFFFFF;
					font-family:Tahoma;
					font-size:11pt; 
				}
				table {
					margin-left: auto;
					margin-right: auto;
					border-spacing: 1px;
    }
    th {
					background-color: dodgerblue;
					color: white;
					font-weight: bold;
					padding: 5px;
					text-align: center;
    }
    td, th {
					border: 1px solid black;
					padding: 5px;
    }
	tr:hover{
		background-color: rgba(255, 255, 0, 0.4);
	}
    td:first-child {
					font-weight: bold;
					text-align: left;
    }
    h1 {
					text-align: center;
    }
    h2 {
					text-align: center;
    }
	footer{
		text-align: center;
		margin-left: auto;
		margin-right: auto;
	}
				</style>
				<title>PSBlitz Output For $InstName</title>
				</head>
				<body>
    <h1>PSBlitz Output For $($InstName.Replace(".database.windows.net", "")) $AzureEnv $DbPortion</h1>
    <table>
				<tr>
				<th>Generated With</th>
				<th>Version</th>
				<th>Execution start</th>
				<th>Execution end</th>
				<th>Duration (hh:mm:ss)</th>
				</tr>
				<tr>
				<td><a href='https://github.com/VladDBA/PSBlitz' target='_blank'>PSBlitz.ps1</a></td>
				<td>$Vers</td>
				<td>$($StartDate.ToString("yyyy-MM-dd HH:mm:ss"))</td>
				<td>$($EndDate.ToString("yyyy-MM-dd HH:mm:ss"))</td>
				<td>$ExecTime</td>
				</tr>
    </table>
    <br>
    <h1>Table of contents</h1>
    <table>
				<tr>
				<th>Page Name</th>
				<th>Description</th>
				<th>Query Source</th>
				<th>Additional info</th>
				</tr>
"@

		# Build an HTML file that acts as the index pointing to all the HTML files that make up the report	
		$HtmlFiles = Get-ChildItem -Path $HTMLOutDir -Filter *.html | Sort-Object CreationTime
		foreach ($File in $HtmlFiles) {
			$AdditionalInfo = ""
			# Get the file name without the extension and replace any underscores with spaces for the description.
			$Description = $File.BaseName.Replace("_", " ")
			# Create a row in the table with a link to the file and its description.
			$RelativePath = $File.Name
			$RelativePath = ".\HTMLFiles\" + $RelativePath
			if ($File.Name -eq "spBlitz.html") {
				$Description = "Instance-level health information"
				$PageName = "Instance Health"
				if ($IsIndepth -eq "Y") {
					$QuerySource = "sp_Blitz @CheckServerInfo = 1, @CheckUserDatabaseObjects = 1; "
					$Description += " including a review of user databases for triggers, heaps, etc"
				}
				else {
					$QuerySource = "sp_Blitz @CheckServerInfo = 1; "
				}
				$Description += "."
			}
			elseif ($File.Name -like "InstanceInfo*") {
				$PageName = "Instance Info"
				$QuerySource = "sys.dm_os_sys_info, sys.dm_os_performance_counters and SERVERPROPERTY()"
				$Description = "Summary information about the instance and its resources."
				$AdditionalInfo = ""
			}
			elseif ($File.Name -like "TempDBInfo*") {
				$PageName = "TempDB Info"
				$QuerySource = "dm_db_file_space_usage, dm_db_partition_stats, dm_exec_requests"
				$Description = "Information pertaining to TempDB usage, size and configuration."
				$AdditionalInfo = ""
			}
			elseif ($File.Name -like "OpenTransactions*") {
				$PageName = "Open Transactions"
				$QuerySource = "sys.dm_tran_session_transactions, sys.dm_tran_active_transactions, sys.dm_exec_sessions, sys.dm_exec_connections, and sys.dm_exec_requests"
				$Description = "Information about currently open transactions"
				if (!([string]::IsNullOrEmpty($CheckDB))) {
					$Description += " for $CheckDB."
				}
				else {
					$Description += "."
				}
				$AdditionalInfo = "Outputs execution plans as .sqlplan files."
			}
			elseif ($File.Name -like "BlitzIndex*") {
				$Mode = $File.Name.Replace('BlitzIndex_', '')
				$Mode = $Mode.Replace('.html', '')
				$QuerySource = "sp_BlitzIndex @Mode = $Mode"
				if (!([string]::IsNullOrEmpty($CheckDB))) {
					$QuerySource += ", @DatabaseName = '$CheckDB'; "
				}
				else {
					$QuerySource += ", @GetAllDatabases = 1; "
				}
				$AdditionalInfo = ""
				if (($File.Name -like "BlitzIndex_0*") -or ($File.Name -like "BlitzIndex_4*")) {
					$PageName = "Index Diagnostics"
					if($File.Name -like "BlitzIndex_4*"){
						$PageName = "Extended $PageName"
					}
					$Description = "Index-related diagnosis outlining high-value missing indexes, duplicate or almost duplicate indexes, indexes with more writes than reads, etc."
					$AdditionalInfo += "For SQL Server 2019 - will output execution plans as .sqlplan files."
				}
				elseif ($File.Name -like "BlitzIndex_1*") {
					$PageName = "Index Summary"
					$Description = "Summary of database, tables and index sizes and counts."
				}
				elseif ($File.Name -like "BlitzIndex_2*") {
					$PageName = "Index Usage"
					$Description = "Index usage details."
				}
			}
			elseif ($File.Name -like "BlitzCache*") {
				$SortOrder = $File.Name.Replace('BlitzCache_', '')
				$SortOrder = $SortOrder.Replace('.html', '')
				$PageName = "Top $CacheTop Queries - $SortOrder"
				$AdditionalInfo = "Outputs execution plans as .sqlplan files."
				if ($SortOrder -eq "Mem_Recent_Comp") {
					$PageName = "Top $CacheTop Queries - Memory and Recently Compiled"
					$QuerySource = "sp_BlitzCache @SortOrder = 'memory grant', @Top = $CacheTop/'recent compilations' , @Top = 50"
					if (!([string]::IsNullOrEmpty($CheckDB))) {
						$QuerySource += ", @DatabaseName = '$CheckDB'; "
					}
					else {
						$QuerySource += "; "
					}
					$Description = "Contains the top $CacheTop queries, found in the plan cache, sorted by memory grant size, and the top 50 most recently compiled queries"
					if (!([string]::IsNullOrEmpty($CheckDB))) {
						$Description += " for $CheckDB."
					}
					elseif ($IsAzureSQLDB) {
						$Description += " for $ASDBName"
					}
					else {
						$Description += "."
					}
				}
				else {
					$QuerySource = "sp_BlitzCache , @Top = $CacheTop, @SortOrder = '$SortOrder'/'avg $SortOrder'"
					if (!([string]::IsNullOrEmpty($CheckDB))) {
						$QuerySource += ", @DatabaseName = '$CheckDB'; "
					}
					else {
						$QuerySource += "; "
					}
					$Description = "Contains the top $CacheTop queries, found in the plan cache, sorted by $SortOrder and Average $SortOrder"
					if ($IsAzureSQLDB) {
						$Description += " for $ASDBName."
					}
					elseif (!([string]::IsNullOrEmpty($CheckDB))) {
						$Description += " for $CheckDB."
					}
					else {
						$Description += "."
					}
				}
			}
			elseif ($File.Name -like "BlitzFirst3*") {
				$QuerySource = "sp_BlitzFirst @ExpertMode = 1, @Seconds = 30; "
				$Description = "What's happening on the instance during a 30 seconds time-frame."
				$PageName = "Happening Now"
				$AdditionalInfo = ""
			}
			elseif ($File.Name -like "BlitzFirst_*") {
				$QuerySource = "sp_BlitzFirst @SinceStartup = 1;"
				if ($File.Name -like "BlitzFirst_Perfmon*") {
					$PageName = "Perfmon Stats"
					$Description = "Performance counters and their curent values since last instance restart from sys.dm_os_performance_counters."
				}
				elseif ($File.Name -like "BlitzFirst_Storage*") {
					$PageName = "Storage Stats"
					$Description = "Information about each database's files, their usage an throughput since last instance restart."
				}
				elseif ($File.Name -like "BlitzFirst_Waits*") {
					$PageName = "Wait Stats"
					$Description = "Information about wait stats recorded since last instance restart."
				}
				$AdditionalInfo = ""
			}
			elseif ($File.Name -like "BlitzWho*") {
				$QuerySource = "sp_BlitzWho @ExpertMode = 1"
				if (!([string]::IsNullOrEmpty($CheckDB))) {
					$QuerySource += ", @DatabaseName = '$CheckDB'; "
				}
				else {
					$QuerySource += "; "
				}
				if ($File.Name -like "BlitzWho_Agg*") {
					$Description = "Aggregate of all the sp_BlitzWho passes sorted by duration descending."
					$PageName = "Session Activity - Aggregated"
					$AdditionalInfo = "Outputs execution plans as .sqlplan files."
				}
				else {
					$PageName = "Session Activity - Raw"
					$Description = "All the data that was collected repeatedly by sp_BlitzWho while PSBlitz was running."
				}
			}
			elseif ($File.Name -like "StatsInfo*") {
				$PageName = "Statistics Information"
				$QuerySource = "sys.stats, sys.dm_db_stats_properties, dm_db_incremental_stats_properties"
				$Description = "Statistics information for "
				if ($IsAzureSQLDB) {
					$Description += "$ASDBName."
				} elseif ($DBSwitched -eq "Y"){
					$Description += "$DBName"
				}
				else {
					$Description += "$CheckDB."
				}
				$AdditionalInfo = "Retrieves info for tables with at least 10k records"
			}
			elseif ($File.Name -like "IndexFragInfo*") {
				$QuerySource = "dm_db_index_physical_stats"
				$PageName = "Index Fragmentation"
				$Description = "Index fragmentation information for "
				if ($IsAzureSQLDB) {
					$Description += "$ASDBName."
				} elseif ($DBSwitched -eq "Y"){
					$Description += "$DBName"
				}
				else {
					$Description += "$CheckDB."
				}
				$AdditionalInfo = "Retrieves info for tables containing at least 52k pages (~400MB)"
			}
			elseif ($File.Name -like "BlitzLock*") {
				$PageName = "Deadlock Info"
				$QuerySource = "sp_BlitzLock @StartDate = DATEADD(DAY, -15, GETDATE()), @EndDate = GETDATE(); "
				$Description = "Information about the deadlocks recorded in the default extended events session."
				$AdditionalInfo = "Outputs deadlock graphs as .xdl files and execution plans as .sqlplan files."
			}
			elseif ($File.Name -like "ExecutionLog*") {
				$QuerySource = ""
				$PageName = "Execution Log"
				$Description = "Log for the current run of PSBlitz."
				$AdditionalInfo = "Contains step status and any error messages that might have been thrown"
			}
			elseif ($File.Name -like "DatabaseInfo*") {
				$PageName = "Database Info"
				$QuerySource = "sys.databases, sys.master_files, sys.database_files, sys.dm_db_log_info"
				if (($MajorVers -ge 13) -and (!([string]::IsNullOrEmpty($CheckDB)))) {
					$QuerySource += ", sys.database_scoped_configurations"
				}
				$Description = "Database info and database files info for "
				if (!([string]::IsNullOrEmpty($CheckDB))) {
					$Description += "$CheckDB."
				}
				else {
					$Description += "all databases on the instance."
				}
			
				$AdditionalInfo = ""
			}
			elseif ($File.Name -like "AzureSQLDBInfo*") {
				$PageName = "Azure SQL DB Info"
				$QuerySource = "sys.dm_user_db_resource_governance, sys.database_files, sys.dm_db_resource_stats, sys.dm_db_wait_stats, sys.databases, database_scoped_configurations, sys.dm_db_objects_impacted_on_version_change"
				$Description = "Azure SQL DB resources, resource and database usage, and database configuration for $ASDBName"
			
				$AdditionalInfo = ""
			}
			elseif ($File.Name -like "BlitzQueryStore*") {
				$PageName = "Query Store Info"
				if ($IsAzureSQLDB) {
					$QuerySource = "sp_BlitzQueryStore;"
				} elseif ($DBSwitched -eq "Y"){
					$QuerySource = "sp_BlitzQueryStore @DatabaseName = '$DBName';"
				}
				else {
					$QuerySource = "sp_BlitzQueryStore @DatabaseName = '$CheckDB';"
				}
				$Description = "Data collected by the query store for the past 7 days"
				$AdditionalInfo = "Outputs execution plans as .sqlplan files."
			}
			$IndexContent += "<tr><td><a href='$RelativePath' target='_blank'>$PageName</a></td><td>$Description</td><td>$QuerySource</td><td>$AdditionalInfo</td></tr>"
		}

		# Close the HTML tags.
		$IndexContent += @"
    </table>
				<br>
				<br>
				<br>
				<footer>  
				<p>Report generated with <a href='https://github.com/VladDBA/PSBlitz' target='_blank'>PSBlitz</a> - created by <a href='https://vladdba.com/' target='_blank'>Vlad Drumea</a></p>
				</footer>  
				</body>
				</html>
"@
		if (!([string]::IsNullOrEmpty($CheckDB))) {
			$IndexFile = "PSBlitzOutput_$InstName_$CheckDB.html"
		}
		else {
			$IndexFile = "PSBlitzOutput_$InstName.html"
		}
		if ($DebugInfo) {
			Write-Host " ->Writing HTML file." -fore yellow
		} 
		$IndexContent | Out-File -Encoding utf8 -FilePath "$OutDir\$IndexFile"
	}
	Write-Host $("-" * 80)
	Write-Host "Execution completed in: " -NoNewLine
	Write-Host $ExecTime -fore green
	if ($OutDir.Length -gt 40) {
		Write-Host "Generated files have been saved in: "
		Write-Host " $OutDir\"
	}
 else {
		Write-Host "Generated files have been saved in: " -NoNewLine
		Write-Host "$OutDir\"
	}
	
	if ($ToHTML -ne "Y") {
		$ExcelFile.Close()
		$ExcelApp.Quit()
		[System.Runtime.Interopservices.Marshal]::ReleaseComObject($ExcelApp) | Out-Null
		Remove-Variable -Name ExcelApp
		###Rename output file 
		if (!([string]::IsNullOrEmpty($CheckDB))) {
			$OutExcelFName = "PSBlitzOutput_$InstName_$CheckDB.xlsx"
		}
		else {
			$OutExcelFName = "PSBlitzOutput_$InstName.xlsx"
		}
		Rename-Item -Path $OutExcelF -NewName $OutExcelFName
	}
	if ($ZipOutput -eq "Y") {
		Compress-Archive -Path "$OutDir" -DestinationPath "$OutDir\..\$ZipFile"
		
		if ($ZipFile.Length -gt 30) {
			Write-Host "The following zip archive has also been created: "
			Write-Host " $ZipFile"
		}
	 else {
			Write-Host "The following zip archive has also been created: " -NoNewLine
			Write-Host " $ZipFile"
		}
	}
	Write-Host " "
	Write-Host $("-" * 80)

	if ($InteractiveMode -eq 1) {
		Read-Host -Prompt "Done. Press Enter to close this window."
	}
	$SqlConnection.Close()
	$SqlConnection.Dispose()
	Remove-Variable -Name SqlConnection
	if (!([string]::IsNullOrEmpty($SQLLogin)) ) {
		#remove plain text password from memory
		[System.Runtime.InteropServices.Marshal]::ZeroFreeBSTR($BSTR)
	}
}
## Experimental fix for https://github.com/VladDBA/PSBlitz/issues/161
Remove-Variable * -ErrorAction SilentlyContinue
$error.Clear();